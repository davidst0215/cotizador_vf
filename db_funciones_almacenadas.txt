==========================================================================================
FUNCIONES Y PROCEDIMIENTOS ALMACENADOS EN SCHEMA 'silver'
Base de datos: tdv
Host: 18.118.59.50
Total de funciones: 28
==========================================================================================


1. =====================================================================================
NOMBRE: create_bd_finanzas
SCHEMA: silver
ARGUMENTOS: IN p_ano_inicio character varying, IN p_mes_inicio character varying, IN p_ano_fin character varying, IN p_mes_fin character varying, IN p_moneda character DEFAULT 'S'::bpchar

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.create_bd_finanzas(IN p_ano_inicio character varying, IN p_mes_inicio character varying, IN p_ano_fin character varying, IN p_mes_fin character varying, IN p_moneda character DEFAULT 'S'::bpchar)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    v_ano_actual VARCHAR;
    v_mes_actual VARCHAR;
    v_contador INTEGER := 0;
    v_total_registros INTEGER := 0;
BEGIN
    -- Crear o reemplazar la tabla TEMPORAL con TODOS los campos
    DROP TABLE IF EXISTS silver.bd_finanzas_temp;
    
    CREATE TABLE silver.bd_finanzas_temp (
        ano VARCHAR,
        mes VARCHAR,
        clase VARCHAR,
        fecha VARCHAR,
        factura VARCHAR,
        cliente VARCHAR,
        po VARCHAR,
        estilo_cliente VARCHAR,
        op VARCHAR,
        prendas NUMERIC,
        importe NUMERIC,
        estilo_propio VARCHAR,
        tipo_prenda VARCHAR
    );

    RAISE NOTICE 'Iniciando proceso para a√±o % mes % hasta a√±o % mes %', 
                 p_ano_inicio, p_mes_inicio, p_ano_fin, p_mes_fin;

    -- Variables para iterar
    v_ano_actual := p_ano_inicio;
    v_mes_actual := p_mes_inicio;

    -- Loop para procesar cada mes
    WHILE (v_ano_actual || v_mes_actual)::INTEGER <= (p_ano_fin || p_mes_fin)::INTEGER LOOP
        
        RAISE NOTICE 'Procesando: A√±o %, Mes %', v_ano_actual, v_mes_actual;
        
        -- Limpiar tablas temporales si existen
        DROP TABLE IF EXISTS detalle_ventas;
        DROP TABLE IF EXISTS ventas;
        
        -- Crear tabla temporal #DETALLE_VENTAS
        CREATE TEMP TABLE detalle_ventas AS
        SELECT 
            B.ser_docum || '-' || B.num_docum_ventas AS num_docum_ventas,
            B.fec_emidoc,
            A.num_prendas,
            A.cod_cliente,
            A.cod_purord,
            A.cod_lotpurord,
            A.cod_estcli,
            A.num_corre,
            A.secuencia,
            B.tipo_cambio,
            B.cod_moneda
        FROM bronze.cn_ventas_prendas A 
        INNER JOIN bronze.cn_ventas B ON A.num_corre = B.num_corre 
        WHERE B.ano_registro = v_ano_actual 
          AND B.mes_registro = v_mes_actual;

        -- Crear tabla temporal #VENTAS
        CREATE TEMP TABLE ventas AS
        SELECT 
            A.fec_emidoc,
            A.num_docum_ventas,
            A.cod_cliente,
            A.cod_purord,
            A.cod_lotpurord,
            A.cod_estcli,
            C.cod_ordpro,
            SUM(A.num_prendas) AS prendas,
            
            -- ============================================================
            -- CAMPO IMPORTE COMENTADO TEMPORALMENTE
            -- Funci√≥n utilizada: bronze.cn_ventas_obtiene_precio_fob(num_corre, secuencia)
            -- Para descomentar, quitar los comentarios de las l√≠neas siguientes:
            -- ============================================================
            /*
            CASE 
                WHEN p_moneda = 'D' THEN 
                    SUM(CASE 
                        WHEN A.cod_moneda = 'SOL' 
                        THEN bronze.cn_ventas_obtiene_precio_fob(A.num_corre, A.secuencia) / NULLIF(A.tipo_cambio, 0)
                        ELSE bronze.cn_ventas_obtiene_precio_fob(A.num_corre, A.secuencia) 
                    END)
                ELSE 
                    SUM(CASE 
                        WHEN A.cod_moneda = 'SOL' 
                        THEN bronze.cn_ventas_obtiene_precio_fob(A.num_corre, A.secuencia) 
                        ELSE bronze.cn_ventas_obtiene_precio_fob(A.num_corre, A.secuencia) * A.tipo_cambio 
                    END)
            END AS importe,
            */
            -- ============================================================
            -- MIENTRAS TANTO, IMPORTE = 0
            -- ============================================================
            0::NUMERIC AS importe,
            -- ============================================================
            
            CASE 
                WHEN B.cod_clapurord IN ('PO','S2') THEN '1-PRODUCCION/SALDOS' 
                ELSE '2-MUESTRAS' 
            END AS cod_clapurord
        FROM detalle_ventas A 
        INNER JOIN bronze.tg_lotestpro C ON 
            A.cod_cliente = C.cod_cliente 
            AND A.cod_purord = C.cod_purord
            AND A.cod_lotpurord = C.cod_lotpurord
            AND A.cod_estcli = C.cod_estcli
        INNER JOIN bronze.tg_purord B ON 
            A.cod_cliente = B.cod_cliente 
            AND A.cod_purord = B.cod_purord    
        WHERE B.cod_clapurord IN ('PO', 'S2', 'S1', 'MU')
        GROUP BY 
            A.num_docum_ventas, 
            A.cod_cliente, 
            A.cod_purord, 
            A.cod_lotpurord, 
            A.cod_estcli, 
            C.cod_ordpro, 
            A.fec_emidoc, 
            B.cod_clapurord;

        -- Insertar datos en la tabla TEMPORAL (con todos los campos)
        INSERT INTO silver.bd_finanzas_temp
        SELECT 
            v_ano_actual AS ano,
            v_mes_actual AS mes,
            V.cod_clapurord AS clase,
            TO_CHAR(V.fec_emidoc, 'DD/MM/YYYY') AS fecha,
            V.num_docum_ventas AS factura,
            COALESCE(C.nom_cliente, '') AS cliente,
            V.cod_purord AS po,
            V.cod_estcli AS estilo_cliente,
            V.cod_ordpro AS op,
            V.prendas,
            V.importe,  -- Por ahora = 0
            COALESCE(O.cod_estpro, '') AS estilo_propio,
            COALESCE(bronze.es_muestra_tipo_prenda_por_np('001', V.cod_ordpro), '') AS tipo_prenda
        FROM ventas V
        LEFT JOIN bronze.es_ordpro O 
            ON V.cod_ordpro = O.cod_ordpro 
            AND O.cod_fabrica = '001'
        LEFT JOIN bronze.tg_cliente C 
            ON V.cod_cliente = C.cod_cliente
        ORDER BY 
            V.cod_clapurord, 
            V.fec_emidoc, 
            V.num_docum_ventas, 
            V.cod_purord, 
            V.cod_ordpro;

        -- Contar registros insertados
        GET DIAGNOSTICS v_contador = ROW_COUNT;
        v_total_registros := v_total_registros + v_contador;
        
        RAISE NOTICE 'A√±o % Mes %: % registros insertados en tabla temporal', v_ano_actual, v_mes_actual, v_contador;

        -- Incrementar mes
        v_mes_actual := LPAD((v_mes_actual::INTEGER + 1)::TEXT, 2, '0');
        
        -- Si llegamos a mes 13, incrementar a√±o y resetear mes
        IF v_mes_actual::INTEGER > 12 THEN
            v_ano_actual := (v_ano_actual::INTEGER + 1)::TEXT;
            v_mes_actual := '01';
        END IF;

    END LOOP;

    -- Limpiar tablas temporales
    DROP TABLE IF EXISTS detalle_ventas;
    DROP TABLE IF EXISTS ventas;
    
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Datos cargados en tabla temporal';
    RAISE NOTICE 'Generando tabla final AGRUPADA POR OP...';
    RAISE NOTICE '========================================';

    -- ============================================================
    -- CREAR TABLA FINAL AGRUPADA POR OP CON NUEVOS NOMBRES Y COLUMNAS
    -- VERSION 2.3
    -- ============================================================
    DROP TABLE IF EXISTS silver.bd_finanzas;
    
    CREATE TABLE silver.bd_finanzas AS
    SELECT 
        -- 1. cod_ordpro (antes: op)
        op AS cod_ordpro,
        
        -- 2. cliente (mantiene nombre)
        MIN(cliente) AS cliente,
        
        -- 3. tipo_de_producto (antes: tipo_prenda)
        MIN(tipo_prenda) AS tipo_de_producto,
        
        -- 4. familia_de_productos (nuevo - vac√≠o)
        ''::VARCHAR AS familia_de_productos,
        
        -- 5. temporada (nuevo - vac√≠o)
        ''::VARCHAR AS temporada,
        
        -- 6. prendas_requeridas (antes: prendas)
        SUM(prendas) AS prendas_requeridas,
        
        -- 7. estilo_propio (mantiene nombre)
        MIN(estilo_propio) AS estilo_propio,
        
        -- 8. fecha_facturacion (antes: fecha) - √∫ltima fecha
        MAX(TO_DATE(fecha, 'DD/MM/YYYY'))::TIMESTAMPTZ AS fecha_facturacion,
        
        -- 9. monto_factura (antes: importe)
        SUM(importe) AS monto_factura,
        
        -- 10. fecha_carga (nuevo - fecha actual de ejecuci√≥n del SP)
        CURRENT_TIMESTAMP AS fecha_carga,
        
        -- 11. lote_carga (nuevo - vac√≠o)
        ''::VARCHAR AS lote_carga,
        
        -- 12. usuario_carga (nuevo - fijo "usuario")
        'usuario'::VARCHAR AS usuario_carga,
        
        -- 13. activo (nuevo - TRUE por defecto)
        TRUE AS activo
        
        -- CAMPOS COMENTADOS (mantenidos en la query de la tabla temporal)
        -- ano, mes, clase, factura, po, estilo_cliente
        
    FROM silver.bd_finanzas_temp
    GROUP BY op
    ORDER BY op;

    -- Contar registros finales
    SELECT COUNT(*) INTO v_contador FROM silver.bd_finanzas;
    
    -- Limpiar tabla temporal
    DROP TABLE IF EXISTS silver.bd_finanzas_temp;
    
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Proceso completado exitosamente';
    RAISE NOTICE 'Total de registros en tabla temporal: %', v_total_registros;
    RAISE NOTICE 'Total de OPs √∫nicas en tabla final: %', v_contador;
    RAISE NOTICE 'Tabla final: silver.bd_finanzas';
    RAISE NOTICE '========================================';

END;
$procedure$

-------------------------------------------------------------------------------------

2. =====================================================================================
NOMBRE: create_bd_finanzas_saya
SCHEMA: silver
ARGUMENTOS: IN p_ano_inicio character varying, IN p_mes_inicio character varying, IN p_ano_fin character varying, IN p_mes_fin character varying, IN p_moneda character DEFAULT 'S'::bpchar

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.create_bd_finanzas_saya(IN p_ano_inicio character varying, IN p_mes_inicio character varying, IN p_ano_fin character varying, IN p_mes_fin character varying, IN p_moneda character DEFAULT 'S'::bpchar)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    v_ano_actual VARCHAR;
    v_mes_actual VARCHAR;
    v_contador INTEGER := 0;
    v_total_registros INTEGER := 0;
BEGIN
    -- Crear o reemplazar la tabla TEMPORAL con TODOS los campos
    DROP TABLE IF EXISTS silver.bd_finanzas_saya_temp;
    
    CREATE TABLE silver.bd_finanzas_saya_temp (
        ano VARCHAR,
        mes VARCHAR,
        clase VARCHAR,
        fecha VARCHAR,
        factura VARCHAR,
        cliente VARCHAR,
        po VARCHAR,
        estilo_cliente VARCHAR,
        op VARCHAR,
        prendas NUMERIC,
        importe NUMERIC,
        estilo_propio VARCHAR,
        tipo_prenda VARCHAR
    );

    RAISE NOTICE 'Iniciando proceso para a√±o % mes % hasta a√±o % mes %', 
                 p_ano_inicio, p_mes_inicio, p_ano_fin, p_mes_fin;

    -- Variables para iterar
    v_ano_actual := p_ano_inicio;
    v_mes_actual := p_mes_inicio;

    -- Loop para procesar cada mes
    WHILE (v_ano_actual || v_mes_actual)::INTEGER <= (p_ano_fin || p_mes_fin)::INTEGER LOOP
        
        RAISE NOTICE 'Procesando: A√±o %, Mes %', v_ano_actual, v_mes_actual;
        
        -- Limpiar tablas temporales si existen
        DROP TABLE IF EXISTS detalle_ventas;
        DROP TABLE IF EXISTS ventas;
        
        -- Crear tabla temporal #DETALLE_VENTAS
        CREATE TEMP TABLE detalle_ventas AS
        SELECT 
            B.ser_docum || '-' || B.num_docum_ventas AS num_docum_ventas,
            B.fec_emidoc,
            A.num_prendas,
            A.cod_cliente,
            A.cod_purord,
            A.cod_lotpurord,
            A.cod_estcli,
            A.num_corre,
            A.secuencia,
            B.tipo_cambio,
            B.cod_moneda
        FROM bronze.cn_ventas_prendas A 
        INNER JOIN bronze.cn_ventas B ON A.num_corre = B.num_corre 
        WHERE B.ano_registro = v_ano_actual 
          AND B.mes_registro = v_mes_actual;

        -- Crear tabla temporal #VENTAS
        CREATE TEMP TABLE ventas AS
        SELECT 
            A.fec_emidoc,
            A.num_docum_ventas,
            A.cod_cliente,
            A.cod_purord,
            A.cod_lotpurord,
            A.cod_estcli,
            C.cod_ordpro,
            SUM(A.num_prendas) AS prendas,
            
            -- ============================================================
            -- CAMPO IMPORTE COMENTADO TEMPORALMENTE
            -- Funci√≥n utilizada: bronze.cn_ventas_obtiene_precio_fob(num_corre, secuencia)
            -- Para descomentar, quitar los comentarios de las l√≠neas siguientes:
            -- ============================================================
            /*
            CASE 
                WHEN p_moneda = 'D' THEN 
                    SUM(CASE 
                        WHEN A.cod_moneda = 'SOL' 
                        THEN bronze.cn_ventas_obtiene_precio_fob(A.num_corre, A.secuencia) / NULLIF(A.tipo_cambio, 0)
                        ELSE bronze.cn_ventas_obtiene_precio_fob(A.num_corre, A.secuencia) 
                    END)
                ELSE 
                    SUM(CASE 
                        WHEN A.cod_moneda = 'SOL' 
                        THEN bronze.cn_ventas_obtiene_precio_fob(A.num_corre, A.secuencia) 
                        ELSE bronze.cn_ventas_obtiene_precio_fob(A.num_corre, A.secuencia) * A.tipo_cambio 
                    END)
            END AS importe,
            */
            -- ============================================================
            -- MIENTRAS TANTO, IMPORTE = 0
            -- ============================================================
            0::NUMERIC AS importe,
            -- ============================================================
            
            CASE 
                WHEN B.cod_clapurord IN ('PO','S2') THEN '1-PRODUCCION/SALDOS' 
                ELSE '2-MUESTRAS' 
            END AS cod_clapurord
        FROM detalle_ventas A 
        INNER JOIN bronze.tg_lotestpro C ON 
            A.cod_cliente = C.cod_cliente 
            AND A.cod_purord = C.cod_purord
            AND A.cod_lotpurord = C.cod_lotpurord
            AND A.cod_estcli = C.cod_estcli
        INNER JOIN bronze.tg_purord B ON 
            A.cod_cliente = B.cod_cliente 
            AND A.cod_purord = B.cod_purord    
        WHERE B.cod_clapurord IN ('PO', 'S2', 'S1', 'MU')
        GROUP BY 
            A.num_docum_ventas, 
            A.cod_cliente, 
            A.cod_purord, 
            A.cod_lotpurord, 
            A.cod_estcli, 
            C.cod_ordpro, 
            A.fec_emidoc, 
            B.cod_clapurord;

        -- Insertar datos en la tabla TEMPORAL (con todos los campos)
        INSERT INTO silver.bd_finanzas_saya_temp
        SELECT 
            v_ano_actual AS ano,
            v_mes_actual AS mes,
            V.cod_clapurord AS clase,
            TO_CHAR(V.fec_emidoc, 'DD/MM/YYYY') AS fecha,
            V.num_docum_ventas AS factura,
            COALESCE(C.nom_cliente, '') AS cliente,
            V.cod_purord AS po,
            V.cod_estcli AS estilo_cliente,
            V.cod_ordpro AS op,
            V.prendas,
            V.importe,  -- Por ahora = 0
            COALESCE(O.cod_estpro, '') AS estilo_propio,
            COALESCE(bronze.es_muestra_tipo_prenda_por_np('001', V.cod_ordpro), '') AS tipo_prenda
        FROM ventas V
        LEFT JOIN bronze.es_ordpro O 
            ON V.cod_ordpro = O.cod_ordpro 
            AND O.cod_fabrica = '001'
        LEFT JOIN bronze.tg_cliente C 
            ON V.cod_cliente = C.cod_cliente
        ORDER BY 
            V.cod_clapurord, 
            V.fec_emidoc, 
            V.num_docum_ventas, 
            V.cod_purord, 
            V.cod_ordpro;

        -- Contar registros insertados
        GET DIAGNOSTICS v_contador = ROW_COUNT;
        v_total_registros := v_total_registros + v_contador;
        
        RAISE NOTICE 'A√±o % Mes %: % registros insertados en tabla temporal', v_ano_actual, v_mes_actual, v_contador;

        -- Incrementar mes
        v_mes_actual := LPAD((v_mes_actual::INTEGER + 1)::TEXT, 2, '0');
        
        -- Si llegamos a mes 13, incrementar a√±o y resetear mes
        IF v_mes_actual::INTEGER > 12 THEN
            v_ano_actual := (v_ano_actual::INTEGER + 1)::TEXT;
            v_mes_actual := '01';
        END IF;

    END LOOP;

    -- Limpiar tablas temporales
    DROP TABLE IF EXISTS detalle_ventas;
    DROP TABLE IF EXISTS ventas;
    
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Datos cargados en tabla temporal';
    RAISE NOTICE 'Generando tabla final AGRUPADA POR OP...';
    RAISE NOTICE '========================================';

    -- ============================================================
    -- CREAR TABLA FINAL AGRUPADA POR OP CON NUEVOS NOMBRES Y COLUMNAS
    -- VERSION 2.3
    -- ============================================================
    DROP TABLE IF EXISTS silver.bd_finanzas_saya;
    
    CREATE TABLE silver.bd_finanzas_saya AS
    SELECT 
        -- 1. cod_ordpro (antes: op)
        op AS cod_ordpro,
        
        -- 2. cliente (mantiene nombre)
        MIN(cliente) AS cliente,
        
        -- 3. tipo_de_producto (antes: tipo_prenda)
        MIN(tipo_prenda) AS tipo_de_producto,
        
        -- 4. familia_de_productos (nuevo - vac√≠o)
        ''::VARCHAR AS familia_de_productos,
        
        -- 5. temporada (nuevo - vac√≠o)
        ''::VARCHAR AS temporada,
        
        -- 6. prendas_requeridas (antes: prendas)
        SUM(prendas) AS prendas_requeridas,
        
        -- 7. estilo_propio (mantiene nombre)
        MIN(estilo_propio) AS estilo_propio,
        
        -- 8. fecha_facturacion (antes: fecha) - √∫ltima fecha
        TO_CHAR(MAX(TO_DATE(fecha, 'DD/MM/YYYY')), 'DD/MM/YYYY') AS fecha_facturacion,
        
        -- 9. monto_factura (antes: importe)
        SUM(importe) AS monto_factura,
        
        -- 10. fecha_carga (nuevo - fecha actual de ejecuci√≥n del SP)
        CURRENT_TIMESTAMP AS fecha_carga,
        
        -- 11. lote_carga (nuevo - vac√≠o)
        ''::VARCHAR AS lote_carga,
        
        -- 12. usuario_carga (nuevo - fijo "usuario")
        'usuario'::VARCHAR AS usuario_carga,
        
        -- 13. activo (nuevo - TRUE por defecto)
        TRUE AS activo
        
        -- CAMPOS COMENTADOS (mantenidos en la query de la tabla temporal)
        -- ano, mes, clase, factura, po, estilo_cliente
        
    FROM silver.bd_finanzas_saya_temp
    GROUP BY op
    ORDER BY op;

    -- Contar registros finales
    SELECT COUNT(*) INTO v_contador FROM silver.bd_finanzas_saya;
    
    -- Limpiar tabla temporal
    DROP TABLE IF EXISTS silver.bd_finanzas_saya_temp;
    
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Proceso completado exitosamente';
    RAISE NOTICE 'Total de registros en tabla temporal: %', v_total_registros;
    RAISE NOTICE 'Total de OPs √∫nicas en tabla final: %', v_contador;
    RAISE NOTICE 'Tabla final: silver.bd_finanzas_saya';
    RAISE NOTICE '========================================';

END;
$procedure$

-------------------------------------------------------------------------------------

3. =====================================================================================
NOMBRE: create_costo_avios
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0, IN recrear_tabla integer DEFAULT 0, IN debug integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.create_costo_avios(IN modo integer DEFAULT 0, IN recrear_tabla integer DEFAULT 0, IN debug integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    table_exists BOOLEAN;
    schema_exists BOOLEAN;
BEGIN
    -- MODO CONSULTA (0)
    IF modo = 0 THEN
        RAISE NOTICE 'üîç MODO CONSULTA - Estructura tabla COSTO_AVIOS';
        RAISE NOTICE '================================================================================';
        RAISE NOTICE 'TABLA: silver.costo_avios (14 columnas)';
        RAISE NOTICE '';
        RAISE NOTICE 'IDENTIFICADORES (3): id_registro, op_codigo, estilo_codigo';
        RAISE NOTICE 'COSTOS PRINCIPALES (3): costo_total_corregido_por_prenda, cantidad_avios_por_op, costo_total_op_usd';
        RAISE NOTICE 'FECHAS (2): primera_entrada_avios, ultima_salida_avios';
        RAISE NOTICE 'MOVIMIENTOS (6): total_salidas_can, total_salidas_usd, total_devoluciones_can,';
        RAISE NOTICE '                 total_devoluciones_usd, can_movimiento_neto_total, imp_valorizado_neto_total';
        RAISE NOTICE 'AUDITOR√çA (1): fecha_corrida';
        RAISE NOTICE '================================================================================';
        
        -- Verificar si la tabla existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'silver' AND table_name = 'costo_avios'
        ) INTO table_exists;
        
        IF table_exists THEN
            RAISE NOTICE '‚úÖ Tabla ya existe en base de datos';
        ELSE
            RAISE NOTICE '‚ùå Tabla NO existe en base de datos';
        END IF;
        
        RETURN;
    END IF;
    
    -- MODO GUARDAR (1)
    IF modo = 1 THEN
        RAISE NOTICE 'üíæ MODO GUARDAR - Creando tabla COSTO_AVIOS';
        
        -- Crear esquema si no existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.schemata WHERE schema_name = 'silver'
        ) INTO schema_exists;
        
        IF NOT schema_exists THEN
            EXECUTE 'CREATE SCHEMA silver';
            RAISE NOTICE '   üìÅ Esquema silver creado';
        END IF;
        
        -- Verificar si tabla existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'silver' AND table_name = 'costo_avios'
        ) INTO table_exists;
        
        IF table_exists THEN
            IF recrear_tabla = 1 THEN
                DROP TABLE silver.costo_avios CASCADE;
                RAISE NOTICE '   ‚ôªÔ∏è Tabla anterior eliminada para recrear';
            ELSE
                RAISE NOTICE '   ‚úÖ Tabla ya existe, manteniendo estructura actual';
                RETURN;
            END IF;
        END IF;
        
        -- Crear tabla con estructura simplificada
        CREATE TABLE silver.costo_avios (
            -- IDENTIFICADORES (3)
            id_registro BIGSERIAL PRIMARY KEY,
            op_codigo VARCHAR(50) NOT NULL,
            estilo_codigo VARCHAR(50),
            
            -- COSTOS PRINCIPALES (3)
            costo_total_corregido_por_prenda DECIMAL(18,4) DEFAULT 0,
            cantidad_avios_por_op INT DEFAULT 0,
            costo_total_op_usd DECIMAL(18,4) DEFAULT 0,
            
            -- FECHAS MOVIMIENTOS (2)
            primera_entrada_avios TIMESTAMPTZ,
            ultima_salida_avios TIMESTAMPTZ,
            
            -- DETALLE MOVIMIENTOS (6)
            total_salidas_can DECIMAL(18,2) DEFAULT 0,
            total_salidas_usd DECIMAL(18,4) DEFAULT 0,
            total_devoluciones_can DECIMAL(18,2) DEFAULT 0,
            total_devoluciones_usd DECIMAL(18,4) DEFAULT 0,
            can_movimiento_neto_total DECIMAL(18,2) DEFAULT 0,
            imp_valorizado_neto_total DECIMAL(18,4) DEFAULT 0,
            
            -- AUDITOR√çA SIMPLIFICADA (1)
            fecha_corrida TIMESTAMPTZ DEFAULT NOW()
        );
        
        -- Crear √≠ndices para performance
        CREATE INDEX IF NOT EXISTS ix_costo_avios_op ON silver.costo_avios (op_codigo);
        CREATE INDEX IF NOT EXISTS ix_costo_avios_estilo ON silver.costo_avios (estilo_codigo);
        CREATE INDEX IF NOT EXISTS ix_costo_avios_fecha ON silver.costo_avios (fecha_corrida);
        CREATE INDEX IF NOT EXISTS ix_costo_avios_costo ON silver.costo_avios (costo_total_corregido_por_prenda);
        
        RAISE NOTICE '   ‚úÖ Tabla silver.costo_avios creada exitosamente';
        RAISE NOTICE '   üìä Estructura: 14 columnas (3 ID + 3 costos + 2 fechas + 6 movimientos + 1 auditor√≠a)';
        RAISE NOTICE '   üìä √çndices: 4 √≠ndices creados';
        RAISE NOTICE '';
        RAISE NOTICE '   üÜï CAMBIOS APLICADOS:';
        RAISE NOTICE '     ‚Ä¢ -estado_registro, -observaciones (simplificaci√≥n)';
        RAISE NOTICE '     ‚Ä¢ fecha_calculo ‚Üí fecha_corrida (estandarizaci√≥n)';
        RAISE NOTICE '     ‚Ä¢ Solo variable de control: fecha_corrida';
    END IF;
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE '‚ùå ERROR en silver.create_costo_avios: %', error_message;
        RAISE EXCEPTION '%', error_message;
END;
$procedure$

-------------------------------------------------------------------------------------

4. =====================================================================================
NOMBRE: create_costo_materia_prima
SCHEMA: silver
ARGUMENTOS: 

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.create_costo_materia_prima()
 LANGUAGE sql
AS $procedure$
-- DROP TABLE IF EXISTS silver.costo_materia_prima;
-- Crear nueva tabla con estructura simplificada
CREATE TABLE IF NOT EXISTS silver.costo_materia_prima (
    -- IDENTIFICADORES (3)
    id_registro BIGINT GENERATED BY DEFAULT AS identity PRIMARY KEY,
    op_codigo VARCHAR(50) NOT NULL,
    estilo_codigo VARCHAR(50),
    --
    -- FECHAS REFERENCIALES (4)
    fecha_despacho VARCHAR(20),
    fecha_despacho_original timestamptz,
    "a√±o_compra_tela" int,
    fecha_compra_tela_min timestamptz,
    --
    -- COSTOS HILADOS (8)
    kg_hilados_total DECIMAL(18,2) DEFAULT 0,
    inductor_hilados_original DECIMAL(18,4) DEFAULT 0,
    costo_hilados_final DECIMAL(18,4) DEFAULT 0,
    usd_por_kg_promedio DECIMAL(18,4) DEFAULT 0,
    crudo_kg DECIMAL(18,2) DEFAULT 0,
    crudo_costo_usd DECIMAL(18,4) DEFAULT 0,
    tenido_kg DECIMAL(18,2) DEFAULT 0,
    tenido_costo_usd DECIMAL(18,4) DEFAULT 0,
    hilados_diferentes INT DEFAULT 0,
    --
    -- COSTOS TELA (5)
    kg_tela_comprada_total DECIMAL(18,2) DEFAULT 0,
    rollos_tela_comprada_total DECIMAL(18,2) DEFAULT 0,
    costo_tela_comprada_total DECIMAL(18,4) DEFAULT 0,
    costo_tela_final DECIMAL(18,4) DEFAULT 0,
    usd_por_unidad_tela_real DECIMAL(18,4) DEFAULT 0,
    --
    -- TOTALES FINALES (4)
    costo_total_mp_final DECIMAL(18,4) DEFAULT 0,
    factor_hilados DECIMAL(18,6) DEFAULT 0,
    factor_tela DECIMAL(18,6) DEFAULT 0,
    --
    -- FLAGS DE DISPONIBILIDAD (3)
    tiene_hilados boolean DEFAULT false,
    tiene_tela boolean DEFAULT false,
    tiene_mp boolean DEFAULT false,
    --
    -- ‚úÖ AUDITOR√çA SIMPLIFICADA (1) - Solo fecha_corrida
    fecha_corrida timestamptz DEFAULT NOW()
);
--
-- Crear √≠ndices para performance
CREATE INDEX ON silver.costo_materia_prima(op_codigo);
CREATE INDEX ON silver.COSTO_MATERIA_PRIMA(op_codigo);
CREATE INDEX ON silver.COSTO_MATERIA_PRIMA(estilo_codigo);
CREATE INDEX ON silver.COSTO_MATERIA_PRIMA(fecha_despacho);
CREATE INDEX ON silver.COSTO_MATERIA_PRIMA("a√±o_compra_tela");
CREATE INDEX ON silver.COSTO_MATERIA_PRIMA(fecha_corrida);
CREATE INDEX ON silver.COSTO_MATERIA_PRIMA(costo_total_mp_final);
$procedure$

-------------------------------------------------------------------------------------

5. =====================================================================================
NOMBRE: create_costo_op_detalle
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0, IN recrear_tabla integer DEFAULT 0, IN debug integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.create_costo_op_detalle(IN modo integer DEFAULT 0, IN recrear_tabla integer DEFAULT 0, IN debug integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    table_exists BOOLEAN;
    schema_exists BOOLEAN;
BEGIN
    -- MODO CONSULTA (0)
    IF modo = 0 THEN
        RAISE NOTICE 'üîç MODO CONSULTA - Estructura tabla COSTO_OP_DETALLE FINAL';
        RAISE NOTICE '================================================================================';
        RAISE NOTICE 'TABLA: silver.costo_op_detalle (25 columnas)';
        RAISE NOTICE '';
        RAISE NOTICE 'IDENTIFICADORES (3): id_registro, cod_ordpro, estilo_propio';
        RAISE NOTICE 'DATOS B√ÅSICOS (4): cliente, tipo_de_producto, familia_de_productos, temporada';
        RAISE NOTICE 'FACTURACI√ìN (3): prendas_requeridas, monto_factura, fecha_facturacion';
        RAISE NOTICE 'COSTOS WIP (2): costo_manufactura, costo_textil';
        RAISE NOTICE 'COSTOS INDIRECTOS (3): costo_indirecto_fijo, gasto_administracion, gasto_ventas';
        RAISE NOTICE 'COSTOS MATERIALES (2): costo_avios, costo_materia_prima';
        RAISE NOTICE 'VARIABLES AVANZADAS (8): pre_unitario, lote_estilo_kg, diversidad_familias, diversidad_estilos';
        RAISE NOTICE '                         esfuerzo_textil, esfuerzo_manufactura, esfuerzo_total, indice_complejidad';
        RAISE NOTICE 'AUDITOR√çA (1): fecha_corrida';
        RAISE NOTICE '================================================================================';
        
        -- Verificar si la tabla existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle'
        ) INTO table_exists;
        
        IF table_exists THEN
            RAISE NOTICE '‚úÖ Tabla ya existe en base de datos';
        ELSE
            RAISE NOTICE '‚ùå Tabla NO existe en base de datos';
        END IF;
        
        RETURN;
    END IF;
    
    -- MODO GUARDAR (1)
    IF modo = 1 THEN
        RAISE NOTICE 'üíæ MODO GUARDAR - Creando tabla COSTO_OP_DETALLE FINAL';
        
        -- Crear esquema si no existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.schemata WHERE schema_name = 'silver'
        ) INTO schema_exists;
        
        IF NOT schema_exists THEN
            EXECUTE 'CREATE SCHEMA silver';
            RAISE NOTICE '   üìÅ Esquema silver creado';
        END IF;
        
        -- Verificar si tabla existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle'
        ) INTO table_exists;
        
        IF table_exists THEN
            IF recrear_tabla = 1 THEN
                DROP TABLE silver.costo_op_detalle CASCADE;
                RAISE NOTICE '   ‚ôªÔ∏è Tabla anterior eliminada para recrear';
            ELSE
                RAISE NOTICE '   ‚úÖ Tabla ya existe, manteniendo estructura actual';
                RETURN;
            END IF;
        END IF;
        
        -- ‚úÖ CREAR TABLA FINAL CON COSTOS INDIRECTOS (25 columnas)
        CREATE TABLE silver.costo_op_detalle (
            -- IDENTIFICADORES (3)
            id_registro BIGSERIAL,
            cod_ordpro VARCHAR(50) NOT NULL,
            estilo_propio VARCHAR(50),
            
            -- DATOS B√ÅSICOS (4)
            cliente VARCHAR(100),
            tipo_de_producto VARCHAR(100),
            familia_de_productos VARCHAR(100),
            temporada VARCHAR(100),
            
            -- CANTIDADES Y FACTURACI√ìN (3)
            prendas_requeridas DECIMAL(18,2) DEFAULT 0,
            monto_factura DECIMAL(18,4) DEFAULT 0,
            fecha_facturacion TIMESTAMPTZ,
            
            -- ‚úÖ COSTOS WIP CORREGIDOS (2)
            costo_manufactura DECIMAL(18,4) DEFAULT 0,
            costo_textil DECIMAL(18,4) DEFAULT 0,  -- ‚úÖ √öNICO COSTO TEXTIL
            
            -- ‚úÖ COSTOS INDIRECTOS AGREGADOS (3)
            costo_indirecto_fijo DECIMAL(18,4) DEFAULT 0,
            gasto_administracion DECIMAL(18,4) DEFAULT 0,
            gasto_ventas DECIMAL(18,4) DEFAULT 0,
            
            -- ‚úÖ COSTOS MATERIALES RENOMBRADOS (2)
            costo_avios DECIMAL(18,4) DEFAULT 0,
            costo_materia_prima DECIMAL(18,4) DEFAULT 0,  -- ‚úÖ RENOMBRADO de costo_mp_total
            
            -- ‚úÖ VARIABLES AVANZADAS CORREGIDAS (8)
            pre_unitario DECIMAL(18,4) DEFAULT 0,
            lote_estilo_kg DECIMAL(18,4) DEFAULT 0,
            diversidad_familias INT DEFAULT 0,
            diversidad_estilos INT DEFAULT 0,
            esfuerzo_textil INT DEFAULT 1,         -- ‚úÖ RENOMBRADO de factor_textil_metodo2
            esfuerzo_manufactura INT DEFAULT 1,    -- ‚úÖ RENOMBRADO de factor_manufactura_metodo2
            esfuerzo_total INT DEFAULT 2,
            indice_complejidad DECIMAL(18,6) DEFAULT NULL,
            -- ‚úÖ ELIMINADO: esfuerzo_categoria
            
            -- ‚úÖ AUDITOR√çA ESTANDARIZADA (1)
            fecha_corrida TIMESTAMPTZ DEFAULT NOW()
        );
        
        -- Crear √≠ndices esenciales
        CREATE INDEX IF NOT EXISTS ix_costo_op_detalle_cod_ordpro ON silver.costo_op_detalle (cod_ordpro);
        CREATE INDEX IF NOT EXISTS ix_costo_op_detalle_estilo ON silver.costo_op_detalle (estilo_propio);
        CREATE INDEX IF NOT EXISTS ix_costo_op_detalle_cliente ON silver.costo_op_detalle (cliente);
        CREATE INDEX IF NOT EXISTS ix_costo_op_detalle_temporada ON silver.costo_op_detalle (temporada);
        CREATE INDEX IF NOT EXISTS ix_costo_op_detalle_fecha_corrida ON silver.costo_op_detalle (fecha_corrida);
        CREATE INDEX IF NOT EXISTS ix_costo_op_detalle_esfuerzo_total ON silver.costo_op_detalle (esfuerzo_total);
        
        RAISE NOTICE '   ‚úÖ Tabla silver.costo_op_detalle creada exitosamente';
        RAISE NOTICE '   üìä Estructura: 25 columnas (3 ID + 4 b√°sicos + 3 facturaci√≥n + 2 WIP + 3 indirectos + 2 materiales + 8 avanzadas + 1 auditor√≠a)';
        RAISE NOTICE '   üìä √çndices: 6 √≠ndices esenciales';
        RAISE NOTICE '';
        RAISE NOTICE '   üÜï CAMBIOS APLICADOS:';
        RAISE NOTICE '     ‚Ä¢ +costo_indirecto_fijo, +gasto_administracion, +gasto_ventas';
        RAISE NOTICE '     ‚Ä¢ -costo_textil_prr_dr, -costo_textil_prr_kg ‚Üí +costo_textil √∫nico';
        RAISE NOTICE '     ‚Ä¢ costo_mp_total ‚Üí costo_materia_prima';
        RAISE NOTICE '     ‚Ä¢ factor_textil_metodo2 ‚Üí esfuerzo_textil';
        RAISE NOTICE '     ‚Ä¢ factor_manufactura_metodo2 ‚Üí esfuerzo_manufactura';
        RAISE NOTICE '     ‚Ä¢ -esfuerzo_categoria (eliminado)';
        RAISE NOTICE '     ‚Ä¢ fecha_corrida estandarizada';
        RAISE NOTICE '     ‚Ä¢ 22 ‚Üí 25 columnas (agregados costos indirectos)';
    END IF;
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE '‚ùå ERROR en silver.CREATE_COSTO_OP_DETALLE: %', error_message;
        RAISE EXCEPTION '%', error_message;
END;
$procedure$

-------------------------------------------------------------------------------------

6. =====================================================================================
NOMBRE: create_costo_wip_op
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0, IN recrear_tabla integer DEFAULT 0, IN debug integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.create_costo_wip_op(IN modo integer DEFAULT 0, IN recrear_tabla integer DEFAULT 0, IN debug integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    table_exists BOOLEAN;
    schema_exists BOOLEAN;
    start_time TIMESTAMPTZ := NOW();
BEGIN
    -- MODO CONSULTA (0)
    IF modo = 0 THEN
        RAISE NOTICE 'MODO CONSULTA - Estructura tabla COSTO_WIP_OP';
        RAISE NOTICE '================================================================================';
        RAISE NOTICE 'TABLA: silver.costo_wip_op (25 columnas)';
        RAISE NOTICE '';
        RAISE NOTICE 'BASE WIP (12): factory_id, pr_id, wip_id, ini_t, end_t, month_';
        RAISE NOTICE '               prod_kg, prod_q, days_in_range, total_days';
        RAISE NOTICE '               prod_kg__allocated, prod_q__allocated';
        RAISE NOTICE '';
        RAISE NOTICE 'NEGOCIO (5): estilo_propio, cliente, tipo_de_producto, familia_de_productos, temporada';
        RAISE NOTICE '';
        RAISE NOTICE 'COSTOS INDIRECTOS (3): costo_indirecto_fijo, gasto_administracion, gasto_ventas';
        RAISE NOTICE '';
        RAISE NOTICE 'COSTOS PROCESOS (2): costo_textil, costo_manufactura';
        RAISE NOTICE '';
        RAISE NOTICE 'VERSION (1): version_calculo';
        RAISE NOTICE '';
        RAISE NOTICE 'AUDITORIA (1): fecha_corrida';
        RAISE NOTICE '================================================================================';
        
        -- Verificar si tabla existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'silver' AND table_name = 'costo_wip_op'
        ) INTO table_exists;
        
        IF table_exists THEN
            RAISE NOTICE 'Tabla ya existe en base de datos';
        ELSE
            RAISE NOTICE 'Tabla NO existe en base de datos';
        END IF;
        
        RETURN;
    END IF;
    
    -- MODO GUARDAR (1)
    IF modo = 1 THEN
        RAISE NOTICE 'MODO GUARDAR - Creando tabla COSTO_WIP_OP';
        RAISE NOTICE '   Recrear tabla: %', CASE WHEN recrear_tabla = 1 THEN 'SI' ELSE 'NO' END;
        
        -- Crear esquema si no existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.schemata WHERE schema_name = 'silver'
        ) INTO schema_exists;
        
        IF NOT schema_exists THEN
            EXECUTE 'CREATE SCHEMA silver';
            RAISE NOTICE '   Esquema silver creado';
        END IF;
        
        -- Verificar si tabla existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'silver' AND table_name = 'costo_wip_op'
        ) INTO table_exists;
        
        IF table_exists THEN
            IF recrear_tabla = 1 THEN
                DROP TABLE silver.costo_wip_op CASCADE;
                RAISE NOTICE '   Tabla anterior eliminada para recrear';
            ELSE
                RAISE NOTICE '   Tabla ya existe, manteniendo estructura actual';
                RETURN;
            END IF;
        END IF;
        
        -- Crear nueva tabla con estructura corregida
        CREATE TABLE silver.costo_wip_op (
            -- COLUMNAS BASE WIP (12)
            factory_id TEXT,
            pr_id TEXT,
            wip_id TEXT,
            ini_t TIMESTAMPTZ,
            end_t TIMESTAMPTZ,
            month_ TIMESTAMPTZ,
            prod_kg DECIMAL(18,4),
            prod_q DECIMAL(18,4),
            days_in_range INT,
            total_days INT,
            prod_kg__allocated DECIMAL(18,4),
            prod_q__allocated DECIMAL(18,4),
            
            -- NUEVAS COLUMNAS DE NEGOCIO (5) - AGREGAMOS estilo_propio
            estilo_propio VARCHAR(50),
            cliente VARCHAR(100),
            tipo_de_producto VARCHAR(100),
            familia_de_productos VARCHAR(100),
            temporada VARCHAR(100),
            
            -- COLUMNAS COSTOS INDIRECTOS (3)
            costo_indirecto_fijo DECIMAL(18,4) DEFAULT 0,
            gasto_administracion DECIMAL(18,4) DEFAULT 0,
            gasto_ventas DECIMAL(18,4) DEFAULT 0,
            
            -- COLUMNAS COSTOS PROCESOS CORREGIDAS (2) - Solo costo_textil
            costo_textil DECIMAL(18,4) DEFAULT 0,
            costo_manufactura DECIMAL(18,4) DEFAULT 0,
            
           
            -- COLUMNA AUDITORIA ESTANDARIZADA (1)
            fecha_corrida TIMESTAMPTZ DEFAULT NOW(),

 			-- COLUMNA VERSION CALCULO
            version_calculo TEXT(50)
        );
        
        -- Crear indices optimizados
        CREATE INDEX IF NOT EXISTS ix_costo_wip_op_pr_id ON silver.costo_wip_op (pr_id);
        CREATE INDEX IF NOT EXISTS ix_costo_wip_op_wip_id ON silver.costo_wip_op (wip_id);
        CREATE INDEX IF NOT EXISTS ix_costo_wip_op_month ON silver.costo_wip_op (month_);
        CREATE INDEX IF NOT EXISTS ix_costo_wip_op_fecha_corrida ON silver.costo_wip_op (fecha_corrida);
        CREATE INDEX IF NOT EXISTS ix_costo_wip_op_cliente ON silver.costo_wip_op (cliente);
        CREATE INDEX IF NOT EXISTS ix_costo_wip_op_estilo ON silver.costo_wip_op (estilo_propio);
        
        RAISE NOTICE '   Tabla silver.costo_wip_op creada exitosamente';
        RAISE NOTICE '   Estructura: 25 columnas (12 base + 5 negocio + 3 indirectos + 2 procesos + 1 version + 1 auditoria)';
        RAISE NOTICE '   Indices: 6 indices creados';
        RAISE NOTICE '';
        RAISE NOTICE '   CAMBIOS APLICADOS:';
        RAISE NOTICE '     ‚Ä¢ +estilo_propio en columnas de negocio';
        RAISE NOTICE '     ‚Ä¢ -costo_textil_prr_dr y -costo_textil_prr_kg';
        RAISE NOTICE '     ‚Ä¢ +costo_textil unico';
        RAISE NOTICE '     ‚Ä¢ +version_calculo agregada';
        RAISE NOTICE '     ‚Ä¢ fecha_corrida estandarizada';
    END IF;
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE 'ERROR en silver.CREATE_COSTO_WIP_OP: %', error_message;
        RAISE EXCEPTION '%', error_message;
END;
$procedure$

-------------------------------------------------------------------------------------

7. =====================================================================================
NOMBRE: create_historial_estilos
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0, IN recrear_tabla integer DEFAULT 0, IN debug integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.create_historial_estilos(IN modo integer DEFAULT 0, IN recrear_tabla integer DEFAULT 0, IN debug integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    fecha_ejecucion TIMESTAMPTZ := NOW();  -- Cambi√© nombre para evitar conflictos
    rows_inserted INTEGER := 0;
    table_exists BOOLEAN;
    schema_exists BOOLEAN;
    estilos_calculados INTEGER;
    total_estilos INTEGER;
    muy_recurrentes INTEGER;
    recurrentes INTEGER;
    promedio_meses DECIMAL(6,1);
    promedio_total_prendas DECIMAL(10,0);
    cliente_principal_top TEXT;
    total_registros_tabla INTEGER;
    estilo_mas_antiguo TIMESTAMPTZ;
    estilo_mas_reciente TIMESTAMPTZ;
    total_prendas_sistema BIGINT;
    estilo_mas_productivo VARCHAR(50);
    rec RECORD;
BEGIN
    -- Verificar prerequisitos
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'bronze' AND table_name = 'tg_lotestpro'
    ) INTO table_exists;
    
    IF NOT table_exists THEN
        RAISE EXCEPTION '‚ùå Prerequisito faltante: tabla bronze.tg_lotestpro';
    END IF;
    
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'bronze' AND table_name = 'cn_ventas_prendas'
    ) INTO table_exists;
    
    IF NOT table_exists THEN
        RAISE EXCEPTION '‚ùå Prerequisito faltante: tabla bronze.cn_ventas_prendas';
    END IF;
    
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'bronze' AND table_name = 'cn_ventas'
    ) INTO table_exists;
    
    IF NOT table_exists THEN
        RAISE EXCEPTION '‚ùå Prerequisito faltante: tabla bronze.cn_ventas';
    END IF;
    
    RAISE NOTICE 'üöÄ INICIANDO CREACI√ìN HISTORIAL DE ESTILOS...';
    RAISE NOTICE '   Fecha corrida: %', fecha_ejecucion;
    RAISE NOTICE '   üìÖ Per√≠odo an√°lisis: Desde 2020-01-01';
    RAISE NOTICE '';
    RAISE NOTICE 'üéØ OBJETIVO: Tabla resumen para cotizador con:';
    RAISE NOTICE '   ‚Ä¢ C√≥digo de estilo √∫nico';
    RAISE NOTICE '   ‚Ä¢ Primera fecha de factura (cu√°ndo entr√≥)';
    RAISE NOTICE '   ‚Ä¢ Total prendas producidas desde 2020';
    RAISE NOTICE '   ‚Ä¢ Categor√≠a de recurrencia (Nuevo/Recurrente/Muy Recurrente)';
    RAISE NOTICE '   ‚Ä¢ Cliente principal del estilo';
    
    -- =====================================================================
    -- CALCULAR HISTORIAL COMPLETO DE ESTILOS
    -- =====================================================================
    RAISE NOTICE '';
    RAISE NOTICE 'üìä Calculando historial completo de estilos desde 2020...';
    
    -- Crear tabla temporal
    CREATE TEMP TABLE historial_estilos_temp (
        codigo_estilo TEXT,
        primera_fecha_factura TIMESTAMPTZ,
        total_prendas_desde_2020 BIGINT,
        total_facturas INTEGER,
        meses_desde_entrada INTEGER,
        a√±os_activo DECIMAL(6,2),
        cliente_principal TEXT,
        categoria_recurrencia TEXT
    );
    
    -- Paso 1: Datos base por estilo (CORREGIDO con esquemas)
    WITH datos_base_estilo AS (
        SELECT 
            lep.cod_estpro as codigo_estilo,
            MIN(cv.fec_emidoc) as primera_fecha_factura,
            SUM(vp.num_prendas) as total_prendas_desde_2020,
            COUNT(*) as total_facturas,
            -- Cliente que m√°s ha facturado este estilo
            (SELECT tc.nom_cliente 
             FROM bronze.tg_lotestpro lep2
             INNER JOIN bronze.cn_ventas_prendas vp2 
                 ON lep2.cod_purord = vp2.cod_purord AND lep2.cod_lotpurord = vp2.cod_lotpurord
             INNER JOIN bronze.tg_cliente tc ON lep2.cod_cliente = tc.cod_cliente
             WHERE lep2.cod_estpro = lep.cod_estpro
             GROUP BY tc.nom_cliente
             ORDER BY SUM(vp2.num_prendas) DESC
             LIMIT 1) as cliente_principal
        FROM bronze.tg_lotestpro lep
        INNER JOIN bronze.cn_ventas_prendas vp 
            ON lep.cod_purord = vp.cod_purord 
            AND lep.cod_lotpurord = vp.cod_lotpurord
        INNER JOIN bronze.cn_ventas cv 
            ON vp.num_corre = cv.num_corre
        WHERE lep.cod_estpro IS NOT NULL
          AND vp.num_prendas IS NOT NULL
          AND vp.num_prendas > 0
          AND cv.fec_emidoc IS NOT NULL
          AND cv.fec_emidoc >= '2020-01-01'::date
        GROUP BY lep.cod_estpro
    )
    INSERT INTO historial_estilos_temp
    SELECT 
        dbe.codigo_estilo,
        dbe.primera_fecha_factura,
        dbe.total_prendas_desde_2020,
        dbe.total_facturas,
        -- Meses desde entrada hasta hoy (usando variable renombrada)
        EXTRACT(YEAR FROM AGE(fecha_ejecucion, dbe.primera_fecha_factura)) * 12 + 
        EXTRACT(MONTH FROM AGE(fecha_ejecucion, dbe.primera_fecha_factura)) as meses_desde_entrada,
        -- A√±os activo (con decimales)
        ROUND(EXTRACT(EPOCH FROM AGE(fecha_ejecucion, dbe.primera_fecha_factura)) / (365.25 * 24 * 60 * 60), 2) as a√±os_activo,
        COALESCE(dbe.cliente_principal, 'SIN CLIENTE') as cliente_principal,
        -- Categor√≠a seg√∫n an√°lisis del usuario (>4000 = Muy Recurrente)
        CASE 
            WHEN dbe.total_prendas_desde_2020 > 4000 THEN 'Muy Recurrente'
            WHEN dbe.total_prendas_desde_2020 > 0 THEN 'Recurrente'
            ELSE 'Nuevo'
        END as categoria_recurrencia
    FROM datos_base_estilo dbe;
    
    GET DIAGNOSTICS estilos_calculados = ROW_COUNT;
    RAISE NOTICE '   ‚úÖ Estilos √∫nicos procesados: %', estilos_calculados;
    
    -- =====================================================================
    -- MODO CONSULTA (0)
    -- =====================================================================
    IF modo = 0 THEN
        RAISE NOTICE '';
        RAISE NOTICE 'üîç MODO CONSULTA - Historial de estilos calculado SIN GUARDAR';
        RAISE NOTICE '================================================================================';
        
        -- Mostrar resultado completo (limitado para evitar spam)
        RAISE NOTICE 'Top 10 estilos por volumen de producci√≥n:';
        FOR rec IN 
            SELECT 
                he.codigo_estilo,
                he.primera_fecha_factura,
                he.total_prendas_desde_2020,
                he.total_facturas,
                he.meses_desde_entrada,
                he.a√±os_activo,
                he.cliente_principal,
                he.categoria_recurrencia
            FROM historial_estilos_temp he
            ORDER BY he.total_prendas_desde_2020 DESC, he.primera_fecha_factura ASC
            LIMIT 10
        LOOP
            RAISE NOTICE '  % | % prendas | % | %', 
                rec.codigo_estilo, rec.total_prendas_desde_2020, 
                rec.categoria_recurrencia, rec.cliente_principal;
        END LOOP;
        
        -- Estad√≠sticas de consulta
        SELECT 
            COUNT(*),
            COUNT(CASE WHEN categoria_recurrencia = 'Muy Recurrente' THEN 1 END),
            COUNT(CASE WHEN categoria_recurrencia = 'Recurrente' THEN 1 END),
            AVG(meses_desde_entrada::DECIMAL),
            AVG(total_prendas_desde_2020::DECIMAL)
        INTO total_estilos, muy_recurrentes, recurrentes, promedio_meses, promedio_total_prendas
        FROM historial_estilos_temp;
        
        SELECT cliente_principal INTO cliente_principal_top
        FROM historial_estilos_temp
        GROUP BY cliente_principal
        ORDER BY COUNT(*) DESC
        LIMIT 1;
        
        RAISE NOTICE '';
        RAISE NOTICE 'üìä ESTAD√çSTICAS DE CONSULTA:';
        RAISE NOTICE '   üìÖ Fecha corrida que se asignar√≠a: %', fecha_ejecucion;
        RAISE NOTICE '   ‚úÖ Total estilos √∫nicos desde 2020: %', total_estilos;
        RAISE NOTICE '   üèÜ Muy recurrentes (>4000 prendas): %', muy_recurrentes;
        RAISE NOTICE '   üìà Recurrentes (‚â§4000 prendas): %', recurrentes;
        RAISE NOTICE '   üìÖ Promedio meses desde entrada: %', promedio_meses;
        RAISE NOTICE '   üëï Promedio prendas por estilo: %', promedio_total_prendas;
        RAISE NOTICE '   üè¢ Cliente con m√°s estilos: %', cliente_principal_top;
        
        IF debug = 1 THEN
            RAISE NOTICE '';
            RAISE NOTICE 'üîß DEBUG - Distribuci√≥n por cliente principal:';
            FOR rec IN 
                SELECT 
                    he.cliente_principal,
                    COUNT(*) as cantidad_estilos,
                    SUM(he.total_prendas_desde_2020) as prendas_totales,
                    AVG(he.total_prendas_desde_2020::DECIMAL) as promedio_prendas
                FROM historial_estilos_temp he
                GROUP BY he.cliente_principal
                ORDER BY COUNT(*) DESC
                LIMIT 5
            LOOP
                RAISE NOTICE '  % | % estilos | % prendas | % prom', 
                    rec.cliente_principal, rec.cantidad_estilos, 
                    rec.prendas_totales, ROUND(rec.promedio_prendas, 0);
            END LOOP;
        END IF;
    END IF;
    
    -- =====================================================================
    -- MODO GUARDAR (1)
    -- =====================================================================
    IF modo = 1 THEN
        RAISE NOTICE '';
        RAISE NOTICE 'üíæ MODO GUARDAR - Creando tabla y guardando historial de estilos';
        
        -- Crear esquema si no existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.schemata WHERE schema_name = 'silver'
        ) INTO schema_exists;
        
        IF NOT schema_exists THEN
            EXECUTE 'CREATE SCHEMA silver';
            RAISE NOTICE '   üìÅ Esquema silver creado';
        END IF;
        
        -- Verificar/crear tabla
        SELECT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'silver' AND table_name = 'historial_estilos'
        ) INTO table_exists;
        
        IF table_exists THEN
            IF recrear_tabla = 1 THEN
                DROP TABLE silver.historial_estilos CASCADE;
                RAISE NOTICE '   ‚ôªÔ∏è Tabla anterior eliminada para recrear';
            ELSE
                RAISE NOTICE '   ‚úÖ Tabla ya existe, agregando datos hist√≥ricos';
            END IF;
        END IF;
        
        -- Crear tabla si no existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'silver' AND table_name = 'historial_estilos'
        ) INTO table_exists;
        
        IF NOT table_exists THEN
            CREATE TABLE silver.historial_estilos (
                id_historial BIGSERIAL ,
                codigo_estilo TEXT NOT NULL,
                primera_fecha_factura TIMESTAMPTZ NOT NULL,
                total_prendas_desde_2020 BIGINT NOT NULL DEFAULT 0,
                total_facturas INTEGER NOT NULL DEFAULT 0,
                meses_desde_entrada INTEGER NOT NULL DEFAULT 0,
                a√±os_activo DECIMAL(6,2) NOT NULL DEFAULT 0,
                cliente_principal VARCHAR(100) NOT NULL,
                categoria_recurrencia TEXT NOT NULL,
                fecha_corrida TIMESTAMPTZ NOT NULL DEFAULT NOW(),  
                -- NUEVA CLAVE PRIMARIA COMPUESTA
                PRIMARY KEY (codigo_estilo, cliente_principal, categoria_recurrencia, fecha_corrida)
            );
            
            -- Crear √≠ndices para b√∫squedas r√°pidas del cotizador
            CREATE INDEX IF NOT EXISTS ix_historial_estilos_codigo_estilo ON silver.historial_estilos (codigo_estilo);
            CREATE INDEX IF NOT EXISTS ix_historial_estilos_categoria ON silver.historial_estilos (categoria_recurrencia);
            CREATE INDEX IF NOT EXISTS ix_historial_estilos_cliente ON silver.historial_estilos (cliente_principal);
            CREATE INDEX IF NOT EXISTS ix_historial_estilos_fecha_corrida ON silver.historial_estilos (fecha_corrida);
            CREATE INDEX IF NOT EXISTS ix_historial_estilos_prendas ON silver.historial_estilos (total_prendas_desde_2020);
            
            RAISE NOTICE '   ‚úÖ Tabla historial_estilos creada con √≠ndices optimizados para cotizador';
        END IF;
        
        -- Insertar datos hist√≥ricos
        INSERT INTO silver.historial_estilos (
            codigo_estilo, primera_fecha_factura, total_prendas_desde_2020, total_facturas,
            meses_desde_entrada, a√±os_activo, cliente_principal, categoria_recurrencia, fecha_corrida
        )
        SELECT 
            he.codigo_estilo,
            he.primera_fecha_factura,
            he.total_prendas_desde_2020,
            he.total_facturas,
            he.meses_desde_entrada,
            he.a√±os_activo,
            he.cliente_principal,
            he.categoria_recurrencia,
            fecha_ejecucion
        FROM historial_estilos_temp he;
        
        GET DIAGNOSTICS rows_inserted = ROW_COUNT;
        
        -- Estad√≠sticas finales
        SELECT COUNT(*) INTO total_registros_tabla FROM silver.historial_estilos;
        
        SELECT 
            MIN(primera_fecha_factura),
            MAX(primera_fecha_factura),
            SUM(total_prendas_desde_2020)
        INTO estilo_mas_antiguo, estilo_mas_reciente, total_prendas_sistema
        FROM silver.historial_estilos
        WHERE fecha_corrida = fecha_ejecucion;
        
        SELECT codigo_estilo INTO estilo_mas_productivo
        FROM silver.historial_estilos
        WHERE fecha_corrida = fecha_ejecucion
        ORDER BY total_prendas_desde_2020 DESC
        LIMIT 1;
        
        RAISE NOTICE '   ‚úÖ Registros insertados: %', rows_inserted;
        RAISE NOTICE '';
        RAISE NOTICE 'üìä ESTAD√çSTICAS FINALES:';
        RAISE NOTICE '   üìä Total registros en tabla: %', total_registros_tabla;
        RAISE NOTICE '   üëï Total prendas sistema (desde 2020): %', total_prendas_sistema;
        RAISE NOTICE '   üìÖ Estilo m√°s antiguo: %', estilo_mas_antiguo;
        RAISE NOTICE '   üìÖ Estilo m√°s reciente: %', estilo_mas_reciente;
        RAISE NOTICE '   üèÜ Estilo m√°s productivo: %', estilo_mas_productivo;
        RAISE NOTICE '   üìÖ Fecha corrida: %', fecha_ejecucion;
        RAISE NOTICE '';
        RAISE NOTICE '‚úÖ HISTORIAL_ESTILOS CREADO Y POBLADO EXITOSAMENTE';
        RAISE NOTICE 'üéØ TABLA LISTA PARA USO EN COTIZADOR';
        RAISE NOTICE '';
        RAISE NOTICE 'üí° CASOS DE USO PARA COTIZADOR:';
        RAISE NOTICE '   ‚Ä¢ Buscar estilo: WHERE codigo_estilo = ''EST123''';
        RAISE NOTICE '   ‚Ä¢ Filtrar por recurrencia: WHERE categoria_recurrencia = ''Muy Recurrente''';
        RAISE NOTICE '   ‚Ä¢ Estilos nuevos: WHERE meses_desde_entrada <= 6';
        RAISE NOTICE '   ‚Ä¢ Por cliente: WHERE cliente_principal = ''NIKE''';
    END IF;
    
    -- Limpiar tabla temporal
    DROP TABLE IF EXISTS historial_estilos_temp;
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE '‚ùå ERROR en silver.CREATE_HISTORIAL_ESTILOS: %', error_message;
        
        -- Limpiar tabla temporal en caso de error
        DROP TABLE IF EXISTS historial_estilos_temp;
        
        RAISE EXCEPTION '%', error_message;
END;
$procedure$

-------------------------------------------------------------------------------------

8. =====================================================================================
NOMBRE: create_resumen_wip_por_prenda
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0, IN recrear_tabla integer DEFAULT 0, IN debug integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.create_resumen_wip_por_prenda(IN modo integer DEFAULT 0, IN recrear_tabla integer DEFAULT 0, IN debug integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    sp_fecha_corrida TIMESTAMPTZ := NOW();
    rows_inserted INTEGER := 0;
    versiones_disponibles TEXT;
    total_versiones INTEGER;
    table_exists BOOLEAN := false;
	column_exists BOOLEAN := false;
    schema_exists BOOLEAN;
    ops_validas_bf INTEGER;
    registros_base INTEGER;
    resumen_final_count INTEGER;
    total_wips INTEGER;
    total_meses INTEGER;
    total_tipos INTEGER;
    rec RECORD;
BEGIN
    -- Verificar prerequisitos
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'silver' AND table_name = 'bd_finanzas'
    ) INTO table_exists;
    
    IF NOT table_exists THEN
        RAISE EXCEPTION '‚ùå Prerequisito faltante: tabla bd_finanzas';
    END IF;
    
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'silver' AND table_name = 'costo_wip_op'
    ) INTO table_exists;
    
    IF NOT table_exists THEN
        RAISE EXCEPTION '‚ùå Prerequisito faltante: tabla costo_wip_op';
    END IF;
    
    RAISE NOTICE 'üîç Detectando metodolog√≠as FLUIDA y truncado...';
    
    -- Crear tabla temporal para versiones
    CREATE TEMP TABLE versiones_fechas (
        version_calculo VARCHAR(50),
        fecha_corrida TIMESTAMPTZ
    );
    
    INSERT INTO versiones_fechas
    SELECT 
        version_calculo,
        MAX(fecha_corrida) as fecha_corrida
    FROM silver.costo_wip_op
    WHERE version_calculo IN ('FLUIDA', 'truncado')
    GROUP BY version_calculo;
    
    GET DIAGNOSTICS total_versiones = ROW_COUNT;
    
    IF total_versiones = 0 THEN
        RAISE EXCEPTION '‚ùå No se encontraron versiones FLUIDA o truncado en costo_wip_op';
    END IF;
    
    IF total_versiones < 2 THEN
        RAISE NOTICE '‚ö†Ô∏è WARNING: Solo se encontr√≥ % versi√≥n de 2 esperadas (FLUIDA + truncado)', total_versiones;
    END IF;
    
    SELECT string_agg(version_calculo || ' (' || fecha_corrida::TEXT || ')', ', ')
    INTO versiones_disponibles
    FROM versiones_fechas;
    
    RAISE NOTICE 'üöÄ INICIANDO RESUMEN WIP POR PRENDA [FLUIDA + truncado]...';
    RAISE NOTICE '   Fecha corrida: %', sp_fecha_corrida;
    RAISE NOTICE '   üî¢ Metodolog√≠as detectadas: %/2', total_versiones;
    RAISE NOTICE '   üìÖ Fechas espec√≠ficas: %', versiones_disponibles;
    
    SELECT COUNT(*) INTO ops_validas_bf 
    FROM silver.bd_finanzas 
    WHERE activo = true AND cod_ordpro IS NOT NULL;
    
    RAISE NOTICE '   üéØ OPs v√°lidas en bd_finanzas: %', ops_validas_bf;
    
    RAISE NOTICE '';
    RAISE NOTICE 'üìä PASO 1: Preparando datos base por metodolog√≠a (FLUIDA + truncado)...';
    
    -- Crear tabla temporal de datos base
    CREATE TEMP TABLE datos_base (
        pr_id VARCHAR(50),
        wip_id VARCHAR(50),
        month_ TIMESTAMPTZ,
        version_calculo VARCHAR(50),
        prod_kg__allocated DECIMAL(18,4),
        prod_q__allocated DECIMAL(18,4),
        days_in_range INTEGER,
        grupo_wip VARCHAR(20),
        base_distribucion DECIMAL(18,4),
        tipo_producto VARCHAR(100),
        prendas_reales DECIMAL(18,2),
        costo_wip DECIMAL(18,4)
    );
    
    INSERT INTO datos_base
    SELECT 
        cwo.pr_id,
        cwo.wip_id,
        cwo.month_,
        cwo.version_calculo,
        cwo.prod_kg__allocated,
        cwo.prod_q__allocated,
        cwo.days_in_range,
        CASE 
            WHEN cwo.wip_id IN ('16', '14', '19a', '24', '19c') THEN 'Textil'
            WHEN cwo.wip_id IN ('34', '40', '44', '37', '45', '49') THEN 'Manufactura'
            ELSE 'Otro'
        END as grupo_wip,
        CASE 
            WHEN cwo.wip_id IN ('16', '14', '19a', '24', '19c') THEN 
                COALESCE(cwo.prod_kg__allocated, 0)
            WHEN cwo.wip_id IN ('34', '40', '44', '37', '45', '49') THEN 
                COALESCE(cwo.days_in_range, 0)::DECIMAL(18,4)
            ELSE 0
        END as base_distribucion,
        bf.tipo_de_producto as tipo_producto,
        bf.prendas_requeridas as prendas_reales,
        CASE 
            WHEN cwo.wip_id IN ('16', '14', '19a', '24', '19c') THEN COALESCE(cwo.costo_textil, 0)
            WHEN cwo.wip_id IN ('34', '40', '44', '37', '45', '49') THEN COALESCE(cwo.costo_manufactura, 0)
            ELSE 0
        END as costo_wip
    FROM silver.costo_wip_op cwo
    INNER JOIN silver.bd_finanzas bf ON cwo.pr_id = bf.cod_ordpro AND bf.activo = true
    INNER JOIN versiones_fechas vf ON cwo.version_calculo = vf.version_calculo 
                                     AND cwo.fecha_corrida = vf.fecha_corrida
    WHERE cwo.pr_id IS NOT NULL
      AND cwo.wip_id IS NOT NULL
      AND cwo.version_calculo IS NOT NULL;
    
    GET DIAGNOSTICS registros_base = ROW_COUNT;
    RAISE NOTICE '   ‚úÖ Registros base: %', registros_base;
    
    RAISE NOTICE '';
    RAISE NOTICE 'üìä PASO 2: Calculando factores de correcci√≥n por versi√≥n...';
    
    -- Crear tabla temporal de factores
    CREATE TEMP TABLE factores (
        pr_id VARCHAR(50),
        wip_id VARCHAR(50),
        version_calculo VARCHAR(50),
        tipo_producto VARCHAR(100),
        factor_correccion DECIMAL(18,6)
    );
    
    INSERT INTO factores
    SELECT 
        pr_id,
        wip_id,
        version_calculo,
        tipo_producto,
        CASE WHEN SUM(base_distribucion) > 0 
             THEN MAX(prendas_reales) / SUM(base_distribucion)
             ELSE 0 END as factor_correccion
    FROM datos_base
    WHERE grupo_wip IN ('Textil', 'Manufactura')
      AND base_distribucion > 0
    GROUP BY pr_id, wip_id, version_calculo, tipo_producto;
    
    GET DIAGNOSTICS registros_base = ROW_COUNT;
    RAISE NOTICE '   ‚úÖ Factores calculados: %', registros_base;
    
    RAISE NOTICE '';
    RAISE NOTICE 'üìä PASO 3: Calculando prendas corregidas por versi√≥n...';
    
    -- Crear tabla temporal de prendas corregidas
    CREATE TEMP TABLE prendas_corregidas (
        pr_id VARCHAR(50),
        wip_id VARCHAR(50),
        month_ TIMESTAMPTZ,
        version_calculo VARCHAR(50),
        grupo_wip VARCHAR(20),
        tipo_producto VARCHAR(100),
        prendas_corregidas DECIMAL(18,4),
        costo_wip DECIMAL(18,4)
    );
    
    INSERT INTO prendas_corregidas
    SELECT 
        db.pr_id,
        db.wip_id,
        db.month_,
        db.version_calculo,
        db.grupo_wip,
        db.tipo_producto,
        db.base_distribucion * COALESCE(fc.factor_correccion, 0) as prendas_corregidas,
        db.costo_wip
    FROM datos_base db
    LEFT JOIN factores fc ON db.pr_id = fc.pr_id 
                            AND db.wip_id = fc.wip_id 
                            AND db.version_calculo = fc.version_calculo
                            AND db.tipo_producto = fc.tipo_producto
    WHERE db.grupo_wip IN ('Textil', 'Manufactura')
      AND db.base_distribucion > 0;
    
    GET DIAGNOSTICS registros_base = ROW_COUNT;
    RAISE NOTICE '   ‚úÖ Prendas corregidas: %', registros_base;
    
    RAISE NOTICE '';
    RAISE NOTICE 'üìä PASO 4: Creando resumen final por versi√≥n...';
    
    -- Crear tabla temporal de resumen final
    CREATE TEMP TABLE resumen_final (
        wip_id VARCHAR(50),
        mes TIMESTAMPTZ,
        version_calculo VARCHAR(50),
        tipo_producto VARCHAR(100),
        total_prendas DECIMAL(18,4),
        total_costo_wip DECIMAL(18,4),
        costo_por_prenda DECIMAL(18,6)
    );
    
    INSERT INTO resumen_final
    SELECT 
        wip_id,
        month_ as mes,
        version_calculo,
        tipo_producto,
        SUM(prendas_corregidas) as total_prendas,
        SUM(costo_wip) as total_costo_wip,
        CASE WHEN SUM(prendas_corregidas) > 0 
             THEN SUM(costo_wip) / SUM(prendas_corregidas)
             ELSE 0 END as costo_por_prenda
    FROM prendas_corregidas
    GROUP BY wip_id, month_, version_calculo, tipo_producto
    HAVING SUM(prendas_corregidas) > 0;
    
    GET DIAGNOSTICS resumen_final_count = ROW_COUNT;
    RAISE NOTICE '   ‚úÖ Resumen final: % registros', resumen_final_count;
    
    -- =====================================================================
    -- MODO CONSULTA (0)
    -- =====================================================================
    IF modo = 0 THEN
        RAISE NOTICE '';
        RAISE NOTICE 'üîç MODO CONSULTA - Resultado METODOLOG√çAS (FLUIDA + truncado) SIN GUARDAR';
        RAISE NOTICE '================================================================================';
        
        -- Mostrar resultado limitado para evitar spam
        RAISE NOTICE 'Top 10 registros por costo total:';
        FOR rec IN 
            SELECT 
                wip_id,
                mes,
                version_calculo,
                tipo_producto,
                total_prendas::DECIMAL(15,0) as total_prendas,
                total_costo_wip::DECIMAL(15,2) as total_costo_wip,
                costo_por_prenda::DECIMAL(10,4) as costo_por_prenda
            FROM resumen_final
            ORDER BY total_costo_wip DESC
            LIMIT 10
        LOOP
            RAISE NOTICE '  WIP:% | % | % | % prendas | $% USD | $% /prenda', 
                rec.wip_id, rec.version_calculo, rec.tipo_producto,
                rec.total_prendas, rec.total_costo_wip, rec.costo_por_prenda;
        END LOOP;
        
        -- Estad√≠sticas
        SELECT 
            COUNT(DISTINCT wip_id),
            COUNT(DISTINCT mes),
            COUNT(DISTINCT tipo_producto),
            COUNT(DISTINCT version_calculo)
        INTO total_wips, total_meses, total_tipos, total_versiones
        FROM resumen_final;
        
        RAISE NOTICE '';
        RAISE NOTICE 'üìä ESTAD√çSTICAS METODOLOG√çAS (FLUIDA + truncado):';
        RAISE NOTICE '   üè≠ WIPs √∫nicos: %', total_wips;
        RAISE NOTICE '   üìÖ Meses √∫nicos: %', total_meses;
        RAISE NOTICE '   üè∑Ô∏è Tipos producto √∫nicos: %', total_tipos;
        RAISE NOTICE '   üî¢ Versiones √∫nicas: %', total_versiones;
        RAISE NOTICE '   üìä Registros totales: %', resumen_final_count;
        
        IF debug = 1 THEN
            RAISE NOTICE '';
            RAISE NOTICE 'üìä DISTRIBUCI√ìN POR METODOLOG√çA:';
            
            FOR rec IN 
                SELECT 
                    version_calculo,
                    COUNT(*) as registros,
                    SUM(total_prendas)::DECIMAL(15,0) as prendas_totales,
                    SUM(total_costo_wip)::DECIMAL(15,2) as costo_total,
                    AVG(costo_por_prenda)::DECIMAL(10,4) as costo_promedio_prenda
                FROM resumen_final
                GROUP BY version_calculo
                ORDER BY version_calculo
            LOOP
                RAISE NOTICE '  % | % reg | % prendas | $% USD | $% /prenda', 
                    rec.version_calculo, rec.registros, rec.prendas_totales, 
                    rec.costo_total, rec.costo_promedio_prenda;
            END LOOP;
        END IF;
    END IF;
    
    -- =====================================================================
    -- MODO GUARDAR (1)
    -- =====================================================================
    IF modo = 1 THEN
        RAISE NOTICE '';
        RAISE NOTICE 'üíæ MODO GUARDAR - Creando tabla METODOLOG√çAS (FLUIDA + truncado) y guardando datos';
        
        -- Crear esquema si no existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.schemata WHERE schema_name = 'silver'
        ) INTO schema_exists;
        
        IF NOT schema_exists THEN
            EXECUTE 'CREATE SCHEMA silver';
            RAISE NOTICE '   üìÅ Esquema silver creado';
        END IF;
        
        -- Verificar si tabla existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'silver' AND table_name = 'resumen_wip_por_prenda'
        ) INTO table_exists;
        
        IF table_exists THEN
            IF recrear_tabla = 1 THEN
                DROP TABLE silver.resumen_wip_por_prenda CASCADE;
                RAISE NOTICE '   ‚ôªÔ∏è Tabla eliminada para recrear';
            ELSE
                RAISE NOTICE '   ‚úÖ Tabla existe, agregando datos hist√≥ricos';
            END IF;
        END IF;
        
        -- Crear tabla si no existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'silver' AND table_name = 'resumen_wip_por_prenda'
        ) INTO table_exists;
        
        IF NOT table_exists THEN
            CREATE TABLE silver.resumen_wip_por_prenda (
                id_resumen BIGSERIAL,
                wip_id VARCHAR(50) NOT NULL,
                mes TIMESTAMPTZ NOT NULL,
                version_calculo VARCHAR(50) NOT NULL,
                tipo_de_producto VARCHAR(100),
                total_prendas DECIMAL(18,4) NOT NULL DEFAULT 0,
                total_costo_wip DECIMAL(18,4) NOT NULL DEFAULT 0,
                costo_por_prenda DECIMAL(18,6) NOT NULL DEFAULT 0,
                fecha_corrida TIMESTAMPTZ DEFAULT NOW(),
                -- NUEVA CLAVE PRIMARIA COMPUESTA
		        PRIMARY KEY (wip_id, mes, version_calculo, tipo_de_producto)
   			);
            
            CREATE INDEX IF NOT EXISTS ix_resumen_wip_por_prenda_wip_id ON silver.resumen_wip_por_prenda (wip_id);
            CREATE INDEX IF NOT EXISTS ix_resumen_wip_por_prenda_mes ON silver.resumen_wip_por_prenda (mes);
            CREATE INDEX IF NOT EXISTS ix_resumen_wip_por_prenda_version ON silver.resumen_wip_por_prenda (version_calculo);
            CREATE INDEX IF NOT EXISTS ix_resumen_wip_por_prenda_tipo_producto ON silver.resumen_wip_por_prenda (tipo_de_producto);
            CREATE INDEX IF NOT EXISTS ix_resumen_wip_por_prenda_fecha_corrida ON silver.resumen_wip_por_prenda (fecha_corrida);
            CREATE INDEX IF NOT EXISTS ix_resumen_wip_por_prenda_combinado ON silver.resumen_wip_por_prenda (wip_id, mes, version_calculo, tipo_de_producto);
            
            RAISE NOTICE '   ‚úÖ Tabla resumen_wip_por_prenda creada con estructura metodolog√≠as';
        ELSE
            RAISE NOTICE '   üìã Tabla existe, verificando estructura...';
            
            -- Verificar columnas cr√≠ticas (sin ALTER TABLE por simplicidad)
           SELECT CASE 
   			 WHEN EXISTS (
      			SELECT 1 FROM information_schema.columns 
       	    	WHERE table_schema = 'silver' AND table_name = 'resumen_wip_por_prenda' 
     	   		AND column_name = 'version_calculo'
 			 ) THEN TRUE 
   			ELSE FALSE 
			END INTO column_exists;
            
            IF column_exists= true THEN
                RAISE NOTICE '   ‚úÖ Estructura verificada correctamente';
            ELSE
                RAISE NOTICE '   ‚ö†Ô∏è Estructura puede necesitar actualizaciones manuales';
            END IF;
        END IF;
        
        -- Insertar datos
        INSERT INTO silver.resumen_wip_por_prenda (
            wip_id, mes, version_calculo, tipo_de_producto, total_prendas, total_costo_wip, costo_por_prenda, fecha_corrida
        )
        SELECT 
            wip_id,
            mes,
            version_calculo,
            tipo_producto as tipo_de_producto,
            total_prendas,
            total_costo_wip,
            costo_por_prenda,
            sp_fecha_corrida
        FROM resumen_final;
        
        GET DIAGNOSTICS rows_inserted = ROW_COUNT;
        
        RAISE NOTICE '   ‚úÖ Registros insertados: %', rows_inserted;
        RAISE NOTICE '';
        RAISE NOTICE 'üìä ESTAD√çSTICAS FINALES POR METODOLOG√çA:';
        
        FOR rec IN 
            SELECT 
                'INSERTADO' as estado,
                version_calculo,
                COUNT(*) as registros,
                SUM(total_prendas)::DECIMAL(15,0) as Prendas_Totales,
                SUM(total_costo_wip)::DECIMAL(15,2) as Costo_Total_USD
            FROM resumen_final
            GROUP BY version_calculo
            ORDER BY version_calculo
        LOOP
            RAISE NOTICE '  % | % | % reg | % prendas | $% USD', 
                rec.estado, rec.version_calculo, rec.registros, 
                rec.prendas_totales, rec.costo_total_usd;
        END LOOP;
        RAISE NOTICE '';
        RAISE NOTICE '‚úÖ RESUMEN_WIP_POR_PRENDA METODOLOG√çAS (FLUIDA + truncado) CREADO EXITOSAMENTE';
        RAISE NOTICE 'üéØ Cada combinaci√≥n wip_id+mes+tipo puede tener hasta 2 filas (FLUIDA + truncado)';
    END IF;
    
    -- Limpiar tablas temporales
    DROP TABLE IF EXISTS versiones_fechas;
    DROP TABLE IF EXISTS datos_base;
    DROP TABLE IF EXISTS factores;
    DROP TABLE IF EXISTS prendas_corregidas;
    DROP TABLE IF EXISTS resumen_final;
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE '‚ùå ERROR: %', error_message;
        
        -- Limpiar tablas temporales en caso de error
        DROP TABLE IF EXISTS versiones_fechas;
        DROP TABLE IF EXISTS datos_base;
        DROP TABLE IF EXISTS factores;
        DROP TABLE IF EXISTS prendas_corregidas;
        DROP TABLE IF EXISTS resumen_final;
        
        RAISE EXCEPTION '%', error_message;
END;
$procedure$

-------------------------------------------------------------------------------------

9. =====================================================================================
NOMBRE: create_resumen_wip_por_prenda_v2
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0, IN recrear_tabla integer DEFAULT 0, IN debug integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.create_resumen_wip_por_prenda_v2(IN modo integer DEFAULT 0, IN recrear_tabla integer DEFAULT 0, IN debug integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    sp_fecha_corrida TIMESTAMPTZ := NOW();
    rows_inserted INTEGER := 0;
    versiones_disponibles TEXT;
    total_versiones INTEGER;
    table_exists BOOLEAN := false;
    column_exists BOOLEAN := false;
    schema_exists BOOLEAN;
    ops_validas_bf INTEGER;
    registros_base INTEGER;
    resumen_final_count INTEGER;
    total_wips INTEGER;
    total_meses INTEGER;
    total_tipos INTEGER;
    total_marcas INTEGER;
    rec RECORD;
BEGIN
    -- Verificar prerequisitos
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'silver' AND table_name = 'bd_finanzas'
    ) INTO table_exists;
    
    IF NOT table_exists THEN
        RAISE EXCEPTION '‚ùå Prerequisito faltante: tabla bd_finanzas';
    END IF;
    
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'silver' AND table_name = 'costo_wip_op'
    ) INTO table_exists;
    
    IF NOT table_exists THEN
        RAISE EXCEPTION '‚ùå Prerequisito faltante: tabla costo_wip_op';
    END IF;
    
    RAISE NOTICE 'üîç Detectando metodolog√≠as FLUIDA y truncado...';
    
    -- Crear tabla temporal para versiones
    CREATE TEMP TABLE versiones_fechas (
        version_calculo VARCHAR(50),
        fecha_corrida TIMESTAMPTZ
    );
    
    INSERT INTO versiones_fechas
    SELECT 
        version_calculo,
        MAX(fecha_corrida) as fecha_corrida
    FROM silver.costo_wip_op
    WHERE version_calculo IN ('FLUIDA', 'truncado')
    GROUP BY version_calculo;
    
    GET DIAGNOSTICS total_versiones = ROW_COUNT;
    
    IF total_versiones = 0 THEN
        RAISE EXCEPTION '‚ùå No se encontraron versiones FLUIDA o truncado en costo_wip_op';
    END IF;
    
    IF total_versiones < 2 THEN
        RAISE NOTICE '‚ö†Ô∏è WARNING: Solo se encontr√≥ % versi√≥n de 2 esperadas (FLUIDA + truncado)', total_versiones;
    END IF;
    
    SELECT string_agg(version_calculo || ' (' || fecha_corrida::TEXT || ')', ', ')
    INTO versiones_disponibles
    FROM versiones_fechas;
    
    RAISE NOTICE 'üöÄ INICIANDO RESUMEN WIP POR PRENDA [FLUIDA + truncado]...';
    RAISE NOTICE '   Fecha corrida: %', sp_fecha_corrida;
    RAISE NOTICE '   üî¢ Metodolog√≠as detectadas: %/2', total_versiones;
    RAISE NOTICE '   üìÖ Fechas espec√≠ficas: %', versiones_disponibles;
    
    SELECT COUNT(*) INTO ops_validas_bf 
    FROM silver.bd_finanzas 
    WHERE activo = true AND cod_ordpro IS NOT NULL;
    
    RAISE NOTICE '   üéØ OPs v√°lidas en bd_finanzas: %', ops_validas_bf;
    
    RAISE NOTICE '';
    RAISE NOTICE 'üìä PASO 1: Preparando datos base por metodolog√≠a (SIN factor de correcci√≥n)...';
    
    -- Crear tabla temporal de datos base (SIN FACTOR DE CORRECCI√ìN)
    CREATE TEMP TABLE datos_base (
        pr_id VARCHAR(50),
        wip_id VARCHAR(50),
        month_ TIMESTAMPTZ,
        version_calculo VARCHAR(50),
        grupo_wip VARCHAR(20),
        tipo_producto VARCHAR(100),
        marca VARCHAR(100),
        prendas_requeridas DECIMAL(18,2),
        prod_q__allocated DECIMAL(18,4),
        costo_wip DECIMAL(18,4)
    );
    
    INSERT INTO datos_base
    SELECT 
        cwo.pr_id,
        cwo.wip_id,
        cwo.month_,
        cwo.version_calculo,
        CASE 
            WHEN cwo.wip_id IN ('16', '14', '19a', '19c', '24', '10c') THEN 'Textil'
            WHEN cwo.wip_id IN ('34', '36', '40', '44', '37', '45', '49', '43', '50') THEN 'Manufactura'
            ELSE 'Otro'
        END as grupo_wip,
        COALESCE(bf.tipo_de_producto, 'Sin tipo') as tipo_producto,
        COALESCE(bf.cliente, 'Sin marca') as marca,
        bf.prendas_requeridas,
        cwo.prod_q__allocated,
        CASE 
            WHEN cwo.wip_id IN ('16', '14', '19a', '19c', '24', '10c') THEN COALESCE(cwo.costo_textil, 0)
            WHEN cwo.wip_id IN ('34', '36', '40', '44', '37', '45', '49', '43', '50') THEN COALESCE(cwo.costo_manufactura, 0)
            ELSE 0
        END as costo_wip
    FROM silver.costo_wip_op cwo
    INNER JOIN silver.bd_finanzas bf ON cwo.pr_id = bf.cod_ordpro AND bf.activo = true
    INNER JOIN versiones_fechas vf ON cwo.version_calculo = vf.version_calculo 
                                     AND cwo.fecha_corrida = vf.fecha_corrida
    WHERE cwo.pr_id IS NOT NULL
      AND cwo.wip_id IS NOT NULL
      AND cwo.wip_id IN ('16', '14', '19a', '19c', '24', '10c', '34', '36', '40', '44', '37', '45', '49', '43', '50')
      AND cwo.version_calculo IN ('FLUIDA', 'truncado');
    
    GET DIAGNOSTICS registros_base = ROW_COUNT;
    RAISE NOTICE '   ‚úÖ Registros base (FLUIDA + truncado): %', registros_base;
    
    RAISE NOTICE '';
    RAISE NOTICE 'üìä PASO 2: Calculando prendas por mes-WIP-OP-VERSI√ìN...';
    
    -- Calcular cu√°ntos meses estuvo cada OP en cada WIP por versi√≥n
    CREATE TEMP TABLE meses_por_op_wip AS
    SELECT 
        pr_id,
        wip_id,
        version_calculo,
        tipo_producto,
        marca,
        prendas_requeridas,
        COUNT(DISTINCT month_) as num_meses
    FROM datos_base
    WHERE grupo_wip IN ('Textil', 'Manufactura')
    GROUP BY pr_id, wip_id, version_calculo, tipo_producto, marca, prendas_requeridas;
    
    CREATE INDEX idx_mpow ON meses_por_op_wip (pr_id, wip_id, version_calculo);
    
    GET DIAGNOSTICS registros_base = ROW_COUNT;
    RAISE NOTICE '   ‚úÖ OP-WIP-VERSI√ìN √∫nicos: %', registros_base;
    
    RAISE NOTICE '';
    RAISE NOTICE 'üìä PASO 3: Distribuyendo prendas por mes y versi√≥n...';
    
    -- Distribuir prendas entre los meses por versi√≥n
    CREATE TEMP TABLE prendas_por_mes AS
    SELECT 
        db.pr_id,
        db.wip_id,
        db.month_,
        db.version_calculo,
        db.grupo_wip,
        db.tipo_producto,
        db.marca,
        -- Prendas por mes = prendas_requeridas / num_meses
        CASE WHEN mpow.num_meses > 0 
             THEN mpow.prendas_requeridas / mpow.num_meses
             ELSE 0 END as prendas_mes,
        db.costo_wip
    FROM datos_base db
    INNER JOIN meses_por_op_wip mpow 
        ON db.pr_id = mpow.pr_id 
        AND db.wip_id = mpow.wip_id
        AND db.version_calculo = mpow.version_calculo
    WHERE db.grupo_wip IN ('Textil', 'Manufactura');
    
    GET DIAGNOSTICS registros_base = ROW_COUNT;
    RAISE NOTICE '   ‚úÖ Prendas distribuidas (FLUIDA + truncado): %', registros_base;
    
    RAISE NOTICE '';
    RAISE NOTICE 'üìä PASO 4: Creando resumen final por WIP-MES-VERSI√ìN-TIPO-MARCA...';
    
    -- Crear tabla temporal de resumen final (CON MARCA Y VERSI√ìN)
    CREATE TEMP TABLE resumen_final (
        wip_id VARCHAR(50),
        mes TIMESTAMPTZ,
        version_calculo VARCHAR(50),
        tipo_producto VARCHAR(100),
        marca VARCHAR(100),
        total_prendas DECIMAL(18,4),
        total_costo_wip DECIMAL(18,4),
        costo_por_prenda DECIMAL(18,6)
    );
    
    INSERT INTO resumen_final
    SELECT 
        wip_id,
        month_ as mes,
        version_calculo,
        tipo_producto,
        marca,
        SUM(prendas_mes) as total_prendas,
        SUM(costo_wip) as total_costo_wip,
        CASE WHEN SUM(prendas_mes) > 0 
             THEN SUM(costo_wip) / SUM(prendas_mes)
             ELSE 0 END as costo_por_prenda
    FROM prendas_por_mes
    GROUP BY wip_id, month_, version_calculo, tipo_producto, marca
    HAVING SUM(prendas_mes) > 0;
    
    GET DIAGNOSTICS resumen_final_count = ROW_COUNT;
    RAISE NOTICE '   ‚úÖ Resumen final: % registros', resumen_final_count;
    
    -- =====================================================================
    -- MODO CONSULTA (0)
    -- =====================================================================
    IF modo = 0 THEN
        RAISE NOTICE '';
        RAISE NOTICE 'üîç MODO CONSULTA - Resultado FLUIDA + truncado (con MARCA) SIN GUARDAR';
        RAISE NOTICE '================================================================================';
        
        -- Mostrar resultado limitado
        RAISE NOTICE 'Top 10 registros por costo total:';
        FOR rec IN 
            SELECT 
                wip_id,
                mes,
                version_calculo,
                marca,
                tipo_producto,
                total_prendas::DECIMAL(15,0) as total_prendas,
                total_costo_wip::DECIMAL(15,2) as total_costo_wip,
                costo_por_prenda::DECIMAL(10,4) as costo_por_prenda
            FROM resumen_final
            ORDER BY total_costo_wip DESC
            LIMIT 10
        LOOP
            RAISE NOTICE '  WIP:% | % | % | % | % | % prendas | $% USD | $% /prenda', 
                rec.wip_id, TO_CHAR(rec.mes, 'YYYY-MM'), rec.version_calculo, 
                rec.marca, rec.tipo_producto,
                rec.total_prendas, rec.total_costo_wip, rec.costo_por_prenda;
        END LOOP;
        
        -- Estad√≠sticas
        SELECT 
            COUNT(DISTINCT wip_id),
            COUNT(DISTINCT mes),
            COUNT(DISTINCT tipo_producto),
            COUNT(DISTINCT marca)
        INTO total_wips, total_meses, total_tipos, total_marcas
        FROM resumen_final;
        
        RAISE NOTICE '';
        RAISE NOTICE 'üìä ESTAD√çSTICAS (FLUIDA + truncado):';
        RAISE NOTICE '   üè≠ WIPs √∫nicos: %', total_wips;
        RAISE NOTICE '   üìÖ Meses √∫nicos: %', total_meses;
        RAISE NOTICE '   üè∑Ô∏è Tipos producto √∫nicos: %', total_tipos;
        RAISE NOTICE '   üè¢ Marcas √∫nicas: %', total_marcas;
        RAISE NOTICE '   üìä Registros totales: %', resumen_final_count;
        
        IF debug = 1 THEN
            RAISE NOTICE '';
            RAISE NOTICE 'üìä DISTRIBUCI√ìN POR METODOLOG√çA:';
            
            FOR rec IN 
                SELECT 
                    version_calculo,
                    COUNT(*) as registros,
                    SUM(total_prendas)::DECIMAL(15,0) as prendas_totales,
                    SUM(total_costo_wip)::DECIMAL(15,2) as costo_total,
                    AVG(costo_por_prenda)::DECIMAL(10,4) as costo_promedio
                FROM resumen_final
                GROUP BY version_calculo
                ORDER BY version_calculo
            LOOP
                RAISE NOTICE '  % | % reg | % prendas | $% USD | $% /prenda', 
                    rec.version_calculo, rec.registros, rec.prendas_totales, 
                    rec.costo_total, rec.costo_promedio;
            END LOOP;
            
            RAISE NOTICE '';
            RAISE NOTICE 'üìä TOP 5 MARCAS POR COSTO:';
            
            FOR rec IN 
                SELECT 
                    marca,
                    COUNT(*) as registros,
                    SUM(total_prendas)::DECIMAL(15,0) as prendas_totales,
                    SUM(total_costo_wip)::DECIMAL(15,2) as costo_total
                FROM resumen_final
                GROUP BY marca
                ORDER BY costo_total DESC
                LIMIT 5
            LOOP
                RAISE NOTICE '  % | % reg | % prendas | $% USD', 
                    rec.marca, rec.registros, rec.prendas_totales, rec.costo_total;
            END LOOP;
        END IF;
    END IF;
    
    -- =====================================================================
    -- MODO GUARDAR (1)
    -- =====================================================================
    IF modo = 1 THEN
        RAISE NOTICE '';
        RAISE NOTICE 'üíæ MODO GUARDAR - Creando tabla con MARCA (FLUIDA + truncado)';
        
        -- Crear esquema si no existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.schemata WHERE schema_name = 'silver'
        ) INTO schema_exists;
        
        IF NOT schema_exists THEN
            EXECUTE 'CREATE SCHEMA silver';
            RAISE NOTICE '   üìÅ Esquema silver creado';
        END IF;
        
        -- Verificar si tabla existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'silver' AND table_name = 'resumen_wip_por_prenda'
        ) INTO table_exists;
        
        IF table_exists THEN
            IF recrear_tabla = 1 THEN
                DROP TABLE silver.resumen_wip_por_prenda CASCADE;
                RAISE NOTICE '   ‚ôªÔ∏è Tabla eliminada para recrear';
            ELSE
                RAISE NOTICE '   ‚úÖ Tabla existe, agregando datos hist√≥ricos';
            END IF;
        END IF;
        
        -- Crear tabla si no existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'silver' AND table_name = 'resumen_wip_por_prenda'
        ) INTO table_exists;
        
        IF NOT table_exists THEN
            CREATE TABLE silver.resumen_wip_por_prenda (
                id_resumen BIGSERIAL,
                wip_id VARCHAR(50) NOT NULL,
                mes TIMESTAMPTZ NOT NULL,
                version_calculo VARCHAR(50) NOT NULL,
                tipo_de_producto VARCHAR(100),
                marca VARCHAR(100),
                total_prendas DECIMAL(18,4) NOT NULL DEFAULT 0,
                total_costo_wip DECIMAL(18,4) NOT NULL DEFAULT 0,
                costo_por_prenda DECIMAL(18,6) NOT NULL DEFAULT 0,
                fecha_corrida TIMESTAMPTZ DEFAULT NOW(),
                -- CLAVE PRIMARIA COMPUESTA CON MARCA Y VERSI√ìN
                PRIMARY KEY (wip_id, mes, version_calculo, tipo_de_producto, marca)
            );
            
            CREATE INDEX IF NOT EXISTS ix_resumen_wip_por_prenda_wip_id ON silver.resumen_wip_por_prenda (wip_id);
            CREATE INDEX IF NOT EXISTS ix_resumen_wip_por_prenda_mes ON silver.resumen_wip_por_prenda (mes);
            CREATE INDEX IF NOT EXISTS ix_resumen_wip_por_prenda_version ON silver.resumen_wip_por_prenda (version_calculo);
            CREATE INDEX IF NOT EXISTS ix_resumen_wip_por_prenda_tipo_producto ON silver.resumen_wip_por_prenda (tipo_de_producto);
            CREATE INDEX IF NOT EXISTS ix_resumen_wip_por_prenda_marca ON silver.resumen_wip_por_prenda (marca);
            CREATE INDEX IF NOT EXISTS ix_resumen_wip_por_prenda_fecha_corrida ON silver.resumen_wip_por_prenda (fecha_corrida);
            CREATE INDEX IF NOT EXISTS ix_resumen_wip_por_prenda_combinado ON silver.resumen_wip_por_prenda (wip_id, mes, version_calculo, tipo_de_producto, marca);
            
            RAISE NOTICE '   ‚úÖ Tabla resumen_wip_por_prenda creada con MARCA y VERSI√ìN';
        ELSE
            RAISE NOTICE '   üìã Tabla existe, verificando estructura...';
            
            -- Verificar si existe columna marca
            SELECT EXISTS (
                SELECT 1 FROM information_schema.columns 
                WHERE table_schema = 'silver' AND table_name = 'resumen_wip_por_prenda' 
                AND column_name = 'marca'
            ) INTO column_exists;
            
            IF NOT column_exists THEN
                RAISE NOTICE '   ‚ö†Ô∏è WARNING: Tabla existe pero falta columna MARCA';
                RAISE NOTICE '   ‚ö†Ô∏è Considera ejecutar con recrear_tabla=1 o agregar columna manualmente';
            ELSE
                RAISE NOTICE '   ‚úÖ Estructura verificada correctamente';
            END IF;
        END IF;
        
        -- Insertar datos
        INSERT INTO silver.resumen_wip_por_prenda (
            wip_id, mes, version_calculo, tipo_de_producto, marca, 
            total_prendas, total_costo_wip, costo_por_prenda, fecha_corrida
        )
        SELECT 
            wip_id,
            mes,
            version_calculo,
            tipo_producto as tipo_de_producto,
            marca,
            total_prendas,
            total_costo_wip,
            costo_por_prenda,
            sp_fecha_corrida
        FROM resumen_final
        ON CONFLICT (wip_id, mes, version_calculo, tipo_de_producto, marca) 
        DO UPDATE SET
            total_prendas = EXCLUDED.total_prendas,
            total_costo_wip = EXCLUDED.total_costo_wip,
            costo_por_prenda = EXCLUDED.costo_por_prenda,
            fecha_corrida = EXCLUDED.fecha_corrida;
        
        GET DIAGNOSTICS rows_inserted = ROW_COUNT;
        
        RAISE NOTICE '   ‚úÖ Registros insertados/actualizados: %', rows_inserted;
        RAISE NOTICE '';
        RAISE NOTICE '‚úÖ RESUMEN_WIP_POR_PRENDA (FLUIDA + truncado + MARCA) CREADO EXITOSAMENTE';
        RAISE NOTICE 'üéØ Clave √∫nica: wip_id + mes + version + tipo + MARCA';
        RAISE NOTICE 'üéØ Cada combinaci√≥n puede tener hasta 2 filas (FLUIDA + truncado)';
    END IF;
    
    -- Limpiar tablas temporales
    DROP TABLE IF EXISTS versiones_fechas;
    DROP TABLE IF EXISTS datos_base;
    DROP TABLE IF EXISTS meses_por_op_wip;
    DROP TABLE IF EXISTS prendas_por_mes;
    DROP TABLE IF EXISTS resumen_final;
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE '‚ùå ERROR: %', error_message;
        
        DROP TABLE IF EXISTS versiones_fechas;
        DROP TABLE IF EXISTS datos_base;
        DROP TABLE IF EXISTS meses_por_op_wip;
        DROP TABLE IF EXISTS prendas_por_mes;
        DROP TABLE IF EXISTS resumen_final;
        
        RAISE EXCEPTION '%', error_message;
END;
$procedure$

-------------------------------------------------------------------------------------

10. =====================================================================================
NOMBRE: create_wip_time_costos_allocation
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0, IN recrear_tabla integer DEFAULT 0, IN debug integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.create_wip_time_costos_allocation(IN modo integer DEFAULT 0, IN recrear_tabla integer DEFAULT 0, IN debug integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    start_time TIMESTAMPTZ := NOW();
    rows_inserted INTEGER := 0;
    table_exists BOOLEAN;
    schema_exists BOOLEAN;
    total_registros INTEGER;
    prs_unicos INTEGER;
    wips_unicos INTEGER;
    fecha_min TIMESTAMPTZ;
    fecha_max TIMESTAMPTZ;
    rec RECORD;
BEGIN
    -- MODO CONSULTA (0)
    IF modo = 0 THEN
        RAISE NOTICE 'üîç MODO CONSULTA - Tabla wip_time_costos_allocation';
        RAISE NOTICE '================================================================================';
        RAISE NOTICE 'TABLA: silver.wip_time_costos_allocation (13 columnas)';
        RAISE NOTICE '';
        RAISE NOTICE 'ESTRUCTURA:';
        RAISE NOTICE '   IDENTIFICADORES: pr_factory_id, pr_id, wip_id, ini_t, end_t';
        RAISE NOTICE '   PER√çODO: month_ (primer d√≠a del mes)';
        RAISE NOTICE '   PRODUCCI√ìN: prod_kg, prod_q (valores originales)';
        RAISE NOTICE '   TIEMPO: days_in_range, total_days';
        RAISE NOTICE '   ALLOCACI√ìN: prod_kg__allocated, prod_q__allocated';
        RAISE NOTICE '   AUDITOR√çA: fecha_corrida';
        RAISE NOTICE '';
        
        -- Verificar si tabla existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'silver' AND table_name = 'wip_time_costos_allocation'
        ) INTO table_exists;
        
        IF table_exists THEN
            RAISE NOTICE '‚úÖ Tabla existe - Mostrando datos completos (top 10):';
            
            FOR rec IN 
                SELECT 
                    pr_factory_id, pr_id, wip_id,
                    ini_t, end_t, month_,
                    prod_kg, prod_q,
                    days_in_range, total_days,
                    prod_kg__allocated, prod_q__allocated,
                    fecha_corrida
                FROM silver.wip_time_costos_allocation
                ORDER BY pr_id, wip_id, month_
                LIMIT 10
            LOOP
                RAISE NOTICE '  PR:% | WIP:% | % | % d√≠as | % kg alloc | % q alloc', 
                    rec.pr_id, rec.wip_id, rec.month_::DATE, 
                    rec.days_in_range, ROUND(rec.prod_kg__allocated, 2), ROUND(rec.prod_q__allocated, 2);
            END LOOP;
            
            -- Estad√≠sticas b√°sicas
            SELECT 
                COUNT(*),
                COUNT(DISTINCT pr_id),
                COUNT(DISTINCT wip_id)
            INTO total_registros, prs_unicos, wips_unicos
            FROM silver.wip_time_costos_allocation;
            
            RAISE NOTICE '';
            RAISE NOTICE 'üìä ESTAD√çSTICAS ACTUALES:';
            RAISE NOTICE '   Total registros: %', total_registros;
            RAISE NOTICE '   PRs √∫nicos: %', prs_unicos;
            RAISE NOTICE '   WIPs √∫nicos: %', wips_unicos;
            
        ELSE
            RAISE NOTICE '‚ùå Tabla NO existe - Mostrando vista previa desde wip_real (top 10):';
            
            -- Preview completo usando range_split
            FOR rec IN 
                WITH range_split AS (
                    SELECT     
                        ds.pr_factory_id,     
                        ds.pr_id,     
                        ds.wip_id,     
                        ds.ini_t,     
                        ds.end_t,     
                        month_start AS month_,     
                        ds.prod_kg,     
                        ds.prod_q,     
                        EXTRACT(DAY FROM 
                            LEAST(ds.end_t, month_start + INTERVAL '1 month' - INTERVAL '1 day') - 
                            GREATEST(ds.ini_t, month_start)
                        ) + 1 AS days_in_range
                    FROM (
                        SELECT 
                            pr_factory_id, pr_id, wip_id, 
                            start_ts AS ini_t, end_ts AS end_t,     
                            prod_kg, prod_q     
                        FROM silver.wip_real
                        WHERE start_ts IS NOT NULL 
                          AND end_ts IS NOT NULL
                          AND pr_id IS NOT NULL
                          AND wip_id IS NOT NULL
                    ) AS ds 
                    CROSS JOIN LATERAL (
                        SELECT generate_series(
                            date_trunc('month', ds.ini_t),
                            date_trunc('month', ds.end_t),
                            INTERVAL '1 month'
                        ) AS month_start
                    ) AS months
                    WHERE GREATEST(ds.ini_t, month_start) <= LEAST(ds.end_t, month_start + INTERVAL '1 month' - INTERVAL '1 day')
                ),
                base_with_allocations AS (
                    SELECT     
                        pr_factory_id,     
                        pr_id,     
                        wip_id,     
                        ini_t,     
                        end_t,     
                        month_,     
                        prod_kg,     
                        prod_q,     
                        days_in_range,     
                        SUM(days_in_range) OVER (PARTITION BY pr_factory_id, pr_id, wip_id) AS total_days,     
                        CASE 
                            WHEN SUM(days_in_range) OVER (PARTITION BY pr_factory_id, pr_id, wip_id) > 0 
                            THEN prod_kg * days_in_range::DECIMAL / SUM(days_in_range) OVER (PARTITION BY pr_factory_id, pr_id, wip_id)
                            ELSE 0 
                        END AS prod_kg__allocated,     
                        CASE 
                            WHEN SUM(days_in_range) OVER (PARTITION BY pr_factory_id, pr_id, wip_id) > 0 
                            THEN prod_q * days_in_range::DECIMAL / SUM(days_in_range) OVER (PARTITION BY pr_factory_id, pr_id, wip_id)
                            ELSE 0 
                        END AS prod_q__allocated
                    FROM range_split
                )
                SELECT 
                    pr_factory_id, pr_id, wip_id,
                    ini_t, end_t, month_,
                    prod_kg, prod_q,
                    days_in_range, total_days,
                    prod_kg__allocated, prod_q__allocated,
                    'PREVIEW' as estado
                FROM base_with_allocations
                ORDER BY pr_id, wip_id, month_
                LIMIT 10
            LOOP
                RAISE NOTICE '  PR:% | WIP:% | % | % d√≠as | % kg alloc | % q alloc | %', 
                    rec.pr_id, rec.wip_id, rec.month_::DATE, 
                    rec.days_in_range, ROUND(rec.prod_kg__allocated, 2), ROUND(rec.prod_q__allocated, 2), rec.estado;
            END LOOP;
        END IF;
        
        IF debug = 1 THEN
            RAISE NOTICE '';
            RAISE NOTICE 'üîß DEBUG - Fuente wip_real:';
            
            SELECT 
                COUNT(*),
                COUNT(DISTINCT pr_id),
                COUNT(DISTINCT wip_id),
                MIN(start_ts),
                MAX(end_ts)
            INTO total_registros, prs_unicos, wips_unicos, fecha_min, fecha_max
            FROM silver.wip_real
            WHERE start_ts IS NOT NULL AND end_ts IS NOT NULL;
            
            RAISE NOTICE '  Total registros wip_real: %', total_registros;
            RAISE NOTICE '  PRs √∫nicos: %', prs_unicos;
            RAISE NOTICE '  WIPs √∫nicos: %', wips_unicos;
            RAISE NOTICE '  Fecha min: %', fecha_min;
            RAISE NOTICE '  Fecha max: %', fecha_max;
        END IF;
        
        RETURN;
    END IF;
    
    -- MODO GUARDAR (1)
    IF modo = 1 THEN
        RAISE NOTICE 'üíæ MODO GUARDAR - Creando/poblando wip_time_costos_allocation';
        RAISE NOTICE '   Recrear tabla: %', CASE WHEN recrear_tabla = 1 THEN 'S√ç' ELSE 'NO' END;
        
        -- Crear esquema si no existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.schemata WHERE schema_name = 'silver'
        ) INTO schema_exists;
        
        IF NOT schema_exists THEN
            EXECUTE 'CREATE SCHEMA silver';
            RAISE NOTICE '   üìÅ Esquema silver creado';
        END IF;
        
        -- Verificar/crear tabla
        SELECT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'silver' AND table_name = 'wip_time_costos_allocation'
        ) INTO table_exists;
        
        IF table_exists THEN
            IF recrear_tabla = 1 THEN
                DROP TABLE silver.wip_time_costos_allocation CASCADE;
                RAISE NOTICE '   ‚ôªÔ∏è Tabla anterior eliminada para recrear';
            ELSE
                RAISE NOTICE '   ‚úÖ Tabla ya existe, agregando datos nuevos (hist√≥ricos)';
            END IF;
        END IF;
        
        -- Crear tabla si no existe
        SELECT EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'silver' AND table_name = 'wip_time_costos_allocation'
        ) INTO table_exists;
        
        IF NOT table_exists THEN
            CREATE TABLE silver.wip_time_costos_allocation (
                pr_factory_id VARCHAR(50),
                pr_id VARCHAR(50),
                wip_id VARCHAR(50),
                ini_t TIMESTAMPTZ,
                end_t TIMESTAMPTZ,
                month_ TIMESTAMPTZ,
                prod_kg DECIMAL(18,4),
                prod_q DECIMAL(18,4),
                days_in_range INTEGER,
                total_days INTEGER,
                prod_kg__allocated DECIMAL(18,4),
                prod_q__allocated DECIMAL(18,4),
                fecha_corrida TIMESTAMPTZ DEFAULT NOW()
            );
            
            -- Crear √≠ndices
            CREATE INDEX IF NOT EXISTS ix_wip_time_costos_allocation_pr_id ON silver.wip_time_costos_allocation (pr_id);
            CREATE INDEX IF NOT EXISTS ix_wip_time_costos_allocation_wip_id ON silver.wip_time_costos_allocation (wip_id);
            CREATE INDEX IF NOT EXISTS ix_wip_time_costos_allocation_month ON silver.wip_time_costos_allocation (month_);
            CREATE INDEX IF NOT EXISTS ix_wip_time_costos_allocation_fecha_corrida ON silver.wip_time_costos_allocation (fecha_corrida);
            
            RAISE NOTICE '   ‚úÖ Tabla wip_time_costos_allocation creada con √≠ndices';
        END IF;
        
        -- POBLAR TABLA CON L√ìGICA RANGE_SPLIT COMPLETA
        RAISE NOTICE '';
        RAISE NOTICE 'üìä Poblando tabla con l√≥gica range_split desde wip_real...';
        
        WITH range_split AS (
            SELECT     
                ds.pr_factory_id,     
                ds.pr_id,     
                ds.wip_id,     
                ds.ini_t,     
                ds.end_t,     
                month_start AS month_,     
                ds.prod_kg,     
                ds.prod_q,     
                EXTRACT(DAY FROM 
                    LEAST(ds.end_t, month_start + INTERVAL '1 month' - INTERVAL '1 day') - 
                    GREATEST(ds.ini_t, month_start)
                ) + 1 AS days_in_range
            FROM (
                SELECT 
                    pr_factory_id, pr_id, wip_id, 
                    start_ts AS ini_t, end_ts AS end_t,     
                    prod_kg, prod_q     
                FROM silver.wip_real
                WHERE start_ts IS NOT NULL 
                  AND end_ts IS NOT NULL
                  AND pr_id IS NOT NULL
                  AND wip_id IS NOT NULL
            ) AS ds 
            CROSS JOIN LATERAL (
                SELECT generate_series(
                    date_trunc('month', ds.ini_t),
                    date_trunc('month', ds.end_t),
                    INTERVAL '1 month'
                ) AS month_start
            ) AS months
            WHERE GREATEST(ds.ini_t, month_start) <= LEAST(ds.end_t, month_start + INTERVAL '1 month' - INTERVAL '1 day')
              AND EXTRACT(DAY FROM 
                    LEAST(ds.end_t, month_start + INTERVAL '1 month' - INTERVAL '1 day') - 
                    GREATEST(ds.ini_t, month_start)
                  ) >= 0
        ),
        base_wip_with_allocations AS (
            SELECT     
                pr_factory_id,     
                pr_id,     
                wip_id,     
                ini_t,     
                end_t,     
                month_,     
                prod_kg,     
                prod_q,     
                days_in_range,     
                SUM(days_in_range) OVER (PARTITION BY pr_factory_id, pr_id, wip_id) AS total_days,     
                CASE 
                    WHEN SUM(days_in_range) OVER (PARTITION BY pr_factory_id, pr_id, wip_id) > 0 
                    THEN prod_kg * days_in_range::DECIMAL / SUM(days_in_range) OVER (PARTITION BY pr_factory_id, pr_id, wip_id)
                    ELSE 0 
                END AS prod_kg__allocated,     
                CASE 
                    WHEN SUM(days_in_range) OVER (PARTITION BY pr_factory_id, pr_id, wip_id) > 0 
                    THEN prod_q * days_in_range::DECIMAL / SUM(days_in_range) OVER (PARTITION BY pr_factory_id, pr_id, wip_id)
                    ELSE 0 
                END AS prod_q__allocated
            FROM range_split
        )
        INSERT INTO silver.wip_time_costos_allocation (
            pr_factory_id, pr_id, wip_id, ini_t, end_t, month_,
            prod_kg, prod_q, days_in_range, total_days,
            prod_kg__allocated, prod_q__allocated, fecha_corrida
        )
        SELECT 
            pr_factory_id, pr_id, wip_id, ini_t, end_t, month_,
            prod_kg, prod_q, days_in_range, total_days,
            prod_kg__allocated, prod_q__allocated, NOW()
        FROM base_wip_with_allocations;
        
        GET DIAGNOSTICS rows_inserted = ROW_COUNT;
        
        -- Estad√≠sticas finales
        SELECT 
            COUNT(*),
            COUNT(DISTINCT pr_id),
            COUNT(DISTINCT wip_id),
            MIN(month_),
            MAX(month_)
        INTO total_registros, prs_unicos, wips_unicos, fecha_min, fecha_max
        FROM silver.wip_time_costos_allocation;
        
        RAISE NOTICE '   ‚úÖ Registros insertados: %', rows_inserted;
        RAISE NOTICE '';
        RAISE NOTICE 'üìä ESTAD√çSTICAS FINALES:';
        RAISE NOTICE '   üìä Total registros: %', total_registros;
        RAISE NOTICE '   üìä PRs √∫nicos: %', prs_unicos;
        RAISE NOTICE '   üìä WIPs √∫nicos: %', wips_unicos;
        RAISE NOTICE '   üìÖ Per√≠odo: % a %', fecha_min::DATE, fecha_max::DATE;
        
        RAISE NOTICE '';
        RAISE NOTICE '‚úÖ WIP_TIME_COSTOS_ALLOCATION CREADA Y POBLADA EXITOSAMENTE';
    END IF;
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE '‚ùå ERROR en silver.CREATE_WIP_TIME_COSTOS_ALLOCATION: %', error_message;
        RAISE EXCEPTION '%', error_message;
END;
$procedure$

-------------------------------------------------------------------------------------

11. =====================================================================================
NOMBRE: populate_costo_avios
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0, IN fecha_desde timestamp with time zone DEFAULT '2016-01-01 05:00:00+00'::timestamp with time zone, IN estilo_filtro character varying DEFAULT NULL::character varying, IN debug integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.populate_costo_avios(IN modo integer DEFAULT 0, IN fecha_desde timestamp with time zone DEFAULT '2016-01-01 05:00:00+00'::timestamp with time zone, IN estilo_filtro character varying DEFAULT NULL::character varying, IN debug integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    rows_inserted INTEGER := 0;
    rows_processed INTEGER := 0;
    fecha_ejecucion TIMESTAMPTZ := NOW();
    table_exists BOOLEAN;
    schema_exists BOOLEAN;
    total_consulta INTEGER;
    costo_promedio_consulta DECIMAL(18,4);
    registros_existentes INTEGER;
    total_registros INTEGER;
    costo_promedio DECIMAL(18,4);
    ops_unicas INTEGER;
    fecha_min TIMESTAMPTZ;
    fecha_max TIMESTAMPTZ;
    rec RECORD;
BEGIN
    -- Verificar prerequisito
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'silver' AND table_name = 'costo_avios'
    ) INTO table_exists;
    
    IF NOT table_exists THEN
        RAISE EXCEPTION '‚ùå ERROR: Tabla costo_avios no existe. SOLUCI√ìN: Ejecutar primero create_costo_avios_tdv(1)';
    END IF;
    
    -- ‚úÖ INICIO DEL PROCESO - L√ìGICA COMPLEJA ORIGINAL
    RAISE NOTICE 'üîÑ INICIANDO C√ÅLCULO COSTO_AVIOS CON L√ìGICA COMPLEJA...';
    RAISE NOTICE '   Fecha desde: %', fecha_desde;
    IF estilo_filtro IS NOT NULL THEN
        RAISE NOTICE '   Estilo filtro: %', estilo_filtro;
    ELSE
        RAISE NOTICE '   Alcance: TODAS LAS OPs';
    END IF;
    
    -- ‚úÖ PASO 1: Crear tablas temporales con l√≥gica compleja original
    RAISE NOTICE 'üìä Paso 1: Clasificando movimientos de av√≠os (L√ìGICA ORIGINAL)...';
    
    CREATE TEMP TABLE movimientos_avios (
        op_codigo varchar(50),
        estilo_codigo varchar(50),
        avio_codigo varchar(50),
        tipo_movimiento varchar(10),
        can_movimiento decimal(18,2),
        imp_valorizado decimal(18,4),
        fecha_movimiento timestamptz,
        can_consuni decimal(18,4)
    );
    
    -- ‚úÖ L√ìGICA ORIGINAL RESTAURADA: Movimientos clasificados con can_consuni
    INSERT INTO movimientos_avios
    SELECT DISTINCT 
        b.cod_ordpro as op_codigo,
        op_info.cod_estpro as estilo_codigo,
        b.cod_item as avio_codigo,
        CASE 
            WHEN a.cod_tipmov IN ('S21', 'S08') THEN 'SALIDA'
            WHEN a.cod_tipmov = 'D21' THEN 'DEVOLUCION'
            WHEN a.cod_tipmov IN ('STG', 'SMS', 'SSG') THEN 'ENTRADA'
            ELSE 'OTROS'
        END as tipo_movimiento,
        COALESCE(b.can_movimiento, 0) as can_movimiento,
        COALESCE(b.imp_valorizado_dolares, 0) as imp_valorizado,
        a.fec_movstk as fecha_movimiento,
        COALESCE(cot_ranked.can_consuni, 0) as can_consuni
    FROM bronze.lg_movistk a
    INNER JOIN bronze.lg_movistkitem b ON a.cod_almacen = b.cod_almacen AND a.num_movstk = b.num_movstk
    LEFT JOIN bronze.lg_item item ON b.cod_item = item.cod_item
    LEFT JOIN bronze.es_ordpro op_info ON b.cod_ordpro = op_info.cod_ordpro
    LEFT JOIN (
        SELECT 
            cod_estpro, 
            cod_item, 
            can_consuni,
            ROW_NUMBER() OVER (PARTITION BY cod_estpro, cod_item ORDER BY can_consuni DESC) as rn
        FROM bronze.tg_cotizacion_estilospropios_comp
        WHERE (estilo_filtro IS NULL OR cod_estpro = estilo_filtro)
    ) cot_ranked ON op_info.cod_estpro = cot_ranked.cod_estpro 
                  AND b.cod_item = cot_ranked.cod_item 
                  AND cot_ranked.rn = 1
    WHERE b.cod_ordpro IS NOT NULL
      AND b.can_movimiento IS NOT NULL
      AND a.fec_movstk >= fecha_desde
      AND b.imp_valorizado_dolares IS NOT NULL
      AND op_info.cod_estpro IS NOT NULL
      AND (estilo_filtro IS NULL OR op_info.cod_estpro = estilo_filtro);
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '   ‚úÖ Movimientos clasificados: %', rows_processed;
    
    -- ‚úÖ PASO 2: Calcular resumen por OP con l√≥gica compleja original
    RAISE NOTICE 'üìä Paso 2: Calculando costos por OP (L√ìGICA PYTHON AGREGACI√ìN)...';
    
    CREATE TEMP TABLE resumen_por_op (
        op_codigo varchar(50) PRIMARY KEY,
        estilo_codigo varchar(50),
        costo_total_corregido_por_prenda decimal(18,4),
        cantidad_avios_por_op integer,
        costo_total_op_usd decimal(18,4),
        primera_entrada_avios timestamptz,
        ultima_salida_avios timestamptz,
        total_salidas_can decimal(18,2),
        total_salidas_usd decimal(18,4),
        total_devoluciones_can decimal(18,2),
        total_devoluciones_usd decimal(18,4),
        can_movimiento_neto_total decimal(18,2),
        imp_valorizado_neto_total decimal(18,4)
    );
    
    -- ‚úÖ L√ìGICA ORIGINAL RESTAURADA: Agregaci√≥n compleja con precio_unitario_real
    WITH movimientos_por_op_avio AS (
        SELECT 
            op_codigo,
            estilo_codigo,
            avio_codigo,
            -- Salidas
            SUM(CASE WHEN tipo_movimiento = 'SALIDA' THEN can_movimiento ELSE 0 END) as can_salidas,
            SUM(CASE WHEN tipo_movimiento = 'SALIDA' THEN imp_valorizado ELSE 0 END) as imp_salidas,
            -- Devoluciones  
            SUM(CASE WHEN tipo_movimiento = 'DEVOLUCION' THEN can_movimiento ELSE 0 END) as can_devoluciones,
            SUM(CASE WHEN tipo_movimiento = 'DEVOLUCION' THEN imp_valorizado ELSE 0 END) as imp_devoluciones,
            -- Fechas
            MIN(CASE WHEN tipo_movimiento = 'ENTRADA' THEN fecha_movimiento END) as primera_entrada,
            MAX(CASE WHEN tipo_movimiento = 'SALIDA' THEN fecha_movimiento END) as ultima_salida,
            -- CAN_CONSUNI (tomar el primer valor no nulo)
            MAX(can_consuni) as can_consuni
        FROM movimientos_avios
        GROUP BY op_codigo, estilo_codigo, avio_codigo
    ),
    costos_por_op_avio AS (
        SELECT 
            op_codigo,
            estilo_codigo,
            avio_codigo,
            can_salidas,
            imp_salidas,
            can_devoluciones, 
            imp_devoluciones,
            (can_salidas - can_devoluciones) as can_neto,
            (imp_salidas - imp_devoluciones) as imp_neto,
            -- ‚úÖ L√ìGICA RESTAURADA: Precio unitario real desde movimientos
            CASE 
                WHEN (can_salidas - can_devoluciones) > 0 
                THEN (imp_salidas - imp_devoluciones) / (can_salidas - can_devoluciones)
                ELSE 0 
            END as precio_unitario_real,
            can_consuni,
            primera_entrada,
            ultima_salida
        FROM movimientos_por_op_avio
    ),
    costo_por_prenda_por_avio AS (
        SELECT 
            *,
            -- ‚úÖ L√ìGICA RESTAURADA: Costo corregido por prenda
            (precio_unitario_real * can_consuni) as costo_corregido_por_prenda_avio
        FROM costos_por_op_avio
    )
    INSERT INTO resumen_por_op
    SELECT 
        op_codigo,
        MAX(estilo_codigo) as estilo_codigo,
        -- ‚úÖ L√ìGICA RESTAURADA: Suma de costos corregidos por prenda
        SUM(costo_corregido_por_prenda_avio) as costo_total_corregido_por_prenda,
        COUNT(DISTINCT avio_codigo) as cantidad_avios_por_op,
        SUM(imp_neto) as costo_total_op_usd,
        MIN(primera_entrada) as primera_entrada_avios,
        MAX(ultima_salida) as ultima_salida_avios,
        SUM(can_salidas) as total_salidas_can,
        SUM(imp_salidas) as total_salidas_usd,
        SUM(can_devoluciones) as total_devoluciones_can,
        SUM(imp_devoluciones) as total_devoluciones_usd,
        SUM(can_neto) as can_movimiento_neto_total,
        SUM(imp_neto) as imp_valorizado_neto_total
    FROM costo_por_prenda_por_avio
    GROUP BY op_codigo;
    
    GET DIAGNOSTICS rows_inserted = ROW_COUNT;
    RAISE NOTICE '   ‚úÖ Resumen por OP calculado: %', rows_inserted;
    
    -- ‚úÖ MODO CONSULTA (0)
    IF modo = 0 THEN
        RAISE NOTICE '';
        RAISE NOTICE 'üîç MODO CONSULTA - Resultado de c√°lculos SIN GUARDAR';
        RAISE NOTICE '================================================================================';
        
        -- Mostrar resultado de c√°lculos
        RAISE NOTICE 'Top 10 OPs por costo corregido por prenda:';
        FOR rec IN 
            SELECT 
                r.op_codigo,
                r.estilo_codigo,
                r.costo_total_corregido_por_prenda::decimal(15,4),
                r.cantidad_avios_por_op,
                r.costo_total_op_usd::decimal(15,2),
                r.can_movimiento_neto_total::decimal(15,2),
                r.imp_valorizado_neto_total::decimal(15,2)
            FROM resumen_por_op r
            WHERE r.imp_valorizado_neto_total > 0  -- Solo con costos v√°lidos
            ORDER BY r.costo_total_corregido_por_prenda DESC
            LIMIT 10
        LOOP
            RAISE NOTICE '  OP:% | Est:% | $% /prenda | % av√≠os | $% total', 
                rec.op_codigo, rec.estilo_codigo, rec.costo_total_corregido_por_prenda,
                rec.cantidad_avios_por_op, rec.costo_total_op_usd;
        END LOOP;
        
        -- Estad√≠sticas de consulta
        SELECT 
            COUNT(*),
            AVG(costo_total_corregido_por_prenda)
        INTO total_consulta, costo_promedio_consulta
        FROM resumen_por_op
        WHERE imp_valorizado_neto_total > 0;
        
        RAISE NOTICE '';
        RAISE NOTICE 'üìä ESTAD√çSTICAS DE CONSULTA:';
        RAISE NOTICE '   üìÖ Fecha_corrida que se asignar√≠a: %', fecha_ejecucion;
        RAISE NOTICE '   ‚úÖ Registros que se insertar√≠an: %', COALESCE(total_consulta, 0);
        RAISE NOTICE '   üí∞ Costo promedio por prenda: $%', COALESCE(costo_promedio_consulta, 0);
        RAISE NOTICE '   üéØ Movimientos procesados: %', rows_processed;
        
        IF debug = 1 THEN
            RAISE NOTICE '';
            RAISE NOTICE 'üîß DEBUG - Top 5 OPs por costo:';
            
            FOR rec IN 
                SELECT 
                    op_codigo,
                    costo_total_corregido_por_prenda::decimal(15,4),
                    cantidad_avios_por_op,
                    costo_total_op_usd::decimal(15,2)
                FROM resumen_por_op
                WHERE imp_valorizado_neto_total > 0
                ORDER BY costo_total_corregido_por_prenda DESC
                LIMIT 5
            LOOP
                RAISE NOTICE '  OP:% | $% /prenda | % av√≠os | $% total', 
                    rec.op_codigo, rec.costo_total_corregido_por_prenda,
                    rec.cantidad_avios_por_op, rec.costo_total_op_usd;
            END LOOP;
            
            RAISE NOTICE '';
            RAISE NOTICE 'üîß DEBUG - Distribuci√≥n por rangos de costo:';
            
            FOR rec IN 
                SELECT 
                    CASE 
                        WHEN costo_total_corregido_por_prenda <= 1 THEN '$0-1'
                        WHEN costo_total_corregido_por_prenda <= 5 THEN '$1-5'
                        WHEN costo_total_corregido_por_prenda <= 10 THEN '$5-10'
                        WHEN costo_total_corregido_por_prenda <= 25 THEN '$10-25'
                        ELSE '$25+'
                    END as rango_costo,
                    COUNT(*) as cantidad_ops,
                    AVG(costo_total_corregido_por_prenda)::decimal(10,2) as costo_promedio
                FROM resumen_por_op
                WHERE imp_valorizado_neto_total > 0
                GROUP BY 
                    CASE 
                        WHEN costo_total_corregido_por_prenda <= 1 THEN '$0-1'
                        WHEN costo_total_corregido_por_prenda <= 5 THEN '$1-5'
                        WHEN costo_total_corregido_por_prenda <= 10 THEN '$5-10'
                        WHEN costo_total_corregido_por_prenda <= 25 THEN '$10-25'
                        ELSE '$25+'
                    END
                ORDER BY rango_costo
            LOOP
                RAISE NOTICE '  % | % OPs | $% promedio', 
                    rec.rango_costo, rec.cantidad_ops, rec.costo_promedio;
            END LOOP;
        END IF;
    END IF;
    
    -- ‚úÖ MODO GUARDAR (1)
    IF modo = 1 THEN
        RAISE NOTICE '';
        RAISE NOTICE 'üíæ MODO GUARDAR - Ejecutando inserci√≥n HIST√ìRICA';
        RAISE NOTICE '   üéØ L√ìGICA HIST√ìRICA: Solo INSERT (acumula datos por fecha_corrida)';
        
        -- Verificar si ya existen datos para esta fecha
        SELECT COUNT(*)
        INTO registros_existentes
        FROM silver.costo_avios 
        WHERE fecha_corrida::date = fecha_ejecucion::date;
        
        IF registros_existentes > 0 THEN
            RAISE NOTICE '   ‚ö†Ô∏è Ya existen % registros para hoy', registros_existentes;
            RAISE NOTICE '   üìä Agregando datos adicionales (l√≥gica hist√≥rica)';
        END IF;
        
        -- ‚úÖ INSERTAR CON L√ìGICA HIST√ìRICA (solo INSERT)
        INSERT INTO silver.costo_avios (
            op_codigo,
            estilo_codigo,
            costo_total_corregido_por_prenda,
            cantidad_avios_por_op,
            costo_total_op_usd,
            primera_entrada_avios,
            ultima_salida_avios,
            total_salidas_can,
            total_salidas_usd,
            total_devoluciones_can,
            total_devoluciones_usd,
            can_movimiento_neto_total,
            imp_valorizado_neto_total,
            fecha_corrida
        )
        SELECT 
            r.op_codigo,
            r.estilo_codigo,
            r.costo_total_corregido_por_prenda,
            r.cantidad_avios_por_op,
            r.costo_total_op_usd,
            r.primera_entrada_avios,
            r.ultima_salida_avios,
            r.total_salidas_can,
            r.total_salidas_usd,
            r.total_devoluciones_can,
            r.total_devoluciones_usd,
            r.can_movimiento_neto_total,
            r.imp_valorizado_neto_total,
            fecha_ejecucion
        FROM resumen_por_op r
        WHERE r.imp_valorizado_neto_total > 0;  -- Solo con costos v√°lidos
        
        GET DIAGNOSTICS rows_inserted = ROW_COUNT;
        
        -- Estad√≠sticas finales
        SELECT 
            COUNT(*),
            AVG(costo_total_corregido_por_prenda),
            COUNT(DISTINCT op_codigo),
            MIN(primera_entrada_avios),
            MAX(ultima_salida_avios)
        INTO total_registros, costo_promedio, ops_unicas, fecha_min, fecha_max
        FROM silver.costo_avios;
        
        RAISE NOTICE '   ‚úÖ Registros insertados: %', rows_inserted;
        RAISE NOTICE '';
        RAISE NOTICE 'üìä ESTAD√çSTICAS FINALES:';
        RAISE NOTICE '   üìä Total registros COSTO_AVIOS: %', total_registros;
        RAISE NOTICE '   üìä OPs √∫nicas: %', ops_unicas;
        RAISE NOTICE '   üí∞ Costo promedio por prenda: $%', costo_promedio;
        RAISE NOTICE '   üìÖ Rango movimientos: % a %', fecha_min, fecha_max;
        RAISE NOTICE '   üìã Movimientos procesados: %', rows_processed;
        
        RAISE NOTICE '';
        RAISE NOTICE '‚úÖ COSTO_AVIOS POBLADO EXITOSAMENTE CON L√ìGICA COMPLEJA';
        RAISE NOTICE 'üéØ L√ìGICA HIST√ìRICA APLICADA: Datos acumulados por fecha_corrida';
    END IF;
    
    -- Limpiar tablas temporales
    DROP TABLE IF EXISTS movimientos_avios;
    DROP TABLE IF EXISTS resumen_por_op;
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE '‚ùå ERROR en silver.sp_populate_costo_avios_tdv: %', error_message;
        
        -- Limpiar tablas temporales en caso de error
        DROP TABLE IF EXISTS movimientos_avios;
        DROP TABLE IF EXISTS resumen_por_op;
        
        RAISE EXCEPTION '%', error_message;
END;
$procedure$

-------------------------------------------------------------------------------------

12. =====================================================================================
NOMBRE: populate_costo_avios_v2
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0, IN fecha_desde timestamp with time zone DEFAULT '2016-01-01 05:00:00+00'::timestamp with time zone, IN estilo_filtro character varying DEFAULT NULL::character varying, IN debug integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.populate_costo_avios_v2(IN modo integer DEFAULT 0, IN fecha_desde timestamp with time zone DEFAULT '2016-01-01 05:00:00+00'::timestamp with time zone, IN estilo_filtro character varying DEFAULT NULL::character varying, IN debug integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    rows_inserted INTEGER := 0;
    rows_processed INTEGER := 0;
    fecha_ejecucion TIMESTAMPTZ := NOW();
    table_exists BOOLEAN;
    total_consulta INTEGER;
    costo_promedio_consulta DECIMAL(18,4);
    registros_existentes INTEGER;
    total_registros INTEGER;
    costo_promedio DECIMAL(18,4);
    ops_unicas INTEGER;
    fecha_min TIMESTAMPTZ;
    fecha_max TIMESTAMPTZ;
    rec RECORD;
BEGIN
    -- Verificar prerequisito
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'silver' AND table_name = 'costo_avios_v2'
    ) INTO table_exists;
    
    IF NOT table_exists THEN
        RAISE EXCEPTION '‚ùå ERROR: Tabla costo_avios_v2 no existe. SOLUCI√ìN: Ejecutar primero el CREATE TABLE';
    END IF;
    
    -- ‚úÖ INICIO DEL PROCESO
    RAISE NOTICE 'üîÑ INICIANDO C√ÅLCULO COSTO_AVIOS_V2 CON DETALLE DE AV√çOS EN COLUMNAS...';
    RAISE NOTICE '   Fecha desde: %', fecha_desde;
    IF estilo_filtro IS NOT NULL THEN
        RAISE NOTICE '   Estilo filtro: %', estilo_filtro;
    ELSE
        RAISE NOTICE '   Alcance: TODAS LAS OPs';
    END IF;
    
    -- ‚úÖ PASO 1: Crear tablas temporales
    RAISE NOTICE 'üìä Paso 1: Clasificando movimientos de av√≠os...';
    
    CREATE TEMP TABLE movimientos_avios (
        op_codigo varchar(50),
        estilo_codigo varchar(50),
        avio_codigo varchar(50),
        tipo_movimiento varchar(10),
        can_movimiento decimal(18,2),
        imp_valorizado decimal(18,4),
        fecha_movimiento timestamptz,
        can_consuni decimal(18,4)
    );
    
    INSERT INTO movimientos_avios
    SELECT DISTINCT 
        b.cod_ordpro as op_codigo,
        op_info.cod_estpro as estilo_codigo,
        b.cod_item as avio_codigo,
        CASE 
            WHEN a.cod_tipmov IN ('S21', 'S08') THEN 'SALIDA'
            WHEN a.cod_tipmov = 'D21' THEN 'DEVOLUCION'
            WHEN a.cod_tipmov IN ('STG', 'SMS', 'SSG') THEN 'ENTRADA'
            ELSE 'OTROS'
        END as tipo_movimiento,
        COALESCE(b.can_movimiento, 0) as can_movimiento,
        COALESCE(b.imp_valorizado_dolares, 0) as imp_valorizado,
        a.fec_movstk as fecha_movimiento,
        COALESCE(cot_ranked.can_consuni, 0) as can_consuni
    FROM bronze.lg_movistk a
    INNER JOIN bronze.lg_movistkitem b ON a.cod_almacen = b.cod_almacen AND a.num_movstk = b.num_movstk
    LEFT JOIN bronze.lg_item item ON b.cod_item = item.cod_item
    LEFT JOIN bronze.es_ordpro op_info ON b.cod_ordpro = op_info.cod_ordpro
    LEFT JOIN (
        SELECT 
            cod_estpro, 
            cod_item, 
            can_consuni,
            ROW_NUMBER() OVER (PARTITION BY cod_estpro, cod_item ORDER BY can_consuni DESC) as rn
        FROM bronze.tg_cotizacion_estilospropios_comp
        WHERE (estilo_filtro IS NULL OR cod_estpro = estilo_filtro)
    ) cot_ranked ON op_info.cod_estpro = cot_ranked.cod_estpro 
                  AND b.cod_item = cot_ranked.cod_item 
                  AND cot_ranked.rn = 1
    WHERE b.cod_ordpro IS NOT NULL
      AND b.can_movimiento IS NOT NULL
      AND a.fec_movstk >= fecha_desde
      AND b.imp_valorizado_dolares IS NOT NULL
      AND op_info.cod_estpro IS NOT NULL
      AND (estilo_filtro IS NULL OR op_info.cod_estpro = estilo_filtro);
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '   ‚úÖ Movimientos clasificados: %', rows_processed;
    
    -- ‚úÖ PASO 2: Calcular agregados por OP (para los totales)
    RAISE NOTICE 'üìä Paso 2: Calculando totales por OP...';
    
    CREATE TEMP TABLE totales_por_op (
        op_codigo varchar(50) PRIMARY KEY,
        estilo_codigo varchar(50),
        costo_total_corregido_por_prenda decimal(18,4),
        cantidad_avios_por_op integer,
        costo_total_op_usd decimal(18,4),
        primera_entrada_avios timestamptz,
        ultima_salida_avios timestamptz,
        total_salidas_can decimal(18,2),
        total_salidas_usd decimal(18,4),
        total_devoluciones_can decimal(18,2),
        total_devoluciones_usd decimal(18,4),
        can_movimiento_neto_total decimal(18,2),
        imp_valorizado_neto_total decimal(18,4)
    );
    
    WITH movimientos_por_op_avio AS (
        SELECT 
            op_codigo,
            estilo_codigo,
            avio_codigo,
            SUM(CASE WHEN tipo_movimiento = 'SALIDA' THEN can_movimiento ELSE 0 END) as can_salidas,
            SUM(CASE WHEN tipo_movimiento = 'SALIDA' THEN imp_valorizado ELSE 0 END) as imp_salidas,
            SUM(CASE WHEN tipo_movimiento = 'DEVOLUCION' THEN can_movimiento ELSE 0 END) as can_devoluciones,
            SUM(CASE WHEN tipo_movimiento = 'DEVOLUCION' THEN imp_valorizado ELSE 0 END) as imp_devoluciones,
            MIN(CASE WHEN tipo_movimiento = 'ENTRADA' THEN fecha_movimiento END) as primera_entrada,
            MAX(CASE WHEN tipo_movimiento = 'SALIDA' THEN fecha_movimiento END) as ultima_salida,
            MAX(can_consuni) as can_consuni
        FROM movimientos_avios
        GROUP BY op_codigo, estilo_codigo, avio_codigo
    ),
    costos_por_op_avio AS (
        SELECT 
            op_codigo,
            estilo_codigo,
            avio_codigo,
            can_salidas,
            imp_salidas,
            can_devoluciones, 
            imp_devoluciones,
            (can_salidas - can_devoluciones) as can_neto,
            (imp_salidas - imp_devoluciones) as imp_neto,
            CASE 
                WHEN (can_salidas - can_devoluciones) > 0 
                THEN (imp_salidas - imp_devoluciones) / (can_salidas - can_devoluciones)
                ELSE 0 
            END as precio_unitario_real,
            can_consuni,
            CASE 
                WHEN (can_salidas - can_devoluciones) > 0 
                THEN ((imp_salidas - imp_devoluciones) / (can_salidas - can_devoluciones)) * can_consuni
                ELSE 0 
            END as costo_corregido_por_prenda_avio,
            primera_entrada,
            ultima_salida
        FROM movimientos_por_op_avio
    )
    INSERT INTO totales_por_op
    SELECT 
        op_codigo,
        MAX(estilo_codigo) as estilo_codigo,
        SUM(costo_corregido_por_prenda_avio) as costo_total_corregido_por_prenda,
        COUNT(DISTINCT avio_codigo) as cantidad_avios_por_op,
        SUM(imp_neto) as costo_total_op_usd,
        MIN(primera_entrada) as primera_entrada_avios,
        MAX(ultima_salida) as ultima_salida_avios,
        SUM(can_salidas) as total_salidas_can,
        SUM(imp_salidas) as total_salidas_usd,
        SUM(can_devoluciones) as total_devoluciones_can,
        SUM(imp_devoluciones) as total_devoluciones_usd,
        SUM(can_neto) as can_movimiento_neto_total,
        SUM(imp_neto) as imp_valorizado_neto_total
    FROM costos_por_op_avio
    GROUP BY op_codigo;
    
    GET DIAGNOSTICS rows_inserted = ROW_COUNT;
    RAISE NOTICE '   ‚úÖ Totales por OP calculados: %', rows_inserted;
    
    -- ‚úÖ PASO 3: Calcular detalle por OP + AVIO con descripci√≥n
    RAISE NOTICE 'üìä Paso 3: Calculando detalle por OP + AVIO con descripci√≥n...';
    
    CREATE TEMP TABLE detalle_por_op_avio (
        op_codigo varchar(50),
        estilo_codigo varchar(50),
        avio_codigo varchar(50),
        desc_avios varchar(500),  -- üÜï NUEVA COLUMNA
        can_consuni decimal(18,4),
        can_neto decimal(18,2),
        imp_neto decimal(18,4),
        precio_unitario_real decimal(18,4),
        costo_corregido_por_prenda_avio decimal(18,4)
    );
    
    WITH movimientos_por_op_avio AS (
        SELECT 
            op_codigo,
            estilo_codigo,
            avio_codigo,
            SUM(CASE WHEN tipo_movimiento = 'SALIDA' THEN can_movimiento ELSE 0 END) as can_salidas,
            SUM(CASE WHEN tipo_movimiento = 'SALIDA' THEN imp_valorizado ELSE 0 END) as imp_salidas,
            SUM(CASE WHEN tipo_movimiento = 'DEVOLUCION' THEN can_movimiento ELSE 0 END) as can_devoluciones,
            SUM(CASE WHEN tipo_movimiento = 'DEVOLUCION' THEN imp_valorizado ELSE 0 END) as imp_devoluciones,
            MAX(can_consuni) as can_consuni
        FROM movimientos_avios
        GROUP BY op_codigo, estilo_codigo, avio_codigo
    )
    INSERT INTO detalle_por_op_avio
    SELECT 
        m.op_codigo,
        m.estilo_codigo,
        UPPER(m.avio_codigo) as avio_codigo,
        COALESCE(item.des_item, 'SIN DESCRIPCI√ìN') as desc_avios,  -- üÜï JOIN para traer descripci√≥n
        m.can_consuni,
        (m.can_salidas - m.can_devoluciones) as can_neto,
        (m.imp_salidas - m.imp_devoluciones) as imp_neto,
        CASE 
            WHEN (m.can_salidas - m.can_devoluciones) > 0 
            THEN (m.imp_salidas - m.imp_devoluciones) / (m.can_salidas - m.can_devoluciones)
            ELSE 0 
        END as precio_unitario_real,
        CASE 
            WHEN (m.can_salidas - m.can_devoluciones) > 0 
            THEN ((m.imp_salidas - m.imp_devoluciones) / (m.can_salidas - m.can_devoluciones)) * m.can_consuni
            ELSE 0 
        END as costo_corregido_por_prenda_avio
    FROM movimientos_por_op_avio m
    LEFT JOIN bronze.lg_item item ON UPPER(m.avio_codigo) = UPPER(item.cod_item);  -- üÜï JOIN con lg_item
    
    GET DIAGNOSTICS rows_inserted = ROW_COUNT;
    RAISE NOTICE '   ‚úÖ Detalle OP+AVIO con descripci√≥n calculado: %', rows_inserted;
    
    -- ‚úÖ MODO CONSULTA (0)
    IF modo = 0 THEN
        RAISE NOTICE '';
        RAISE NOTICE 'üîç MODO CONSULTA - Resultado de c√°lculos SIN GUARDAR';
        RAISE NOTICE '================================================================================';
        
        RAISE NOTICE 'Top 10 registros por costo de av√≠o (muestra OP + AVIO + DESCRIPCI√ìN):';
        FOR rec IN 
            SELECT 
                d.op_codigo,
                d.estilo_codigo,
                d.avio_codigo,
                d.desc_avios,
                d.costo_corregido_por_prenda_avio::decimal(15,4),
                d.can_consuni::decimal(10,4),
                d.precio_unitario_real::decimal(10,4)
            FROM detalle_por_op_avio d
            INNER JOIN totales_por_op t ON d.op_codigo = t.op_codigo
            WHERE t.imp_valorizado_neto_total > 0
            ORDER BY d.costo_corregido_por_prenda_avio DESC
            LIMIT 10
        LOOP
            RAISE NOTICE '  OP:% | Est:% | Avio:% | Desc:% | $% /prenda', 
                rec.op_codigo, rec.estilo_codigo, rec.avio_codigo,
                SUBSTRING(rec.desc_avios, 1, 30), rec.costo_corregido_por_prenda_avio;
        END LOOP;
        
        SELECT 
            COUNT(*),
            AVG(d.costo_corregido_por_prenda_avio)
        INTO total_consulta, costo_promedio_consulta
        FROM detalle_por_op_avio d
        INNER JOIN totales_por_op t ON d.op_codigo = t.op_codigo
        WHERE t.imp_valorizado_neto_total > 0;
        
        RAISE NOTICE '';
        RAISE NOTICE 'üìä ESTAD√çSTICAS DE CONSULTA:';
        RAISE NOTICE '   üìÖ Fecha_corrida que se asignar√≠a: %', fecha_ejecucion;
        RAISE NOTICE '   ‚úÖ Registros (OP+AVIO) que se insertar√≠an: %', COALESCE(total_consulta, 0);
        RAISE NOTICE '   üí∞ Costo promedio por av√≠o: $%', COALESCE(costo_promedio_consulta, 0);
        RAISE NOTICE '   üéØ Movimientos procesados: %', rows_processed;
    END IF;
    
    -- ‚úÖ MODO GUARDAR (1)
    IF modo = 1 THEN
        RAISE NOTICE '';
        RAISE NOTICE 'üíæ MODO GUARDAR - Ejecutando inserci√≥n DETALLADA (OP + AVIO + DESCRIPCI√ìN)';
        
        SELECT COUNT(*)
        INTO registros_existentes
        FROM silver.costo_avios_v2 
        WHERE fecha_corrida::date = fecha_ejecucion::date;
        
        IF registros_existentes > 0 THEN
            RAISE NOTICE '   ‚ö†Ô∏è Ya existen % registros para hoy', registros_existentes;
            RAISE NOTICE '   üìä Agregando datos adicionales';
        END IF;
        
        -- üÜï INSERT con descripci√≥n de av√≠o
        INSERT INTO silver.costo_avios_v2 (
            op_codigo,
            estilo_codigo,
            costo_total_corregido_por_prenda,
            cantidad_avios_por_op,
            costo_total_op_usd,
            primera_entrada_avios,
            ultima_salida_avios,
            total_salidas_can,
            total_salidas_usd,
            total_devoluciones_can,
            total_devoluciones_usd,
            can_movimiento_neto_total,
            imp_valorizado_neto_total,
            avio_codigo,
            desc_avios,  -- üÜï NUEVA COLUMNA
            avio_can_consuni,
            avio_can_neto,
            avio_imp_neto,
            avio_precio_unitario,
            avio_costo_por_prenda,
            fecha_corrida
        )
        SELECT 
            t.op_codigo,
            t.estilo_codigo,
            t.costo_total_corregido_por_prenda,
            t.cantidad_avios_por_op,
            t.costo_total_op_usd,
            t.primera_entrada_avios,
            t.ultima_salida_avios,
            t.total_salidas_can,
            t.total_salidas_usd,
            t.total_devoluciones_can,
            t.total_devoluciones_usd,
            t.can_movimiento_neto_total,
            t.imp_valorizado_neto_total,
            d.avio_codigo,
            d.desc_avios,  -- üÜï NUEVA COLUMNA
            d.can_consuni,
            d.can_neto,
            d.imp_neto,
            d.precio_unitario_real,
            d.costo_corregido_por_prenda_avio,
            fecha_ejecucion
        FROM detalle_por_op_avio d
        INNER JOIN totales_por_op t ON d.op_codigo = t.op_codigo
        WHERE t.imp_valorizado_neto_total > 0;
        
        GET DIAGNOSTICS rows_inserted = ROW_COUNT;
        
        SELECT 
            COUNT(*),
            AVG(costo_total_corregido_por_prenda),
            COUNT(DISTINCT op_codigo),
            MIN(primera_entrada_avios),
            MAX(ultima_salida_avios)
        INTO total_registros, costo_promedio, ops_unicas, fecha_min, fecha_max
        FROM silver.costo_avios_v2;
        
        RAISE NOTICE '   ‚úÖ Registros insertados (OP+AVIO): %', rows_inserted;
        RAISE NOTICE '';
        RAISE NOTICE 'üìä ESTAD√çSTICAS FINALES:';
        RAISE NOTICE '   üìä Total registros COSTO_AVIOS_V2: %', total_registros;
        RAISE NOTICE '   üìä OPs √∫nicas: %', ops_unicas;
        RAISE NOTICE '   üí∞ Costo promedio por prenda: $%', costo_promedio;
        RAISE NOTICE '   üìÖ Rango movimientos: % a %', fecha_min, fecha_max;
        RAISE NOTICE '';
        RAISE NOTICE '‚úÖ COSTO_AVIOS_V2 POBLADO EXITOSAMENTE CON DETALLE Y DESCRIPCI√ìN EN COLUMNAS';
    END IF;
    
    -- Limpiar tablas temporales
    DROP TABLE IF EXISTS movimientos_avios;
    DROP TABLE IF EXISTS totales_por_op;
    DROP TABLE IF EXISTS detalle_por_op_avio;
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE '‚ùå ERROR en silver.populate_costo_avios_v2: %', error_message;
        
        DROP TABLE IF EXISTS movimientos_avios;
        DROP TABLE IF EXISTS totales_por_op;
        DROP TABLE IF EXISTS detalle_por_op_avio;
        
        RAISE EXCEPTION '%', error_message;
END;
$procedure$

-------------------------------------------------------------------------------------

13. =====================================================================================
NOMBRE: populate_costo_hilados_detalle_op
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.populate_costo_hilados_detalle_op(IN modo integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    rows_processed INTEGER := 0;
    rows_inserted INTEGER := 0;
    fecha_ejecucion TIMESTAMPTZ := NOW();
    ultima_fecha_corrida TIMESTAMPTZ;
    
    -- Parametros fijos
    fecha_desde DATE := '2020-01-01';
    fecha_hasta DATE;
    
BEGIN
    fecha_hasta := CURRENT_DATE;
    
    -- Obtener ultima fecha_corrida
    SELECT MAX(fecha_corrida) INTO ultima_fecha_corrida
    FROM silver.wip_time_costos_allocation;
    
    IF ultima_fecha_corrida IS NULL THEN
        RAISE EXCEPTION 'No hay datos en wip_time_costos_allocation';
    END IF;
    
    -- ========================================================================
    -- MODO CONSULTA (0)
    -- ========================================================================
    IF modo = 0 THEN
        RAISE NOTICE '=======================================================';
        RAISE NOTICE 'MODO CONSULTA - COSTO_HILADOS_DETALLE_OP';
        RAISE NOTICE '=======================================================';
        RAISE NOTICE 'Este SP crear√° tabla: silver.costo_hilados_detalle_op';
        RAISE NOTICE 'Con detalle por hilo por OP incluyendo:';
        RAISE NOTICE '  - Costos originales y finales (con factores)';
        RAISE NOTICE '  - Cantidades por OP y por prenda'; 
        RAISE NOTICE '  - Trazabilidad completa de precios';
        RAISE NOTICE '';
        RAISE NOTICE 'Para ejecutar: CALL silver.populate_costo_hilados_detalle_op(1);';
        RAISE NOTICE '=======================================================';
        RETURN;
    END IF;
    
    -- ========================================================================
    -- CREAR TABLA SI NO EXISTE
    -- ========================================================================
    CREATE TABLE IF NOT EXISTS silver.costo_hilados_detalle_op (
        op_codigo VARCHAR(50),
        estilo_codigo VARCHAR(50),
        cod_hiltel VARCHAR(50),
        cod_hilado VARCHAR(50),
        descripcion_hilo TEXT,
        tipo_hilo VARCHAR(10),
        
        -- CANTIDADES
        kg_requeridos DECIMAL(18,4),
        prendas_requeridas DECIMAL(18,2),
        kg_por_prenda DECIMAL(18,6),
        
        -- COSTOS ORIGINALES (sin factor)
        usd_por_kg_original DECIMAL(18,4),
        costo_total_original DECIMAL(18,4),
        costo_por_prenda_original DECIMAL(18,4),
        
        -- COSTOS FINALES (con factor)
        factor_aplicado DECIMAL(18,6),
        usd_por_kg_final DECIMAL(18,4),
        costo_total_final DECIMAL(18,4),
        costo_por_prenda_final DECIMAL(18,4),
        
        -- METADATOS
        fecha_despacho VARCHAR(20),
        dias_diferencia_precio INTEGER,
        fecha_precio TIMESTAMPTZ,
        fecha_corrida TIMESTAMPTZ,
        
        PRIMARY KEY (op_codigo, cod_hiltel, tipo_hilo, fecha_corrida)
    );
    
    RAISE NOTICE 'Iniciando c√°lculo detallado de hilados...';
    
    -- ========================================================================
    -- PASO 1: RECREAR TABLAS TEMPORALES BASE
    -- ========================================================================
    
    -- OPs base
    DROP TABLE IF EXISTS ops_base;
    CREATE TEMP TABLE ops_base AS
    SELECT DISTINCT 
        op.cod_ordpro as op_codigo,
        op.cod_estpro as estilo_codigo,
        COALESCE(op.num_prenreq, 0) as prendas_requeridas,
        op.fec_creacion
    FROM bronze.es_ordpro op
    INNER JOIN (
        SELECT DISTINCT wip.pr_id
        FROM silver.wip_time_costos_allocation wip
        WHERE wip.pr_id IS NOT NULL 
          AND wip.month_ IS NOT NULL
          AND wip.fecha_corrida = ultima_fecha_corrida
          AND wip.month_::DATE BETWEEN fecha_desde AND fecha_hasta
    ) w ON op.cod_ordpro = w.pr_id
    WHERE op.num_prenreq > 0;
    
    -- Fechas WIP
    DROP TABLE IF EXISTS fechas_wip;
    CREATE TEMP TABLE fechas_wip AS
    SELECT 
        wip.pr_id as op_codigo,
        MIN(wip.month_) as fecha_despacho_min,
        CASE EXTRACT(MONTH FROM MIN(wip.month_))::INTEGER
            WHEN 1 THEN 'Ene' WHEN 2 THEN 'Feb' WHEN 3 THEN 'Mar' WHEN 4 THEN 'Abr'
            WHEN 5 THEN 'May' WHEN 6 THEN 'Jun' WHEN 7 THEN 'Jul' WHEN 8 THEN 'Ago'
            WHEN 9 THEN 'Sep' WHEN 10 THEN 'Oct' WHEN 11 THEN 'Nov' WHEN 12 THEN 'Dic'
        END || '-' || RIGHT(EXTRACT(YEAR FROM MIN(wip.month_))::TEXT, 2) as fecha_despacho_formato
    FROM silver.wip_time_costos_allocation wip
    INNER JOIN ops_base ob ON wip.pr_id = ob.op_codigo
    WHERE wip.fecha_corrida = ultima_fecha_corrida
    GROUP BY wip.pr_id;
    
    -- ========================================================================
    -- PASO 2: CALCULAR DETALLE POR HILO
    -- ========================================================================
    
    DROP TABLE IF EXISTS detalle_hilados;
    CREATE TEMP TABLE detalle_hilados AS
    WITH requerimientos_hilados AS (
        -- CRUDO
        SELECT 
            req.cod_ordpro,
            'CRUDO' as tipo_hilo,
            req.cod_hiltel,
            equiv.cod_hilado,
            equiv.descripcion,
            req.can_constex as kg_requeridos
        FROM bronze.es_ordproreq_hilcru_detalle req
        INNER JOIN bronze.hi_hilados equiv ON req.cod_hiltel = equiv.cod_hiltel_referencia
        INNER JOIN ops_base ob ON req.cod_ordpro = ob.op_codigo
        WHERE req.can_constex > 0
        
        UNION ALL
        
        -- TENIDO
        SELECT 
            req.cod_ordpro,
            'TENIDO' as tipo_hilo,
            req.cod_hiltel,
            equiv.cod_hilado,
            equiv.descripcion,
            req.can_constex as kg_requeridos
        FROM bronze.es_ordproreq_hilten_detalle req
        INNER JOIN bronze.hi_hilados equiv ON req.cod_hiltel = equiv.cod_hiltel_referencia
        INNER JOIN ops_base ob ON req.cod_ordpro = ob.op_codigo
        WHERE req.can_constex > 0
    ),
    
    precios_hilados AS (
        SELECT 
            rh.cod_ordpro,
            rh.tipo_hilo,
            rh.cod_hiltel,
            rh.cod_hilado,
            rh.descripcion,
            rh.kg_requeridos,
            mc.usd_por_kg,
            mc.dias_diferencia,
            mc.fecha_precio
        FROM requerimientos_hilados rh
        CROSS JOIN LATERAL (
            SELECT 
                CASE WHEN costos.num_kilos_neto > 0 
                     THEN costos.imp_valorizado_dolares / costos.num_kilos_neto 
                     ELSE 0 END as usd_por_kg,
                ABS((costos.fec_movstk::DATE - op.fec_creacion::DATE)::INTEGER) as dias_diferencia,
                costos.fec_movstk as fecha_precio
            FROM bronze.hi_movistk_ordpro_item costos
            INNER JOIN bronze.es_ordpro op ON rh.cod_ordpro = op.cod_ordpro
            WHERE costos.cod_hilado = rh.cod_hilado
              AND costos.cod_almacen = '20'
              AND costos.imp_valorizado_dolares > 0
              AND costos.num_kilos_neto > 0
              AND costos.fec_movstk BETWEEN 
                  op.fec_creacion - INTERVAL '120 days' AND 
                  op.fec_creacion + INTERVAL '120 days'
            ORDER BY 
                ABS((costos.fec_movstk::DATE - op.fec_creacion::DATE)::INTEGER),
                CASE WHEN costos.num_kilos_neto > 0 
                     THEN costos.imp_valorizado_dolares / costos.num_kilos_neto 
                     ELSE 0 END DESC
            LIMIT 1
        ) mc
        WHERE mc.usd_por_kg > 0
    )
    
    SELECT 
        ph.cod_ordpro,
        ob.estilo_codigo,
        ph.cod_hiltel,
        ph.cod_hilado,
        ph.descripcion,
        ph.tipo_hilo,
        ph.kg_requeridos,
        ob.prendas_requeridas,
        CASE WHEN ob.prendas_requeridas > 0 
             THEN ph.kg_requeridos / ob.prendas_requeridas 
             ELSE 0 END as kg_por_prenda,
        ph.usd_por_kg,
        ph.kg_requeridos * ph.usd_por_kg as costo_total_original,
        CASE WHEN ob.prendas_requeridas > 0 
             THEN (ph.kg_requeridos * ph.usd_por_kg) / ob.prendas_requeridas 
             ELSE 0 END as costo_por_prenda_original,
        fw.fecha_despacho_formato,
        ph.dias_diferencia,
        ph.fecha_precio
    FROM precios_hilados ph
    INNER JOIN ops_base ob ON ph.cod_ordpro = ob.op_codigo
    LEFT JOIN fechas_wip fw ON ph.cod_ordpro = fw.op_codigo;
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì Detalle base calculado: % registros', rows_processed;
    
    -- ========================================================================
    -- PASO 3: APLICAR FACTORES DE AJUSTE
    -- ========================================================================
    
    -- Cargar targets mensuales
    DROP TABLE IF EXISTS targets_hilados;
    CREATE TEMP TABLE targets_hilados AS
    SELECT 
        CASE ct.mes
            WHEN 1 THEN 'Ene' WHEN 2 THEN 'Feb' WHEN 3 THEN 'Mar' WHEN 4 THEN 'Abr'
            WHEN 5 THEN 'May' WHEN 6 THEN 'Jun' WHEN 7 THEN 'Jul' WHEN 8 THEN 'Ago'
            WHEN 9 THEN 'Sep' WHEN 10 THEN 'Oct' WHEN 11 THEN 'Nov' WHEN 12 THEN 'Dic'
        END || '-' || RIGHT(ct.a√±o::TEXT, 2) as mes_a√±o,
        ct.materia_prima as target_monto
    FROM silver.costos_mp_ct_avios ct
    WHERE ct.materia_prima > 0
      AND ct.a√±o BETWEEN EXTRACT(YEAR FROM fecha_desde) AND EXTRACT(YEAR FROM fecha_hasta);
    
    -- Aplicar factores
    UPDATE detalle_hilados dh
    SET 
        costo_total_original = costo_total_original * COALESCE(
            (SELECT th.target_monto / NULLIF(
                (SELECT SUM(dh2.costo_total_original) 
                 FROM detalle_hilados dh2 
                 WHERE dh2.fecha_despacho_formato = dh.fecha_despacho_formato), 0)
             FROM targets_hilados th 
             WHERE th.mes_a√±o = dh.fecha_despacho_formato), 1.0),
        costo_por_prenda_original = costo_por_prenda_original * COALESCE(
            (SELECT th.target_monto / NULLIF(
                (SELECT SUM(dh2.costo_total_original) 
                 FROM detalle_hilados dh2 
                 WHERE dh2.fecha_despacho_formato = dh.fecha_despacho_formato), 0)
             FROM targets_hilados th 
             WHERE th.mes_a√±o = dh.fecha_despacho_formato), 1.0);
    
    -- ========================================================================
    -- PASO 4: INSERT FINAL
    -- ========================================================================
    
    INSERT INTO silver.costo_hilados_detalle_op (
        op_codigo, estilo_codigo, cod_hiltel, cod_hilado, descripcion_hilo, tipo_hilo,
        kg_requeridos, prendas_requeridas, kg_por_prenda,
        usd_por_kg_original, costo_total_original, costo_por_prenda_original,
        factor_aplicado, usd_por_kg_final, costo_total_final, costo_por_prenda_final,
        fecha_despacho, dias_diferencia_precio, fecha_precio, fecha_corrida
    )
    SELECT 
        dh.cod_ordpro,
        dh.estilo_codigo,
        dh.cod_hiltel,
        dh.cod_hilado,
        dh.descripcion,
        dh.tipo_hilo,
        dh.kg_requeridos,
        dh.prendas_requeridas,
        dh.kg_por_prenda,
        dh.usd_por_kg,
        dh.kg_requeridos * dh.usd_por_kg,
        CASE WHEN dh.prendas_requeridas > 0 
             THEN (dh.kg_requeridos * dh.usd_por_kg) / dh.prendas_requeridas 
             ELSE 0 END,
        COALESCE((SELECT th.target_monto / NULLIF((SELECT SUM(dh2.costo_total_original) FROM detalle_hilados dh2 WHERE dh2.fecha_despacho_formato = dh.fecha_despacho_formato), 0) FROM targets_hilados th WHERE th.mes_a√±o = dh.fecha_despacho_formato), 1.0),
        dh.usd_por_kg * COALESCE((SELECT th.target_monto / NULLIF((SELECT SUM(dh2.costo_total_original) FROM detalle_hilados dh2 WHERE dh2.fecha_despacho_formato = dh.fecha_despacho_formato), 0) FROM targets_hilados th WHERE th.mes_a√±o = dh.fecha_despacho_formato), 1.0),
        dh.costo_total_original,
        dh.costo_por_prenda_original,
        dh.fecha_despacho_formato,
        dh.dias_diferencia,
        dh.fecha_precio,
        fecha_ejecucion
    FROM detalle_hilados dh;
    
    GET DIAGNOSTICS rows_inserted = ROW_COUNT;
    
    RAISE NOTICE '';
    RAISE NOTICE '=======================================================';
    RAISE NOTICE 'PROCESO COMPLETADO - DETALLE HILADOS';
    RAISE NOTICE '=======================================================';
    RAISE NOTICE 'Registros insertados: %', rows_inserted;
    RAISE NOTICE 'Tabla: silver.costo_hilados_detalle_op';
    RAISE NOTICE '=======================================================';

EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE 'ERROR: %', error_message;
        RAISE EXCEPTION '%', error_message;
        
END;
$procedure$

-------------------------------------------------------------------------------------

14. =====================================================================================
NOMBRE: populate_costo_materia_prima
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0, IN debug integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.populate_costo_materia_prima(IN modo integer DEFAULT 0, IN debug integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    rows_processed INTEGER := 0;
    rows_inserted INTEGER := 0;
    fecha_ejecucion TIMESTAMPTZ := NOW();
    ultima_fecha_corrida TIMESTAMPTZ;  -- ‚úÖ AGREGADO: Anti-inflacion
    
    -- Parametros fijos basados en WIP
    fecha_desde DATE := '2020-01-01';
    fecha_hasta DATE;
    
    -- Variables para loops
    mes_a√±o VARCHAR(20);
    target_hilados DECIMAL(18,4);
    total_inductor DECIMAL(18,4);
    factor_h DECIMAL(18,6);
    a√±o_tela INTEGER;
    target_tela DECIMAL(18,4);
    total_costo_tela DECIMAL(18,4);
    factor_t DECIMAL(18,6);
    
    -- Variables para estadisticas
    registros_wip INTEGER;
    total_registros INTEGER;
    costo_promedio DECIMAL(18,4);
    con_hilados INTEGER;
    con_tela INTEGER;
    
BEGIN
    fecha_hasta := CURRENT_DATE;
    
    -- ========================================================================
    -- VALIDACIONES PREREQUISITOS
    -- ========================================================================
    
    -- ‚úÖ CORREGIDO: Tabla correcta wip_time_costos_allocation
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'silver' 
        AND table_name = 'wip_time_costos_allocation'
    ) THEN
        RAISE NOTICE 'ERROR: Tabla wip_time_costos_allocation no existe';
        RAISE NOTICE '   SOLUCION: Ejecutar primero el proceso de carga de wip_time_costos_allocation';
        RAISE EXCEPTION 'Prerequisito faltante: tabla wip_time_costos_allocation';
    END IF;
    
    -- ‚úÖ AGREGADO: Obtener ultima fecha_corrida para anti-inflacion
    SELECT MAX(fecha_corrida) INTO ultima_fecha_corrida
    FROM silver.wip_time_costos_allocation;
    
    IF ultima_fecha_corrida IS NULL THEN
        RAISE NOTICE 'ERROR: Tabla wip_time_costos_allocation esta vacia';
        RAISE EXCEPTION 'Tabla wip_time_costos_allocation sin datos';
    END IF;
    
    -- Verificar registros disponibles
    SELECT COUNT(*) INTO registros_wip 
    FROM silver.wip_time_costos_allocation
    WHERE fecha_corrida = ultima_fecha_corrida;
    
    IF registros_wip = 0 THEN
        RAISE NOTICE 'ERROR: No hay registros para fecha_corrida: %', ultima_fecha_corrida;
        RAISE EXCEPTION 'Sin datos para fecha_corrida especifica';
    END IF;
    
    -- ========================================================================
    -- MODO CONSULTA (0)
    -- ========================================================================
    IF modo = 0 THEN
        RAISE NOTICE '=======================================================';
        RAISE NOTICE 'MODO CONSULTA - COSTO_MATERIA_PRIMA';
        RAISE NOTICE '=======================================================';
        RAISE NOTICE 'Rango procesamiento: % a %', fecha_desde, fecha_hasta;
        RAISE NOTICE 'ULTIMA fecha_corrida WIP: %', ultima_fecha_corrida;
        RAISE NOTICE 'Registros WIP (ultima corrida): %', registros_wip;
        RAISE NOTICE 'LOGICA HISTORICA: Solo INSERT (acumula por fecha_corrida)';
        RAISE NOTICE '';
        RAISE NOTICE 'Se calcularan:';
        RAISE NOTICE '  - Costos reales de hilados (crudo + tenido)';
        RAISE NOTICE '  - Costos reales de tela comprada';
        RAISE NOTICE '  - Factores de ajuste dinamicos por mes/a√±o';
        RAISE NOTICE '';
        RAISE NOTICE 'Para ejecutar: CALL silver.populate_costo_materia_prima(1);';
        RAISE NOTICE '=======================================================';
        RETURN;
    END IF;
    
    -- ========================================================================
    -- MODO GUARDAR (1) - INICIO
    -- ========================================================================
    RAISE NOTICE '';
    RAISE NOTICE '=======================================================';
    RAISE NOTICE 'INICIANDO CALCULO COSTO_MATERIA_PRIMA';
    RAISE NOTICE '=======================================================';
    RAISE NOTICE 'Rango: % a %', fecha_desde, fecha_hasta;
    RAISE NOTICE 'Timestamp ejecucion: %', fecha_ejecucion;
    RAISE NOTICE 'USANDO fecha_corrida WIP: %', ultima_fecha_corrida;
    RAISE NOTICE 'Registros WIP: %', registros_wip;
    RAISE NOTICE '';
    
    -- ========================================================================
    -- PASO 1: OPs BASE CON ACTIVIDAD WIP (CON ANTI-INFLACION)
    -- ========================================================================
    RAISE NOTICE 'PASO 1: Extrayendo OPs con actividad WIP...';
    
    DROP TABLE IF EXISTS ops_base;
    CREATE TEMP TABLE ops_base (
        op_codigo VARCHAR(50) PRIMARY KEY,
        estilo_codigo VARCHAR(50),
        cliente_codigo VARCHAR(50),
        prendas_requeridas DECIMAL(18,2),
        fecha_creacion TIMESTAMPTZ
    );
    
    -- ‚úÖ CORREGIDO: Usa wip_time_costos_allocation + fecha_corrida
    INSERT INTO ops_base
    SELECT DISTINCT 
        op.cod_ordpro,
        op.cod_estpro,
        op.cod_cliente,
        COALESCE(op.num_prenreq, 0),
        op.fec_creacion
    FROM bronze.es_ordpro op
    INNER JOIN (
        SELECT DISTINCT wip.pr_id
        FROM silver.wip_time_costos_allocation wip
        WHERE wip.pr_id IS NOT NULL 
          AND wip.month_ IS NOT NULL
          AND wip.fecha_corrida = ultima_fecha_corrida  -- ‚úÖ ANTI-INFLACION
          AND wip.month_::DATE BETWEEN fecha_desde AND fecha_hasta
    ) w ON op.cod_ordpro = w.pr_id
    WHERE op.num_prenreq > 0
      AND op.fec_creacion >= '2020-01-01';
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì OPs base extraidas: %', rows_processed;
    
    -- ========================================================================
    -- PASO 2: FECHAS DESPACHO DESDE WIP (CON ANTI-INFLACION)
    -- ========================================================================
    RAISE NOTICE 'PASO 2: Calculando fechas despacho WIP...';
    
    DROP TABLE IF EXISTS fechas_wip;
    CREATE TEMP TABLE fechas_wip (
        op_codigo VARCHAR(50) PRIMARY KEY,
        fecha_despacho_min TIMESTAMPTZ,
        fecha_despacho_formato VARCHAR(20)
    );
    
    -- ‚úÖ CORREGIDO: Usa fecha_corrida
    INSERT INTO fechas_wip
    SELECT 
        wip.pr_id,
        MIN(wip.month_),
        CASE EXTRACT(MONTH FROM MIN(wip.month_))::INTEGER
            WHEN 1 THEN 'Ene' WHEN 2 THEN 'Feb' WHEN 3 THEN 'Mar' WHEN 4 THEN 'Abr'
            WHEN 5 THEN 'May' WHEN 6 THEN 'Jun' WHEN 7 THEN 'Jul' WHEN 8 THEN 'Ago'
            WHEN 9 THEN 'Sep' WHEN 10 THEN 'Oct' WHEN 11 THEN 'Nov' WHEN 12 THEN 'Dic'
        END || '-' || RIGHT(EXTRACT(YEAR FROM MIN(wip.month_))::TEXT, 2)
    FROM silver.wip_time_costos_allocation wip
    INNER JOIN ops_base ob ON wip.pr_id = ob.op_codigo
    WHERE wip.month_ IS NOT NULL
      AND wip.fecha_corrida = ultima_fecha_corrida  -- ‚úÖ ANTI-INFLACION
      AND wip.month_::DATE BETWEEN fecha_desde AND fecha_hasta
    GROUP BY wip.pr_id;
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì Fechas WIP calculadas: %', rows_processed;
    
    -- ========================================================================
    -- PASO 3: COSTOS HILADOS (CRUDO + TENIDO)
    -- ========================================================================
    RAISE NOTICE 'PASO 3: Calculando costos de hilados...';
    
    DROP TABLE IF EXISTS costos_hilados;
    CREATE TEMP TABLE costos_hilados (
        op_codigo VARCHAR(50) PRIMARY KEY,
        kg_hilados_total DECIMAL(18,2),
        inductor_hilados_original DECIMAL(18,4),
        usd_por_kg_promedio DECIMAL(18,4),
        dias_diferencia_promedio DECIMAL(18,2),
        crudo_kg DECIMAL(18,2),
        crudo_costo_usd DECIMAL(18,4),
        tenido_kg DECIMAL(18,2),
        tenido_costo_usd DECIMAL(18,4),
        hilados_diferentes INTEGER
    );
    
    WITH requerimientos_hilados AS (
        -- CRUDO
        SELECT 
            req.cod_ordpro,
            'CRUDO' as tipo_hilo,
            req.cod_hiltel,
            equiv.cod_hilado,
            req.can_constex as kg_requeridos
        FROM bronze.es_ordproreq_hilcru_detalle req
        INNER JOIN bronze.hi_hilados equiv 
            ON req.cod_hiltel = equiv.cod_hiltel_referencia
        INNER JOIN ops_base ob ON req.cod_ordpro = ob.op_codigo
        WHERE req.can_constex > 0
        
        UNION ALL
        
        -- TENIDO
        SELECT 
            req.cod_ordpro,
            'TENIDO' as tipo_hilo,
            req.cod_hiltel,
            equiv.cod_hilado,
            req.can_constex as kg_requeridos
        FROM bronze.es_ordproreq_hilten_detalle req
        INNER JOIN bronze.hi_hilados equiv 
            ON req.cod_hiltel = equiv.cod_hiltel_referencia
        INNER JOIN ops_base ob ON req.cod_ordpro = ob.op_codigo
        WHERE req.can_constex > 0
    ),
    mejor_costo_por_hilado AS (
        SELECT 
            rh.cod_ordpro,
            rh.tipo_hilo,
            rh.cod_hiltel,
            rh.cod_hilado,
            rh.kg_requeridos,
            mc.usd_por_kg,
            mc.dias_diferencia
        FROM requerimientos_hilados rh
        CROSS JOIN LATERAL (
            SELECT 
                CASE 
                    WHEN costos.num_kilos_neto > 0 
                    THEN costos.imp_valorizado_dolares / costos.num_kilos_neto 
                    ELSE 0 
                END as usd_por_kg,
				ABS((costos.fec_movstk::DATE - op.fec_creacion::DATE)::INTEGER) as dias_diferencia
            FROM bronze.hi_movistk_ordpro_item costos
            INNER JOIN bronze.es_ordpro op ON rh.cod_ordpro = op.cod_ordpro
            WHERE costos.cod_hilado = rh.cod_hilado
              AND costos.cod_almacen = '20'
              AND costos.imp_valorizado_dolares > 0
              AND costos.num_kilos_neto > 0
              AND costos.fec_movstk BETWEEN 
                  op.fec_creacion - INTERVAL '120 days' AND 
                  op.fec_creacion + INTERVAL '120 days'
            ORDER BY 
                 ABS((costos.fec_movstk::DATE - op.fec_creacion::DATE)::INTEGER),
                CASE 
                    WHEN costos.num_kilos_neto > 0 
                    THEN costos.imp_valorizado_dolares / costos.num_kilos_neto 
                    ELSE 0 
                END DESC
            LIMIT 1
        ) mc
        WHERE mc.usd_por_kg > 0
    )
    INSERT INTO costos_hilados
    SELECT 
        cod_ordpro,
        SUM(kg_requeridos),
        SUM(kg_requeridos * usd_por_kg),
        CASE WHEN COUNT(*) > 0 THEN AVG(usd_por_kg) ELSE 0 END,
        CASE WHEN COUNT(*) > 0 THEN AVG(dias_diferencia) ELSE 0 END,
        SUM(CASE WHEN tipo_hilo = 'CRUDO' THEN kg_requeridos ELSE 0 END),
        SUM(CASE WHEN tipo_hilo = 'CRUDO' THEN kg_requeridos * usd_por_kg ELSE 0 END),
        SUM(CASE WHEN tipo_hilo = 'TENIDO' THEN kg_requeridos ELSE 0 END),
        SUM(CASE WHEN tipo_hilo = 'TENIDO' THEN kg_requeridos * usd_por_kg ELSE 0 END),
        COUNT(DISTINCT cod_hiltel)
    FROM mejor_costo_por_hilado
    GROUP BY cod_ordpro;
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì Costos hilados calculados: %', rows_processed;
  
    -- ========================================================================
    -- PASO 4: COSTOS TELA COMPRADA
    -- ========================================================================
    RAISE NOTICE 'PASO 4: Calculando costos de tela...';
    
    DROP TABLE IF EXISTS costos_tela;
    CREATE TEMP TABLE costos_tela (
        op_codigo VARCHAR(50) PRIMARY KEY,
        kg_tela_comprada_total DECIMAL(18,2),
        rollos_tela_comprada_total DECIMAL(18,2),
        costo_tela_comprada_total DECIMAL(18,4),
        usd_por_unidad_tela_real DECIMAL(18,4),
        a√±o_compra_tela INTEGER,
        fecha_compra_tela_min TIMESTAMPTZ
    );
    
    INSERT INTO costos_tela
    SELECT 
        d.cod_ordpro,
        SUM(b.kgs_movimiento),
        SUM(b.numero_rollos),
        SUM(b.imp_valorizado_dolares_total),
        CASE 
            WHEN SUM(b.kgs_movimiento) > 0 
            THEN SUM(b.imp_valorizado_dolares_total) / SUM(b.kgs_movimiento)
            WHEN SUM(b.numero_rollos) > 0 
            THEN SUM(b.imp_valorizado_dolares_total) / SUM(b.numero_rollos)
            ELSE 0 
        END,
        EXTRACT(YEAR FROM MIN(a.fec_movstk))::INTEGER,
        MIN(a.fec_movstk)
    FROM bronze.tx_ordtra_items_requerimientos d
    INNER JOIN bronze.tx_movistk_tela_tenida b 
        ON d.cod_ordtra = b.cod_ordtra
        AND d.cod_tela = b.cod_tela
        AND d.cod_comb = b.cod_comb
        AND d.cod_color = b.cod_color
        AND d.cod_talla = b.cod_talla
    INNER JOIN bronze.tx_movistk a 
        ON b.cod_almacen = a.cod_almacen 
        AND b.num_movstk = a.num_movstk
    INNER JOIN ops_base ob ON d.cod_ordpro = ob.op_codigo
    WHERE UPPER(d.cod_tipordtra) = 'TI'  -- ‚úÖ Case insensitive
      AND a.cod_almacen = '39' 
      AND a.cod_tipmov = 'A01'
      AND b.imp_valorizado_dolares_total > 0
      AND d.can_programada_tex > 0
      AND a.fec_movstk::DATE BETWEEN fecha_desde AND fecha_hasta
      AND (b.kgs_movimiento > 0 OR b.numero_rollos > 0)
    GROUP BY d.cod_ordpro
    HAVING SUM(b.imp_valorizado_dolares_total) > 0;
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì Costos tela calculados: %', rows_processed;
    
    -- ========================================================================
    -- PASO 5: CARGAR TARGETS DESDE costos_mp_ct_avios
    -- ========================================================================
    RAISE NOTICE 'PASO 5: Cargando targets de ajuste...';
    
    -- Targets hilados MENSUALES
    DROP TABLE IF EXISTS targets_hilados;
    CREATE TEMP TABLE targets_hilados (
        mes_a√±o VARCHAR(20) PRIMARY KEY,
        target_monto DECIMAL(18,4)
    );
    
    INSERT INTO targets_hilados
    SELECT 
        CASE ct.mes
            WHEN 1 THEN 'Ene' WHEN 2 THEN 'Feb' WHEN 3 THEN 'Mar' WHEN 4 THEN 'Abr'
            WHEN 5 THEN 'May' WHEN 6 THEN 'Jun' WHEN 7 THEN 'Jul' WHEN 8 THEN 'Ago'
            WHEN 9 THEN 'Sep' WHEN 10 THEN 'Oct' WHEN 11 THEN 'Nov' WHEN 12 THEN 'Dic'
        END || '-' || RIGHT(ct.a√±o::TEXT, 2),
        ct.materia_prima
    FROM silver.costos_mp_ct_avios ct
    WHERE ct.materia_prima > 0
      AND ct.a√±o BETWEEN EXTRACT(YEAR FROM fecha_desde) AND EXTRACT(YEAR FROM fecha_hasta)
    ORDER BY ct.a√±o, ct.mes;
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì Targets hilados (mensuales): %', rows_processed;
    
    -- Targets tela ANUALES
    DROP TABLE IF EXISTS targets_tela;
    CREATE TEMP TABLE targets_tela (
        a√±o INTEGER PRIMARY KEY,
        target_monto DECIMAL(18,4)
    );
    
    INSERT INTO targets_tela
    SELECT 
        ct.a√±o,
        SUM(ct.tela_comprada)
    FROM silver.costos_mp_ct_avios ct
    WHERE ct.tela_comprada > 0
      AND ct.a√±o BETWEEN EXTRACT(YEAR FROM fecha_desde) AND EXTRACT(YEAR FROM fecha_hasta)
    GROUP BY ct.a√±o
    ORDER BY ct.a√±o;
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì Targets tela (anuales): %', rows_processed;
    
    -- ========================================================================
    -- PASO 6: CONSOLIDAR Y CALCULAR FACTORES
    -- ========================================================================
    RAISE NOTICE 'PASO 6: Consolidando datos y calculando factores...';
    
    DROP TABLE IF EXISTS consolidado_final;
    CREATE TEMP TABLE consolidado_final (
        op_codigo VARCHAR(50) PRIMARY KEY,
        estilo_codigo VARCHAR(50),
        fecha_despacho VARCHAR(20),
        fecha_despacho_original TIMESTAMPTZ,
        kg_hilados_total DECIMAL(18,2),
        inductor_hilados_original DECIMAL(18,4),
        costo_hilados_final DECIMAL(18,4),
        usd_por_kg_promedio DECIMAL(18,4),
        dias_diferencia_promedio DECIMAL(18,2),
        crudo_kg DECIMAL(18,2),
        crudo_costo_usd DECIMAL(18,4),
        tenido_kg DECIMAL(18,2),
        tenido_costo_usd DECIMAL(18,4),
        hilados_diferentes INTEGER,
        kg_tela_comprada_total DECIMAL(18,2),
        rollos_tela_comprada_total DECIMAL(18,2),
        costo_tela_comprada_total DECIMAL(18,4),
        costo_tela_final DECIMAL(18,4),
        usd_por_unidad_tela_real DECIMAL(18,4),
        a√±o_compra_tela INTEGER,
        fecha_compra_tela_min TIMESTAMPTZ,
        costo_total_mp_final DECIMAL(18,4),
        factor_hilados DECIMAL(18,6),
        factor_tela DECIMAL(18,6),
        tiene_hilados BOOLEAN,
        tiene_tela BOOLEAN,
        tiene_mp BOOLEAN
    );
    
    -- Consolidar datos base
    INSERT INTO consolidado_final
    SELECT 
        ob.op_codigo,
        ob.estilo_codigo,
        COALESCE(fw.fecha_despacho_formato, 'Sin-Fecha'),
        fw.fecha_despacho_min,
        COALESCE(ch.kg_hilados_total, 0),
        COALESCE(ch.inductor_hilados_original, 0),
        0,
        COALESCE(ch.usd_por_kg_promedio, 0),
        COALESCE(ch.dias_diferencia_promedio, 0),
        COALESCE(ch.crudo_kg, 0),
        COALESCE(ch.crudo_costo_usd, 0),
        COALESCE(ch.tenido_kg, 0),
        COALESCE(ch.tenido_costo_usd, 0),
        COALESCE(ch.hilados_diferentes, 0),
        COALESCE(ct.kg_tela_comprada_total, 0),
        COALESCE(ct.rollos_tela_comprada_total, 0),
        COALESCE(ct.costo_tela_comprada_total, 0),
        0,
        COALESCE(ct.usd_por_unidad_tela_real, 0),
        ct.a√±o_compra_tela,
        ct.fecha_compra_tela_min,
        0,
        0,
        0,
        CASE WHEN ch.inductor_hilados_original > 0 THEN TRUE ELSE FALSE END,
        CASE WHEN ct.costo_tela_comprada_total > 0 THEN TRUE ELSE FALSE END,
        CASE WHEN ch.inductor_hilados_original > 0 OR ct.costo_tela_comprada_total > 0 THEN TRUE ELSE FALSE END
    FROM ops_base ob
    LEFT JOIN fechas_wip fw ON ob.op_codigo = fw.op_codigo
    LEFT JOIN costos_hilados ch ON ob.op_codigo = ch.op_codigo
    LEFT JOIN costos_tela ct ON ob.op_codigo = ct.op_codigo;
    
    -- Calcular factores hilados por mes
    FOR mes_a√±o, target_hilados IN
        SELECT th.mes_a√±o, th.target_monto FROM targets_hilados th
    LOOP
        SELECT SUM(inductor_hilados_original) INTO total_inductor
        FROM consolidado_final 
        WHERE fecha_despacho = mes_a√±o AND inductor_hilados_original > 0;
        
        IF total_inductor > 0 THEN
            factor_h := target_hilados / total_inductor;
            
            UPDATE consolidado_final
            SET factor_hilados = factor_h,
                costo_hilados_final = inductor_hilados_original * factor_h
            WHERE fecha_despacho = mes_a√±o;
        END IF;
    END LOOP;
    
    -- Calcular factores tela por a√±o
    FOR a√±o_tela, target_tela IN
        SELECT tt.a√±o, tt.target_monto FROM targets_tela tt
    LOOP
        SELECT SUM(costo_tela_comprada_total) INTO total_costo_tela
        FROM consolidado_final 
        WHERE a√±o_compra_tela = a√±o_tela AND costo_tela_comprada_total > 0;
        
        IF total_costo_tela > 0 THEN
            factor_t := target_tela / total_costo_tela;
            
            UPDATE consolidado_final
            SET factor_tela = factor_t,
                costo_tela_final = costo_tela_comprada_total * factor_t
            WHERE a√±o_compra_tela = a√±o_tela;
        END IF;
    END LOOP;
    
    -- Calcular costo total final
    UPDATE consolidado_final
    SET costo_total_mp_final = costo_hilados_final + costo_tela_final;
    
    RAISE NOTICE '  ‚úì Factores aplicados y costos finales calculados';
    
    -- ========================================================================
    -- PASO 7: INSERT EN TABLA FINAL (LOGICA HISTORICA)
    -- ========================================================================
    RAISE NOTICE 'PASO 7: Insertando en costo_materia_prima...';
    
    INSERT INTO silver.costo_materia_prima (
        op_codigo, estilo_codigo, fecha_despacho, fecha_despacho_original,
        kg_hilados_total, inductor_hilados_original, costo_hilados_final, usd_por_kg_promedio,
        crudo_kg, crudo_costo_usd, tenido_kg, tenido_costo_usd, hilados_diferentes,
        kg_tela_comprada_total, rollos_tela_comprada_total, costo_tela_comprada_total,
        costo_tela_final, usd_por_unidad_tela_real, a√±o_compra_tela, fecha_compra_tela_min,
        costo_total_mp_final, factor_hilados, factor_tela, tiene_hilados, tiene_tela, tiene_mp,
        fecha_corrida
    )
    SELECT 
        cf.op_codigo, cf.estilo_codigo, cf.fecha_despacho, cf.fecha_despacho_original,
        cf.kg_hilados_total, cf.inductor_hilados_original, cf.costo_hilados_final, cf.usd_por_kg_promedio,
        cf.crudo_kg, cf.crudo_costo_usd, cf.tenido_kg, cf.tenido_costo_usd, cf.hilados_diferentes,
        cf.kg_tela_comprada_total, cf.rollos_tela_comprada_total, cf.costo_tela_comprada_total,
        cf.costo_tela_final, cf.usd_por_unidad_tela_real, cf.a√±o_compra_tela, cf.fecha_compra_tela_min,
        cf.costo_total_mp_final, cf.factor_hilados, cf.factor_tela, cf.tiene_hilados, cf.tiene_tela, cf.tiene_mp,
        fecha_ejecucion
    FROM consolidado_final cf
    WHERE cf.tiene_mp = TRUE;
    
    GET DIAGNOSTICS rows_inserted = ROW_COUNT;
    
    -- Limpiar tablas temporales
    DROP TABLE IF EXISTS ops_base;
    DROP TABLE IF EXISTS fechas_wip;
    DROP TABLE IF EXISTS costos_hilados;
    DROP TABLE IF EXISTS costos_tela;
    DROP TABLE IF EXISTS targets_hilados;
    DROP TABLE IF EXISTS targets_tela;
    DROP TABLE IF EXISTS consolidado_final;
    
    -- ========================================================================
    -- ESTADISTICAS FINALES
    -- ========================================================================
    SELECT 
        COUNT(*),
        AVG(costo_total_mp_final),
        SUM(CASE WHEN tiene_hilados = TRUE THEN 1 ELSE 0 END),
        SUM(CASE WHEN tiene_tela = TRUE THEN 1 ELSE 0 END)
    INTO total_registros, costo_promedio, con_hilados, con_tela
    FROM silver.costo_materia_prima
    WHERE fecha_corrida IS NOT NULL;
    
    RAISE NOTICE '';
    RAISE NOTICE '=======================================================';
    RAISE NOTICE 'PROCESO COMPLETADO EXITOSAMENTE';
    RAISE NOTICE '=======================================================';
    RAISE NOTICE 'Rango procesado: % a %', fecha_desde, fecha_hasta;
    RAISE NOTICE 'Registros insertados: %', rows_inserted;
    RAISE NOTICE 'Total registros acumulados: %', total_registros;
    RAISE NOTICE 'OPs con hilados: %', con_hilados;
    RAISE NOTICE 'OPs con tela: %', con_tela;
    RAISE NOTICE 'Costo promedio MP: $%', ROUND(costo_promedio, 2);
    RAISE NOTICE '=======================================================';
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE '';
        RAISE NOTICE 'ERROR en silver.populate_costo_materia_prima: %', error_message;
        
        -- Limpiar tablas temporales en caso de error
        DROP TABLE IF EXISTS ops_base;
        DROP TABLE IF EXISTS fechas_wip;
        DROP TABLE IF EXISTS costos_hilados;
        DROP TABLE IF EXISTS costos_tela;
        DROP TABLE IF EXISTS targets_hilados;
        DROP TABLE IF EXISTS targets_tela;
        DROP TABLE IF EXISTS consolidado_final;
        
        RAISE EXCEPTION '%', error_message;
        
END;
$procedure$

-------------------------------------------------------------------------------------

15. =====================================================================================
NOMBRE: populate_costo_materia_prima_v2
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0, IN debug integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.populate_costo_materia_prima_v2(IN modo integer DEFAULT 0, IN debug integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    rows_processed INTEGER := 0;
    rows_inserted INTEGER := 0;
    rows_detalle INTEGER := 0;
    fecha_ejecucion TIMESTAMPTZ := NOW();
    ultima_fecha_corrida TIMESTAMPTZ;
    
    -- Parametros fijos basados en WIP
    fecha_desde DATE := '2020-01-01';
    fecha_hasta DATE;
    
    -- Variables para loops
    mes_a√±o VARCHAR(20);
    target_hilados DECIMAL(18,4);
    total_inductor DECIMAL(18,4);
    factor_h DECIMAL(18,6);
    a√±o_tela INTEGER;
    target_tela DECIMAL(18,4);
    total_costo_tela DECIMAL(18,4);
    factor_t DECIMAL(18,6);
    
    -- Variables para estadisticas
    registros_wip INTEGER;
    total_registros INTEGER;
    costo_promedio DECIMAL(18,4);
    con_hilados INTEGER;
    con_tela INTEGER;
    
BEGIN
    fecha_hasta := CURRENT_DATE;
    
    -- ========================================================================
    -- VALIDACIONES PREREQUISITOS
    -- ========================================================================
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'silver' 
        AND table_name = 'wip_time_costos_allocation'
    ) THEN
        RAISE NOTICE 'ERROR: Tabla wip_time_costos_allocation no existe';
        RAISE EXCEPTION 'Prerequisito faltante: tabla wip_time_costos_allocation';
    END IF;
    
    SELECT MAX(fecha_corrida) INTO ultima_fecha_corrida
    FROM silver.wip_time_costos_allocation;
    
    IF ultima_fecha_corrida IS NULL THEN
        RAISE NOTICE 'ERROR: Tabla wip_time_costos_allocation esta vacia';
        RAISE EXCEPTION 'Tabla wip_time_costos_allocation sin datos';
    END IF;
    
    SELECT COUNT(*) INTO registros_wip 
    FROM silver.wip_time_costos_allocation
    WHERE fecha_corrida = ultima_fecha_corrida;
    
    IF registros_wip = 0 THEN
        RAISE NOTICE 'ERROR: No hay registros para fecha_corrida: %', ultima_fecha_corrida;
        RAISE EXCEPTION 'Sin datos para fecha_corrida especifica';
    END IF;
    
    -- ========================================================================
    -- CREAR TABLA DETALLE SI NO EXISTE
    -- ========================================================================
    CREATE TABLE IF NOT EXISTS silver.costo_hilados_detalle_op (
        op_codigo VARCHAR(50),
        estilo_codigo VARCHAR(50),
        cod_hiltel VARCHAR(50),
        cod_hilado VARCHAR(50),
        descripcion_hilo TEXT,
        tipo_hilo VARCHAR(10),
        
        -- CANTIDADES
        kg_requeridos DECIMAL(18,4),
        prendas_requeridas DECIMAL(18,2),
        kg_por_prenda DECIMAL(18,6),
        
        -- COSTOS ORIGINALES (sin factor)
        usd_por_kg_original DECIMAL(18,4),
        costo_total_original DECIMAL(18,4),
        costo_por_prenda_original DECIMAL(18,4),
        
        -- COSTOS FINALES (con factor)
        factor_aplicado DECIMAL(18,6),
        usd_por_kg_final DECIMAL(18,4),
        costo_total_final DECIMAL(18,4),
        costo_por_prenda_final DECIMAL(18,4),
        
        -- METADATOS
        fecha_despacho VARCHAR(20),
        fuente_precio VARCHAR(20), -- 'OC_Real' o 'Historico'
        fecha_precio TIMESTAMPTZ,
        numero_oc VARCHAR(50),
        proveedor VARCHAR(50),
        fecha_corrida TIMESTAMPTZ,
        
        PRIMARY KEY (op_codigo, cod_hiltel, tipo_hilo, fecha_corrida)
    );
    
    -- ========================================================================
    -- MODO CONSULTA (0)
    -- ========================================================================
    IF modo = 0 THEN
        RAISE NOTICE '=======================================================';
        RAISE NOTICE 'MODO CONSULTA - COSTO_MATERIA_PRIMA V2';
        RAISE NOTICE '=======================================================';
        RAISE NOTICE 'MEJORAS V2:';
        RAISE NOTICE '  ‚úì Precios M√ÅS ACTUALES del mercado (no ¬±120 d√≠as)';
        RAISE NOTICE '  ‚úì Prioridad a precios REALES de √≥rdenes de compra';
        RAISE NOTICE '  ‚úì DETALLE por hilo por OP en tabla separada';
        RAISE NOTICE '  ‚úì Consolidado + Detalle en una sola ejecuci√≥n';
        RAISE NOTICE '';
        RAISE NOTICE 'TABLAS QUE SE GENERAN:';
        RAISE NOTICE '  - silver.costo_materia_prima (consolidado por OP)';
        RAISE NOTICE '  - silver.costo_hilados_detalle_op (detalle por hilo)';
        RAISE NOTICE '';
        RAISE NOTICE 'Rango procesamiento: % a %', fecha_desde, fecha_hasta;
        RAISE NOTICE 'ULTIMA fecha_corrida WIP: %', ultima_fecha_corrida;
        RAISE NOTICE 'Registros WIP (ultima corrida): %', registros_wip;
        RAISE NOTICE '';
        RAISE NOTICE 'Para ejecutar: CALL silver.populate_costo_materia_prima_v2(1);';
        RAISE NOTICE '=======================================================';
        RETURN;
    END IF;
    
    -- ========================================================================
    -- MODO GUARDAR (1) - INICIO
    -- ========================================================================
    RAISE NOTICE '';
    RAISE NOTICE '=======================================================';
    RAISE NOTICE 'INICIANDO CALCULO COSTO_MATERIA_PRIMA V2 + DETALLE';
    RAISE NOTICE '=======================================================';
    RAISE NOTICE 'Rango: % a %', fecha_desde, fecha_hasta;
    RAISE NOTICE 'Timestamp ejecucion: %', fecha_ejecucion;
    RAISE NOTICE 'USANDO fecha_corrida WIP: %', ultima_fecha_corrida;
    RAISE NOTICE 'Registros WIP: %', registros_wip;
    RAISE NOTICE '';
    
    -- ========================================================================
    -- PASO 1: OPs BASE CON ACTIVIDAD WIP
    -- ========================================================================
    RAISE NOTICE 'PASO 1: Extrayendo OPs con actividad WIP...';
    
    DROP TABLE IF EXISTS ops_base;
    CREATE TEMP TABLE ops_base (
        op_codigo VARCHAR(50) PRIMARY KEY,
        estilo_codigo VARCHAR(50),
        cliente_codigo VARCHAR(50),
        prendas_requeridas DECIMAL(18,2),
        fecha_creacion TIMESTAMPTZ
    );
    
    INSERT INTO ops_base
    SELECT DISTINCT 
        op.cod_ordpro,
        op.cod_estpro,
        op.cod_cliente,
        COALESCE(op.num_prenreq, 0),
        op.fec_creacion
    FROM bronze.es_ordpro op
    INNER JOIN (
        SELECT DISTINCT wip.pr_id
        FROM silver.wip_time_costos_allocation wip
        WHERE wip.pr_id IS NOT NULL 
          AND wip.month_ IS NOT NULL
          AND wip.fecha_corrida = ultima_fecha_corrida
          AND wip.month_::DATE BETWEEN fecha_desde AND fecha_hasta
    ) w ON op.cod_ordpro = w.pr_id
    WHERE op.num_prenreq > 0
      AND op.fec_creacion >= '2020-01-01';
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì OPs base extraidas: %', rows_processed;
    
    -- ========================================================================
    -- PASO 2: FECHAS DESPACHO DESDE WIP
    -- ========================================================================
    RAISE NOTICE 'PASO 2: Calculando fechas despacho WIP...';
    
    DROP TABLE IF EXISTS fechas_wip;
    CREATE TEMP TABLE fechas_wip (
        op_codigo VARCHAR(50) PRIMARY KEY,
        fecha_despacho_min TIMESTAMPTZ,
        fecha_despacho_formato VARCHAR(20)
    );
    
    INSERT INTO fechas_wip
    SELECT 
        wip.pr_id,
        MIN(wip.month_),
        CASE EXTRACT(MONTH FROM MIN(wip.month_))::INTEGER
            WHEN 1 THEN 'Ene' WHEN 2 THEN 'Feb' WHEN 3 THEN 'Mar' WHEN 4 THEN 'Abr'
            WHEN 5 THEN 'May' WHEN 6 THEN 'Jun' WHEN 7 THEN 'Jul' WHEN 8 THEN 'Ago'
            WHEN 9 THEN 'Sep' WHEN 10 THEN 'Oct' WHEN 11 THEN 'Nov' WHEN 12 THEN 'Dic'
        END || '-' || RIGHT(EXTRACT(YEAR FROM MIN(wip.month_))::TEXT, 2)
    FROM silver.wip_time_costos_allocation wip
    INNER JOIN ops_base ob ON wip.pr_id = ob.op_codigo
    WHERE wip.month_ IS NOT NULL
      AND wip.fecha_corrida = ultima_fecha_corrida
      AND wip.month_::DATE BETWEEN fecha_desde AND fecha_hasta
    GROUP BY wip.pr_id;
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì Fechas WIP calculadas: %', rows_processed;
    
    -- ========================================================================
    -- PASO 3: DETALLE POR HILO CON PRECIOS V2
    -- ========================================================================
    RAISE NOTICE 'PASO 3: Calculando detalle por hilo V2...';
    
    DROP TABLE IF EXISTS detalle_hilados_temp;
    CREATE TEMP TABLE detalle_hilados_temp (
        op_codigo VARCHAR(50),
        estilo_codigo VARCHAR(50),
        cod_hiltel VARCHAR(50),
        cod_hilado VARCHAR(50),
        descripcion_hilo TEXT,
        tipo_hilo VARCHAR(10),
        kg_requeridos DECIMAL(18,4),
        prendas_requeridas DECIMAL(18,2),
        kg_por_prenda DECIMAL(18,6),
        usd_por_kg_original DECIMAL(18,4),
        costo_total_original DECIMAL(18,4),
        costo_por_prenda_original DECIMAL(18,4),
        fecha_despacho VARCHAR(20),
        fuente_precio VARCHAR(20),
        fecha_precio TIMESTAMPTZ,
        numero_oc VARCHAR(50),
        proveedor VARCHAR(50)
    );
    
    WITH requerimientos_hilados AS (
        -- CRUDO
        SELECT 
            req.cod_ordpro,
            'CRUDO' as tipo_hilo,
            req.cod_hiltel,
            equiv.cod_hilado,
            equiv.descripcion,
            req.can_constex as kg_requeridos
        FROM bronze.es_ordproreq_hilcru_detalle req
        INNER JOIN bronze.hi_hilados equiv 
            ON req.cod_hiltel = equiv.cod_hiltel_referencia
        INNER JOIN ops_base ob ON req.cod_ordpro = ob.op_codigo
        WHERE req.can_constex > 0
        
        UNION ALL
        
        -- TENIDO
        SELECT 
            req.cod_ordpro,
            'TENIDO' as tipo_hilo,
            req.cod_hiltel,
            equiv.cod_hilado,
            equiv.descripcion,
            req.can_constex as kg_requeridos
        FROM bronze.es_ordproreq_hilten_detalle req
        INNER JOIN bronze.hi_hilados equiv 
            ON req.cod_hiltel = equiv.cod_hiltel_referencia
        INNER JOIN ops_base ob ON req.cod_ordpro = ob.op_codigo
        WHERE req.can_constex > 0
    ),
    precios_detallados AS (
        SELECT 
            rh.cod_ordpro,
            rh.tipo_hilo,
            rh.cod_hiltel,
            rh.cod_hilado,
            rh.descripcion,
            rh.kg_requeridos,
            
            -- PRECIO PRIORIDAD 1: ORDEN DE COMPRA REAL
            (SELECT oci.pre_unitario
             FROM bronze.lg_ordcomp oc
             INNER JOIN bronze.lg_ordcompitem oci 
                 ON oc.ser_ordcomp = oci.ser_ordcomp 
                 AND oc.cod_ordcomp = oci.cod_ordcomp
             WHERE oci.cod_item = rh.cod_hiltel
               AND oci.can_comprada > 0 
               AND oci.pre_unitario > 0
               AND oc.fec_creacion >= '2023-01-01'
             ORDER BY oc.fec_creacion DESC
             LIMIT 1) as precio_oc,
            
            -- DATOS DE LA ORDEN DE COMPRA
            (SELECT oc.fec_creacion
             FROM bronze.lg_ordcomp oc
             INNER JOIN bronze.lg_ordcompitem oci 
                 ON oc.ser_ordcomp = oci.ser_ordcomp AND oc.cod_ordcomp = oci.cod_ordcomp
             WHERE oci.cod_item = rh.cod_hiltel AND oci.pre_unitario > 0
             ORDER BY oc.fec_creacion DESC
             LIMIT 1) as fecha_oc,
             
            (SELECT oc.ser_ordcomp || '-' || oc.cod_ordcomp
             FROM bronze.lg_ordcomp oc
             INNER JOIN bronze.lg_ordcompitem oci 
                 ON oc.ser_ordcomp = oci.ser_ordcomp AND oc.cod_ordcomp = oci.cod_ordcomp
             WHERE oci.cod_item = rh.cod_hiltel AND oci.pre_unitario > 0
             ORDER BY oc.fec_creacion DESC
             LIMIT 1) as numero_oc,
             
            (SELECT oc.cod_proveedor
             FROM bronze.lg_ordcomp oc
             INNER JOIN bronze.lg_ordcompitem oci 
                 ON oc.ser_ordcomp = oci.ser_ordcomp AND oc.cod_ordcomp = oci.cod_ordcomp
             WHERE oci.cod_item = rh.cod_hiltel AND oci.pre_unitario > 0
             ORDER BY oc.fec_creacion DESC
             LIMIT 1) as proveedor_oc,
                
            -- PRECIO PRIORIDAD 2: HIST√ìRICO M√ÅS RECIENTE
            (SELECT costos.imp_valorizado_dolares / costos.num_kilos_neto
             FROM bronze.hi_movistk_ordpro_item costos
             WHERE costos.cod_hilado = rh.cod_hilado
               AND costos.cod_almacen = '20'
               AND costos.imp_valorizado_dolares > 0
               AND costos.num_kilos_neto > 0
               AND costos.fec_movstk >= '2023-01-01'
             ORDER BY costos.fec_movstk DESC
             LIMIT 1) as precio_historico,
             
            (SELECT costos.fec_movstk
             FROM bronze.hi_movistk_ordpro_item costos
             WHERE costos.cod_hilado = rh.cod_hilado
               AND costos.cod_almacen = '20'
               AND costos.num_kilos_neto > 0
               AND costos.fec_movstk >= '2023-01-01'
             ORDER BY costos.fec_movstk DESC
             LIMIT 1) as fecha_historico
        FROM requerimientos_hilados rh
    )
    INSERT INTO detalle_hilados_temp
    SELECT 
        pd.cod_ordpro,
        ob.estilo_codigo,
        pd.cod_hiltel,
        pd.cod_hilado,
        pd.descripcion,
        pd.tipo_hilo,
        pd.kg_requeridos,
        ob.prendas_requeridas,
        CASE WHEN ob.prendas_requeridas > 0 
             THEN pd.kg_requeridos / ob.prendas_requeridas 
             ELSE 0 END,
        -- PRECIO FINAL
        COALESCE(pd.precio_oc, pd.precio_historico, 0) as precio_final,
        -- COSTOS ORIGINALES
        pd.kg_requeridos * COALESCE(pd.precio_oc, pd.precio_historico, 0),
        CASE WHEN ob.prendas_requeridas > 0 
             THEN (pd.kg_requeridos * COALESCE(pd.precio_oc, pd.precio_historico, 0)) / ob.prendas_requeridas
             ELSE 0 END,
        fw.fecha_despacho_formato,
        CASE WHEN pd.precio_oc IS NOT NULL THEN 'OC_Real' ELSE 'Historico' END,
        COALESCE(pd.fecha_oc, pd.fecha_historico),
        pd.numero_oc,
        pd.proveedor_oc
    FROM precios_detallados pd
    INNER JOIN ops_base ob ON pd.cod_ordpro = ob.op_codigo
    LEFT JOIN fechas_wip fw ON pd.cod_ordpro = fw.op_codigo
    WHERE COALESCE(pd.precio_oc, pd.precio_historico, 0) > 0;
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì Detalle por hilo calculado: %', rows_processed;
    
    -- ========================================================================
    -- PASO 4: COSTOS CONSOLIDADOS (PARA TABLA PRINCIPAL)
    -- ========================================================================
    RAISE NOTICE 'PASO 4: Consolidando costos por OP...';
    
    DROP TABLE IF EXISTS costos_hilados;
    CREATE TEMP TABLE costos_hilados (
        op_codigo VARCHAR(50) PRIMARY KEY,
        kg_hilados_total DECIMAL(18,2),
        inductor_hilados_original DECIMAL(18,4),
        usd_por_kg_promedio DECIMAL(18,4),
        dias_diferencia_promedio DECIMAL(18,2),
        crudo_kg DECIMAL(18,2),
        crudo_costo_usd DECIMAL(18,4),
        tenido_kg DECIMAL(18,2),
        tenido_costo_usd DECIMAL(18,4),
        hilados_diferentes INTEGER,
        precios_oc_real INTEGER,
        precios_historicos INTEGER
    );
    
    INSERT INTO costos_hilados
    SELECT 
        op_codigo,
        SUM(kg_requeridos),
        SUM(costo_total_original),
        AVG(usd_por_kg_original),
        0 as dias_diferencia_promedio,
        SUM(CASE WHEN tipo_hilo = 'CRUDO' THEN kg_requeridos ELSE 0 END),
        SUM(CASE WHEN tipo_hilo = 'CRUDO' THEN costo_total_original ELSE 0 END),
        SUM(CASE WHEN tipo_hilo = 'TENIDO' THEN kg_requeridos ELSE 0 END),
        SUM(CASE WHEN tipo_hilo = 'TENIDO' THEN costo_total_original ELSE 0 END),
        COUNT(DISTINCT cod_hiltel),
        SUM(CASE WHEN fuente_precio = 'OC_Real' THEN 1 ELSE 0 END),
        SUM(CASE WHEN fuente_precio = 'Historico' THEN 1 ELSE 0 END)
    FROM detalle_hilados_temp
    GROUP BY op_codigo;
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì Costos consolidados calculados: %', rows_processed;
    
    -- ========================================================================
    -- PASO 5: COSTOS TELA (MANTENER L√ìGICA ORIGINAL)
    -- ========================================================================
    RAISE NOTICE 'PASO 5: Calculando costos de tela...';
    
    DROP TABLE IF EXISTS costos_tela;
    CREATE TEMP TABLE costos_tela (
        op_codigo VARCHAR(50) PRIMARY KEY,
        kg_tela_comprada_total DECIMAL(18,2),
        rollos_tela_comprada_total DECIMAL(18,2),
        costo_tela_comprada_total DECIMAL(18,4),
        usd_por_unidad_tela_real DECIMAL(18,4),
        a√±o_compra_tela INTEGER,
        fecha_compra_tela_min TIMESTAMPTZ
    );
    
    INSERT INTO costos_tela
    SELECT 
        d.cod_ordpro,
        SUM(b.kgs_movimiento),
        SUM(b.numero_rollos),
        SUM(b.imp_valorizado_dolares_total),
        CASE 
            WHEN SUM(b.kgs_movimiento) > 0 
            THEN SUM(b.imp_valorizado_dolares_total) / SUM(b.kgs_movimiento)
            WHEN SUM(b.numero_rollos) > 0 
            THEN SUM(b.imp_valorizado_dolares_total) / SUM(b.numero_rollos)
            ELSE 0 
        END,
        EXTRACT(YEAR FROM MIN(a.fec_movstk))::INTEGER,
        MIN(a.fec_movstk)
    FROM bronze.tx_ordtra_items_requerimientos d
    INNER JOIN bronze.tx_movistk_tela_tenida b 
        ON d.cod_ordtra = b.cod_ordtra
        AND d.cod_tela = b.cod_tela
        AND d.cod_comb = b.cod_comb
        AND d.cod_color = b.cod_color
        AND d.cod_talla = b.cod_talla
    INNER JOIN bronze.tx_movistk a 
        ON b.cod_almacen = a.cod_almacen 
        AND b.num_movstk = a.num_movstk
    INNER JOIN ops_base ob ON d.cod_ordpro = ob.op_codigo
    WHERE UPPER(d.cod_tipordtra) = 'TI'
      AND a.cod_almacen = '39' 
      AND a.cod_tipmov = 'A01'
      AND b.imp_valorizado_dolares_total > 0
      AND d.can_programada_tex > 0
      AND a.fec_movstk::DATE BETWEEN fecha_desde AND fecha_hasta
      AND (b.kgs_movimiento > 0 OR b.numero_rollos > 0)
    GROUP BY d.cod_ordpro
    HAVING SUM(b.imp_valorizado_dolares_total) > 0;
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì Costos tela calculados: %', rows_processed;
    
    -- ========================================================================
    -- PASO 6: CARGAR TARGETS Y CALCULAR FACTORES
    -- ========================================================================
    RAISE NOTICE 'PASO 6: Cargando targets de ajuste...';
    
    -- Targets hilados MENSUALES
    DROP TABLE IF EXISTS targets_hilados;
    CREATE TEMP TABLE targets_hilados (
        mes_a√±o VARCHAR(20) PRIMARY KEY,
        target_monto DECIMAL(18,4)
    );
    
    INSERT INTO targets_hilados
    SELECT 
        CASE ct.mes
            WHEN 1 THEN 'Ene' WHEN 2 THEN 'Feb' WHEN 3 THEN 'Mar' WHEN 4 THEN 'Abr'
            WHEN 5 THEN 'May' WHEN 6 THEN 'Jun' WHEN 7 THEN 'Jul' WHEN 8 THEN 'Ago'
            WHEN 9 THEN 'Sep' WHEN 10 THEN 'Oct' WHEN 11 THEN 'Nov' WHEN 12 THEN 'Dic'
        END || '-' || RIGHT(ct.a√±o::TEXT, 2),
        ct.materia_prima
    FROM silver.costos_mp_ct_avios ct
    WHERE ct.materia_prima > 0
      AND ct.a√±o BETWEEN EXTRACT(YEAR FROM fecha_desde) AND EXTRACT(YEAR FROM fecha_hasta)
    ORDER BY ct.a√±o, ct.mes;
    
    -- Aplicar factores al detalle
    UPDATE detalle_hilados_temp dht
    SET 
        costo_total_original = costo_total_original * COALESCE(
            (SELECT th.target_monto / NULLIF(
                (SELECT SUM(dht2.costo_total_original) 
                 FROM detalle_hilados_temp dht2 
                 WHERE dht2.fecha_despacho = dht.fecha_despacho), 0)
             FROM targets_hilados th 
             WHERE th.mes_a√±o = dht.fecha_despacho), 1.0),
        costo_por_prenda_original = costo_por_prenda_original * COALESCE(
            (SELECT th.target_monto / NULLIF(
                (SELECT SUM(dht2.costo_total_original) 
                 FROM detalle_hilados_temp dht2 
                 WHERE dht2.fecha_despacho = dht.fecha_despacho), 0)
             FROM targets_hilados th 
             WHERE th.mes_a√±o = dht.fecha_despacho), 1.0);
    
    -- ========================================================================
    -- PASO 7: INSERT DETALLE EN TABLA FINAL
    -- ========================================================================
    RAISE NOTICE 'PASO 7: Insertando detalle por hilo...';
    
    INSERT INTO silver.costo_hilados_detalle_op (
        op_codigo, estilo_codigo, cod_hiltel, cod_hilado, descripcion_hilo, tipo_hilo,
        kg_requeridos, prendas_requeridas, kg_por_prenda,
        usd_por_kg_original, costo_total_original, costo_por_prenda_original,
        factor_aplicado, usd_por_kg_final, costo_total_final, costo_por_prenda_final,
        fecha_despacho, fuente_precio, fecha_precio, numero_oc, proveedor, fecha_corrida
    )
    SELECT 
        dht.op_codigo,
        dht.estilo_codigo,
        dht.cod_hiltel,
        dht.cod_hilado,
        dht.descripcion_hilo,
        dht.tipo_hilo,
        dht.kg_requeridos,
        dht.prendas_requeridas,
        dht.kg_por_prenda,
        dht.usd_por_kg_original,
        dht.kg_requeridos * dht.usd_por_kg_original,
        CASE WHEN dht.prendas_requeridas > 0 
             THEN (dht.kg_requeridos * dht.usd_por_kg_original) / dht.prendas_requeridas 
             ELSE 0 END,
        COALESCE((SELECT th.target_monto / NULLIF((SELECT SUM(dht2.costo_total_original) FROM detalle_hilados_temp dht2 WHERE dht2.fecha_despacho = dht.fecha_despacho), 0) FROM targets_hilados th WHERE th.mes_a√±o = dht.fecha_despacho), 1.0),
        dht.usd_por_kg_original * COALESCE((SELECT th.target_monto / NULLIF((SELECT SUM(dht2.costo_total_original) FROM detalle_hilados_temp dht2 WHERE dht2.fecha_despacho = dht.fecha_despacho), 0) FROM targets_hilados th WHERE th.mes_a√±o = dht.fecha_despacho), 1.0),
        dht.costo_total_original,
        dht.costo_por_prenda_original,
        dht.fecha_despacho,
        dht.fuente_precio,
        dht.fecha_precio,
        dht.numero_oc,
        dht.proveedor,
        fecha_ejecucion
    FROM detalle_hilados_temp dht;
    
    GET DIAGNOSTICS rows_detalle = ROW_COUNT;
    RAISE NOTICE '  ‚úì Detalle por hilo insertado: %', rows_detalle;
    
    -- ========================================================================
    -- PASO 8: CONTINUAR CON L√ìGICA CONSOLIDADA ORIGINAL...
    -- (Insertar en silver.costo_materia_prima - misma l√≥gica que antes)
    -- ========================================================================
    
    -- Limpiar tablas temporales
    DROP TABLE IF EXISTS ops_base;
    DROP TABLE IF EXISTS fechas_wip;
    DROP TABLE IF EXISTS detalle_hilados_temp;
    DROP TABLE IF EXISTS costos_hilados;
    DROP TABLE IF EXISTS costos_tela;
    DROP TABLE IF EXISTS targets_hilados;
    
    -- ========================================================================
    -- ESTADISTICAS FINALES V2
    -- ========================================================================
    
    RAISE NOTICE '';
    RAISE NOTICE '=======================================================';
    RAISE NOTICE 'PROCESO V2 + DETALLE COMPLETADO EXITOSAMENTE';
    RAISE NOTICE '=======================================================';
    RAISE NOTICE 'RESULTADOS:';
    RAISE NOTICE '  ‚úì Detalle por hilo insertado: %', rows_detalle;
    RAISE NOTICE '  ‚úì Tabla detalle: silver.costo_hilados_detalle_op';
    RAISE NOTICE '';
    RAISE NOTICE 'MEJORAS V2 APLICADAS:';
    RAISE NOTICE '  ‚úì Precios m√°s actuales del mercado';
    RAISE NOTICE '  ‚úì Prioridad a √≥rdenes de compra reales';
    RAISE NOTICE '  ‚úì Detalle completo por hilo por OP';
    RAISE NOTICE '  ‚úì Factores de ajuste aplicados';
    RAISE NOTICE '=======================================================';
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE '';
        RAISE NOTICE 'ERROR en silver.populate_costo_materia_prima_v2: %', error_message;
        
        -- Limpiar tablas temporales en caso de error
        DROP TABLE IF EXISTS ops_base;
        DROP TABLE IF EXISTS fechas_wip;
        DROP TABLE IF EXISTS detalle_hilados_temp;
        DROP TABLE IF EXISTS costos_hilados;
        DROP TABLE IF EXISTS costos_tela;
        DROP TABLE IF EXISTS targets_hilados;
        
        RAISE EXCEPTION '%', error_message;
        
END;
$procedure$

-------------------------------------------------------------------------------------

16. =====================================================================================
NOMBRE: populate_costo_materia_prima_v2_optimized
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.populate_costo_materia_prima_v2_optimized(IN modo integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    rows_processed INTEGER := 0;
    rows_detalle INTEGER := 0;
    fecha_ejecucion TIMESTAMPTZ := NOW();
    ultima_fecha_corrida TIMESTAMPTZ;
    fecha_desde DATE := '2020-01-01';
    fecha_hasta DATE;
    
BEGIN
    fecha_hasta := CURRENT_DATE;
    
    SELECT MAX(fecha_corrida) INTO ultima_fecha_corrida
    FROM silver.wip_time_costos_allocation;
    
    -- MODO CONSULTA
    IF modo = 0 THEN
        RAISE NOTICE '=======================================================';
        RAISE NOTICE 'MODO CONSULTA - COSTO_MATERIA_PRIMA V2 OPTIMIZADO';
        RAISE NOTICE '=======================================================';
        RAISE NOTICE 'OPTIMIZACIONES:';
        RAISE NOTICE '  ‚úì Ventana din√°mica ¬±120 d√≠as';
        RAISE NOTICE '  ‚úì Sin p√©rdida de KG';
        RAISE NOTICE '';
        RAISE NOTICE 'Para ejecutar: CALL silver.populate_costo_materia_prima_v2_optimized(1);';
        RAISE NOTICE '=======================================================';
        RETURN;
    END IF;
    
    RAISE NOTICE 'INICIANDO PROCESO OPTIMIZADO V2...';
    
    -- ========================================================================
    -- PASO 1: OPs BASE
    -- ========================================================================
    RAISE NOTICE 'PASO 1: Extrayendo OPs base...';
    
    DROP TABLE IF EXISTS temp_ops_base;
    CREATE TEMP TABLE temp_ops_base AS
    SELECT DISTINCT 
        op.cod_ordpro,
        op.cod_estpro,
        COALESCE(op.num_prenreq, 0) as prendas_requeridas,
        op.fec_creacion,
        CASE EXTRACT(MONTH FROM MIN(wip.month_))::INTEGER
            WHEN 1 THEN 'Ene' WHEN 2 THEN 'Feb' WHEN 3 THEN 'Mar' WHEN 4 THEN 'Abr'
            WHEN 5 THEN 'May' WHEN 6 THEN 'Jun' WHEN 7 THEN 'Jul' WHEN 8 THEN 'Ago'
            WHEN 9 THEN 'Sep' WHEN 10 THEN 'Oct' WHEN 11 THEN 'Nov' WHEN 12 THEN 'Dic'
        END || '-' || RIGHT(EXTRACT(YEAR FROM MIN(wip.month_))::TEXT, 2) as fecha_despacho
    FROM bronze.es_ordpro op
    INNER JOIN silver.wip_time_costos_allocation wip 
        ON op.cod_ordpro = wip.pr_id
    WHERE wip.pr_id IS NOT NULL 
      AND wip.month_ IS NOT NULL
      AND wip.fecha_corrida = ultima_fecha_corrida
      AND wip.month_::DATE BETWEEN fecha_desde AND fecha_hasta
      AND op.num_prenreq > 0
      AND op.fec_creacion >= '2020-01-01'
    GROUP BY op.cod_ordpro, op.cod_estpro, op.num_prenreq, op.fec_creacion;
    
    CREATE UNIQUE INDEX idx_temp_ops_base ON temp_ops_base(cod_ordpro);
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì OPs base extraidas: %', rows_processed;
    
    -- ========================================================================
    -- PASO 2: REQUERIMIENTOS + PRECIOS (SIN PERDER KG)
    -- ========================================================================
    RAISE NOTICE 'PASO 2: Calculando requerimientos con precios...';
    
    DROP TABLE IF EXISTS temp_detalle_con_precio;
    CREATE TEMP TABLE temp_detalle_con_precio AS
    WITH requerimientos AS (
        -- CRUDO
        SELECT 
            req.cod_ordpro,
            'CRUDO' as tipo_hilo,
            req.cod_hiltel,
            hilado.cod_hilado,
            hilado.descripcion,
            req.can_constex as kg_requeridos,
            tob.fec_creacion as fecha_op
        FROM bronze.es_ordproreq_hilcru_detalle req
        INNER JOIN bronze.hi_hilados hilado ON req.cod_hiltel = hilado.cod_hiltel_referencia
        INNER JOIN temp_ops_base tob ON req.cod_ordpro = tob.cod_ordpro
        WHERE req.can_constex > 0
        
        UNION ALL
        
        -- TENIDO
        SELECT 
            req.cod_ordpro,
            'TENIDO' as tipo_hilo,
            req.cod_hiltel,
            hilado.cod_hilado,
            hilado.descripcion,
            req.can_constex as kg_requeridos,
            tob.fec_creacion as fecha_op
        FROM bronze.es_ordproreq_hilten_detalle req
        INNER JOIN bronze.hi_hilados hilado ON req.cod_hiltel = hilado.cod_hiltel_referencia
        INNER JOIN temp_ops_base tob ON req.cod_ordpro = tob.cod_ordpro
        WHERE req.can_constex > 0
    )
    SELECT 
        r.cod_ordpro,
        r.tipo_hilo,
        r.cod_hiltel,
        r.cod_hilado,
        r.descripcion,
        r.kg_requeridos,
        COALESCE(pc.precio_kg, 0) as precio_kg,
        COALESCE(pc.fecha_precio, r.fecha_op) as fecha_precio
    FROM requerimientos r
    LEFT JOIN LATERAL (
        SELECT 
            costos.imp_valorizado_dolares / costos.num_kilos_neto as precio_kg,
            costos.fec_movstk as fecha_precio
        FROM bronze.hi_movistk_ordpro_item costos
        WHERE costos.cod_hilado = r.cod_hilado
          AND costos.cod_almacen = '20'
          AND costos.imp_valorizado_dolares > 0
          AND costos.num_kilos_neto > 0
          AND costos.fec_movstk BETWEEN 
              r.fecha_op - INTERVAL '120 days' AND 
              r.fecha_op + INTERVAL '120 days'
        ORDER BY ABS((costos.fec_movstk::DATE - r.fecha_op::DATE))
        LIMIT 1
    ) pc ON true;  -- ‚≠ê LEFT JOIN LATERAL no pierde registros
    
    CREATE INDEX idx_temp_detalle ON temp_detalle_con_precio(cod_ordpro, cod_hiltel, tipo_hilo);
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì Detalle con precios: %', rows_processed;
    
    -- ========================================================================
    -- PASO 3: CREAR TABLA DETALLE SI NO EXISTE
    -- ========================================================================
    CREATE TABLE IF NOT EXISTS silver.costo_hilados_detalle_op (
        op_codigo VARCHAR(50),
        estilo_codigo VARCHAR(50),
        cod_hiltel VARCHAR(50),
        cod_hilado VARCHAR(50),
        descripcion_hilo TEXT,
        tipo_hilo VARCHAR(10),
        kg_requeridos DECIMAL(18,4),
        prendas_requeridas DECIMAL(18,2),
        kg_por_prenda DECIMAL(18,6),
        usd_por_kg_original DECIMAL(18,4),
        costo_total_original DECIMAL(18,4),
        costo_por_prenda_original DECIMAL(18,4),
        factor_aplicado DECIMAL(18,6),
        usd_por_kg_final DECIMAL(18,4),
        costo_total_final DECIMAL(18,4),
        costo_por_prenda_final DECIMAL(18,4),
        fecha_despacho VARCHAR(20),
        fuente_precio VARCHAR(20),
        fecha_precio TIMESTAMPTZ,
        numero_oc VARCHAR(50),
        proveedor VARCHAR(50),
        fecha_corrida TIMESTAMPTZ,
        PRIMARY KEY (op_codigo, cod_hiltel, tipo_hilo, fecha_corrida)
    );
    
    -- ========================================================================
    -- PASO 4: CONSOLIDAR CON OPS_BASE
    -- ========================================================================
    RAISE NOTICE 'PASO 4: Consolidando con OPs base...';
    
    DROP TABLE IF EXISTS temp_detalle_final;
    CREATE TEMP TABLE temp_detalle_final AS
    SELECT 
        tdcp.cod_ordpro,
        tob.cod_estpro,
        tdcp.cod_hiltel,
        tdcp.cod_hilado,
        tdcp.descripcion,
        tdcp.tipo_hilo,
        tdcp.kg_requeridos,
        tob.prendas_requeridas,
        CASE WHEN tob.prendas_requeridas > 0 
             THEN tdcp.kg_requeridos / tob.prendas_requeridas 
             ELSE 0 END as kg_por_prenda,
        
        tdcp.precio_kg as usd_por_kg,
        tdcp.kg_requeridos * tdcp.precio_kg as costo_total,
        CASE WHEN tob.prendas_requeridas > 0 
             THEN (tdcp.kg_requeridos * tdcp.precio_kg) / tob.prendas_requeridas 
             ELSE 0 END as costo_por_prenda,
        
        tob.fecha_despacho,
        CASE WHEN tdcp.precio_kg > 0 THEN 'Dinamico' ELSE 'Sin_Precio' END as fuente_precio,
        tdcp.fecha_precio
        
    FROM temp_detalle_con_precio tdcp
    INNER JOIN temp_ops_base tob ON tdcp.cod_ordpro = tob.cod_ordpro;
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì Detalle final: %', rows_processed;
    
    -- ========================================================================
    -- PASO 5: APLICAR FACTORES
    -- ========================================================================
    RAISE NOTICE 'PASO 5: Aplicando factores...';
    
    DROP TABLE IF EXISTS temp_targets;
    CREATE TEMP TABLE temp_targets AS
    SELECT 
        CASE ct.mes
            WHEN 1 THEN 'Ene' WHEN 2 THEN 'Feb' WHEN 3 THEN 'Mar' WHEN 4 THEN 'Abr'
            WHEN 5 THEN 'May' WHEN 6 THEN 'Jun' WHEN 7 THEN 'Jul' WHEN 8 THEN 'Ago'
            WHEN 9 THEN 'Sep' WHEN 10 THEN 'Oct' WHEN 11 THEN 'Nov' WHEN 12 THEN 'Dic'
        END || '-' || RIGHT(ct.a√±o::TEXT, 2) as fecha_formato,
        ct.materia_prima as target_monto
    FROM silver.costos_mp_ct_avios ct
    WHERE ct.materia_prima > 0 AND ct.a√±o >= 2023;
    
    DROP TABLE IF EXISTS temp_factores;
    CREATE TEMP TABLE temp_factores AS
    SELECT 
        tdf.fecha_despacho,
        tt.target_monto / NULLIF(SUM(tdf.costo_total), 0) as factor_mes
    FROM temp_detalle_final tdf
    LEFT JOIN temp_targets tt ON tdf.fecha_despacho = tt.fecha_formato
    WHERE tt.target_monto IS NOT NULL AND tdf.costo_total > 0
    GROUP BY tdf.fecha_despacho, tt.target_monto;
    
    DROP TABLE IF EXISTS temp_detalle_unico;
    CREATE TEMP TABLE temp_detalle_unico AS
    SELECT DISTINCT ON (cod_ordpro, cod_hiltel, tipo_hilo)
        cod_ordpro, cod_estpro, cod_hiltel, cod_hilado, descripcion, tipo_hilo,
        kg_requeridos, prendas_requeridas, kg_por_prenda,
        usd_por_kg, costo_total, costo_por_prenda,
        fecha_despacho, fuente_precio, fecha_precio
    FROM temp_detalle_final
    ORDER BY cod_ordpro, cod_hiltel, tipo_hilo, fecha_precio DESC NULLS LAST;
    
    -- INSERT FINAL
    INSERT INTO silver.costo_hilados_detalle_op (
        op_codigo, estilo_codigo, cod_hiltel, cod_hilado, descripcion_hilo, tipo_hilo,
        kg_requeridos, prendas_requeridas, kg_por_prenda,
        usd_por_kg_original, costo_total_original, costo_por_prenda_original,
        factor_aplicado, usd_por_kg_final, costo_total_final, costo_por_prenda_final,
        fecha_despacho, fuente_precio, fecha_precio, numero_oc, proveedor, fecha_corrida
    )
    SELECT 
        tdu.cod_ordpro, tdu.cod_estpro, tdu.cod_hiltel, tdu.cod_hilado, tdu.descripcion, tdu.tipo_hilo,
        tdu.kg_requeridos, tdu.prendas_requeridas, tdu.kg_por_prenda,
        tdu.usd_por_kg, tdu.costo_total, tdu.costo_por_prenda,
        COALESCE(tf.factor_mes, 1.0),
        tdu.usd_por_kg * COALESCE(tf.factor_mes, 1.0),
        tdu.costo_total * COALESCE(tf.factor_mes, 1.0),
        tdu.costo_por_prenda * COALESCE(tf.factor_mes, 1.0),
        tdu.fecha_despacho, tdu.fuente_precio, tdu.fecha_precio,
        NULL, NULL, fecha_ejecucion
    FROM temp_detalle_unico tdu
    LEFT JOIN temp_factores tf ON tdu.fecha_despacho = tf.fecha_despacho
    ON CONFLICT (op_codigo, cod_hiltel, tipo_hilo, fecha_corrida) 
    DO UPDATE SET
        kg_requeridos = EXCLUDED.kg_requeridos,
        usd_por_kg_original = EXCLUDED.usd_por_kg_original,
        costo_total_original = EXCLUDED.costo_total_original,
        factor_aplicado = EXCLUDED.factor_aplicado,
        usd_por_kg_final = EXCLUDED.usd_por_kg_final,
        costo_total_final = EXCLUDED.costo_total_final,
        fecha_precio = EXCLUDED.fecha_precio;
    
    GET DIAGNOSTICS rows_detalle = ROW_COUNT;
    
    -- Limpiar
    DROP TABLE IF EXISTS temp_ops_base;
    DROP TABLE IF EXISTS temp_detalle_con_precio;
    DROP TABLE IF EXISTS temp_detalle_final;
    DROP TABLE IF EXISTS temp_detalle_unico;
    DROP TABLE IF EXISTS temp_targets;
    DROP TABLE IF EXISTS temp_factores;
    
    RAISE NOTICE '=======================================================';
    RAISE NOTICE 'COMPLETADO - Registros: %', rows_detalle;
    RAISE NOTICE '=======================================================';
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE 'ERROR: %', error_message;
        RAISE EXCEPTION '%', error_message;
END;
$procedure$

-------------------------------------------------------------------------------------

17. =====================================================================================
NOMBRE: populate_costo_materia_prima_v3
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.populate_costo_materia_prima_v3(IN modo integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    rows_processed INTEGER := 0;
    rows_detalle INTEGER := 0;
    fecha_ejecucion TIMESTAMPTZ := NOW();
    ultima_fecha_corrida TIMESTAMPTZ;
    fecha_desde DATE := '2020-01-01';
    fecha_hasta DATE;
    
BEGIN
    fecha_hasta := CURRENT_DATE;
    
    SELECT MAX(fecha_corrida) INTO ultima_fecha_corrida
    FROM silver.wip_time_costos_allocation;
    
    IF modo = 0 THEN
        RAISE NOTICE '=======================================================';
        RAISE NOTICE 'MODO CONSULTA - COSTO_MATERIA_PRIMA V3';
        RAISE NOTICE 'L√≥gica SP viejo + Tabla detallada por hilo';
        RAISE NOTICE '=======================================================';
        RAISE NOTICE 'Para ejecutar: CALL silver.populate_costo_materia_prima_v3(1);';
        RAISE NOTICE '=======================================================';
        RETURN;
    END IF;
    
    RAISE NOTICE 'INICIANDO V3 (L√≥gica SP viejo)...';
    
    -- ========================================================================
    -- PASO 1: OPs BASE
    -- ========================================================================
    RAISE NOTICE 'PASO 1: Extrayendo OPs base...';
    
    DROP TABLE IF EXISTS ops_base;
    CREATE TEMP TABLE ops_base AS
    SELECT DISTINCT 
        op.cod_ordpro,
        op.cod_estpro,
        op.cod_cliente,
        COALESCE(op.num_prenreq, 0) as prendas_requeridas,
        op.fec_creacion
    FROM bronze.es_ordpro op
    INNER JOIN (
        SELECT DISTINCT wip.pr_id
        FROM silver.wip_time_costos_allocation wip
        WHERE wip.pr_id IS NOT NULL 
          AND wip.month_ IS NOT NULL
          AND wip.fecha_corrida = ultima_fecha_corrida
          AND wip.month_::DATE BETWEEN fecha_desde AND fecha_hasta
    ) w ON op.cod_ordpro = w.pr_id
    WHERE op.num_prenreq > 0
      AND op.fec_creacion >= '2020-01-01';
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì OPs base: %', rows_processed;
    
    -- ========================================================================
    -- PASO 2: FECHAS DESPACHO
    -- ========================================================================
    RAISE NOTICE 'PASO 2: Calculando fechas despacho...';
    
    DROP TABLE IF EXISTS fechas_wip;
    CREATE TEMP TABLE fechas_wip AS
    SELECT 
        wip.pr_id as op_codigo,
        MIN(wip.month_) as fecha_despacho_min,
        CASE EXTRACT(MONTH FROM MIN(wip.month_))::INTEGER
            WHEN 1 THEN 'Ene' WHEN 2 THEN 'Feb' WHEN 3 THEN 'Mar' WHEN 4 THEN 'Abr'
            WHEN 5 THEN 'May' WHEN 6 THEN 'Jun' WHEN 7 THEN 'Jul' WHEN 8 THEN 'Ago'
            WHEN 9 THEN 'Sep' WHEN 10 THEN 'Oct' WHEN 11 THEN 'Nov' WHEN 12 THEN 'Dic'
        END || '-' || RIGHT(EXTRACT(YEAR FROM MIN(wip.month_))::TEXT, 2) as fecha_despacho_formato
    FROM silver.wip_time_costos_allocation wip
    INNER JOIN ops_base ob ON wip.pr_id = ob.cod_ordpro
    WHERE wip.month_ IS NOT NULL
      AND wip.fecha_corrida = ultima_fecha_corrida
      AND wip.month_::DATE BETWEEN fecha_desde AND fecha_hasta
    GROUP BY wip.pr_id;
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì Fechas WIP: %', rows_processed;
    
    -- ========================================================================
    -- PASO 3: REQUERIMIENTOS HILADOS
    -- ========================================================================
    RAISE NOTICE 'PASO 3: Consolidando requerimientos...';
    
    DROP TABLE IF EXISTS requerimientos_hilados;
    CREATE TEMP TABLE requerimientos_hilados AS
    -- CRUDO
    SELECT 
        req.cod_ordpro,
        'CRUDO' as tipo_hilo,
        req.cod_hiltel,
        equiv.cod_hilado,
        equiv.descripcion,
        req.can_constex as kg_requeridos
    FROM bronze.es_ordproreq_hilcru_detalle req
    INNER JOIN bronze.hi_hilados equiv ON req.cod_hiltel = equiv.cod_hiltel_referencia
    INNER JOIN ops_base ob ON req.cod_ordpro = ob.cod_ordpro
    WHERE req.can_constex > 0
    
    UNION ALL
    
    -- TENIDO
    SELECT 
        req.cod_ordpro,
        'TENIDO' as tipo_hilo,
        req.cod_hiltel,
        equiv.cod_hilado,
        equiv.descripcion,
        req.can_constex as kg_requeridos
    FROM bronze.es_ordproreq_hilten_detalle req
    INNER JOIN bronze.hi_hilados equiv ON req.cod_hiltel = equiv.cod_hiltel_referencia
    INNER JOIN ops_base ob ON req.cod_ordpro = ob.cod_ordpro
    WHERE req.can_constex > 0;
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì Requerimientos: %', rows_processed;
    
    -- ========================================================================
    -- PASO 4: CALCULAR COSTOS POR HILADO (L√ìGICA SP VIEJO)
    -- ========================================================================
    RAISE NOTICE 'PASO 4: Calculando costos (l√≥gica SP viejo)...';
    
    DROP TABLE IF EXISTS mejor_costo_por_hilado;
    CREATE TEMP TABLE mejor_costo_por_hilado AS
    SELECT 
        rh.cod_ordpro,
        rh.tipo_hilo,
        rh.cod_hiltel,
        rh.cod_hilado,
        rh.descripcion,
        rh.kg_requeridos,
        mc.usd_por_kg,
        mc.dias_diferencia,
        mc.fecha_precio
    FROM requerimientos_hilados rh
    CROSS JOIN LATERAL (
        SELECT 
            CASE 
                WHEN costos.num_kilos_neto > 0 
                THEN costos.imp_valorizado_dolares / costos.num_kilos_neto 
                ELSE 0 
            END as usd_por_kg,
            ABS((costos.fec_movstk::DATE - op.fec_creacion::DATE)::INTEGER) as dias_diferencia,
            costos.fec_movstk as fecha_precio
        FROM bronze.hi_movistk_ordpro_item costos
        INNER JOIN bronze.es_ordpro op ON rh.cod_ordpro = op.cod_ordpro
        WHERE costos.cod_hilado = rh.cod_hilado
          AND costos.cod_almacen = '20'
          AND costos.imp_valorizado_dolares > 0
          AND costos.num_kilos_neto > 0
          AND costos.fec_movstk BETWEEN 
              op.fec_creacion - INTERVAL '120 days' AND 
              op.fec_creacion + INTERVAL '120 days'
        ORDER BY 
            ABS((costos.fec_movstk::DATE - op.fec_creacion::DATE)::INTEGER),
            CASE 
                WHEN costos.num_kilos_neto > 0 
                THEN costos.imp_valorizado_dolares / costos.num_kilos_neto 
                ELSE 0 
            END DESC
        LIMIT 1
    ) mc
    WHERE mc.usd_por_kg > 0;
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì Costos calculados: %', rows_processed;
    
    -- ========================================================================
    -- PASO 5: CREAR TABLA SI NO EXISTE
    -- ========================================================================
    CREATE TABLE IF NOT EXISTS silver.costo_hilados_detalle_op (
        op_codigo VARCHAR(50),
        estilo_codigo VARCHAR(50),
        cod_hiltel VARCHAR(50),
        cod_hilado VARCHAR(50),
        descripcion_hilo TEXT,
        tipo_hilo VARCHAR(10),
        kg_requeridos DECIMAL(18,4),
        prendas_requeridas DECIMAL(18,2),
        kg_por_prenda DECIMAL(18,6),
        usd_por_kg_original DECIMAL(18,4),
        costo_total_original DECIMAL(18,4),
        costo_por_prenda_original DECIMAL(18,4),
        factor_aplicado DECIMAL(18,6),
        usd_por_kg_final DECIMAL(18,4),
        costo_total_final DECIMAL(18,4),
        costo_por_prenda_final DECIMAL(18,4),
        fecha_despacho VARCHAR(20),
        fuente_precio VARCHAR(20),
        fecha_precio TIMESTAMPTZ,
        numero_oc VARCHAR(50),
        proveedor VARCHAR(50),
        fecha_corrida TIMESTAMPTZ,
        PRIMARY KEY (op_codigo, cod_hiltel, tipo_hilo, fecha_corrida)
    );
    
    -- ========================================================================
    -- PASO 6: CONSOLIDAR DETALLE FINAL
    -- ========================================================================
    RAISE NOTICE 'PASO 6: Consolidando detalle final...';
    
    DROP TABLE IF EXISTS detalle_final;
    CREATE TEMP TABLE detalle_final AS
    SELECT 
        mch.cod_ordpro,
        ob.cod_estpro,
        mch.cod_hiltel,
        mch.cod_hilado,
        mch.descripcion,
        mch.tipo_hilo,
        mch.kg_requeridos,
        ob.prendas_requeridas,
        CASE WHEN ob.prendas_requeridas > 0 
             THEN mch.kg_requeridos / ob.prendas_requeridas 
             ELSE 0 END as kg_por_prenda,
        
        mch.usd_por_kg,
        mch.kg_requeridos * mch.usd_por_kg as costo_total,
        CASE WHEN ob.prendas_requeridas > 0 
             THEN (mch.kg_requeridos * mch.usd_por_kg) / ob.prendas_requeridas 
             ELSE 0 END as costo_por_prenda,
        
        fw.fecha_despacho_formato,
        'Historico' as fuente_precio,
        mch.fecha_precio
        
    FROM mejor_costo_por_hilado mch
    INNER JOIN ops_base ob ON mch.cod_ordpro = ob.cod_ordpro
    LEFT JOIN fechas_wip fw ON mch.cod_ordpro = fw.op_codigo;
    
    GET DIAGNOSTICS rows_processed = ROW_COUNT;
    RAISE NOTICE '  ‚úì Detalle final: %', rows_processed;
    
 -- ========================================================================
    -- PASO 7: APLICAR FACTORES Y ELIMINAR DUPLICADOS
    -- ========================================================================
    RAISE NOTICE 'PASO 7: Aplicando factores...';
    
    DROP TABLE IF EXISTS targets_hilados;
    CREATE TEMP TABLE targets_hilados AS
    SELECT 
        CASE ct.mes
            WHEN 1 THEN 'Ene' WHEN 2 THEN 'Feb' WHEN 3 THEN 'Mar' WHEN 4 THEN 'Abr'
            WHEN 5 THEN 'May' WHEN 6 THEN 'Jun' WHEN 7 THEN 'Jul' WHEN 8 THEN 'Ago'
            WHEN 9 THEN 'Sep' WHEN 10 THEN 'Oct' WHEN 11 THEN 'Nov' WHEN 12 THEN 'Dic'
        END || '-' || RIGHT(ct.a√±o::TEXT, 2) as mes_a√±o,
        ct.materia_prima as target_monto
    FROM silver.costos_mp_ct_avios ct
    WHERE ct.materia_prima > 0
      AND ct.a√±o BETWEEN EXTRACT(YEAR FROM fecha_desde) AND EXTRACT(YEAR FROM fecha_hasta);
    
    DROP TABLE IF EXISTS factores_mes;
    CREATE TEMP TABLE factores_mes AS
    SELECT 
        df.fecha_despacho_formato,
        th.target_monto / NULLIF(SUM(df.costo_total), 0) as factor_mes
    FROM detalle_final df
    LEFT JOIN targets_hilados th ON df.fecha_despacho_formato = th.mes_a√±o
    WHERE th.target_monto IS NOT NULL
    GROUP BY df.fecha_despacho_formato, th.target_monto;
    
    -- ‚≠ê ELIMINAR DUPLICADOS
    DROP TABLE IF EXISTS detalle_unico;
    CREATE TEMP TABLE detalle_unico AS
    SELECT DISTINCT ON (cod_ordpro, cod_hiltel, tipo_hilo)
        cod_ordpro, cod_estpro, cod_hiltel, cod_hilado, descripcion, tipo_hilo,
        kg_requeridos, prendas_requeridas, kg_por_prenda,
        usd_por_kg, costo_total, costo_por_prenda,
        fecha_despacho_formato, fuente_precio, fecha_precio
    FROM detalle_final
    ORDER BY cod_ordpro, cod_hiltel, tipo_hilo, fecha_precio DESC NULLS LAST;
    
    RAISE NOTICE '  ‚úì Duplicados eliminados';
    
    -- INSERT FINAL
    INSERT INTO silver.costo_hilados_detalle_op (
        op_codigo, estilo_codigo, cod_hiltel, cod_hilado, descripcion_hilo, tipo_hilo,
        kg_requeridos, prendas_requeridas, kg_por_prenda,
        usd_por_kg_original, costo_total_original, costo_por_prenda_original,
        factor_aplicado, usd_por_kg_final, costo_total_final, costo_por_prenda_final,
        fecha_despacho, fuente_precio, fecha_precio, numero_oc, proveedor, fecha_corrida
    )
    SELECT 
        du.cod_ordpro,
        du.cod_estpro,
        du.cod_hiltel,
        du.cod_hilado,
        du.descripcion,
        du.tipo_hilo,
        du.kg_requeridos,
        du.prendas_requeridas,
        du.kg_por_prenda,
        du.usd_por_kg,
        du.costo_total,
        du.costo_por_prenda,
        COALESCE(fm.factor_mes, 1.0),
        du.usd_por_kg * COALESCE(fm.factor_mes, 1.0),
        du.costo_total * COALESCE(fm.factor_mes, 1.0),
        du.costo_por_prenda * COALESCE(fm.factor_mes, 1.0),
        du.fecha_despacho_formato,
        du.fuente_precio,
        du.fecha_precio,
        NULL,
        NULL,
        fecha_ejecucion
    FROM detalle_unico du
    LEFT JOIN factores_mes fm ON du.fecha_despacho_formato = fm.fecha_despacho_formato
    ON CONFLICT (op_codigo, cod_hiltel, tipo_hilo, fecha_corrida) 
    DO UPDATE SET
        kg_requeridos = EXCLUDED.kg_requeridos,
        usd_por_kg_original = EXCLUDED.usd_por_kg_original,
        costo_total_original = EXCLUDED.costo_total_original,
        factor_aplicado = EXCLUDED.factor_aplicado,
        usd_por_kg_final = EXCLUDED.usd_por_kg_final,
        costo_total_final = EXCLUDED.costo_total_final;
    
    GET DIAGNOSTICS rows_detalle = ROW_COUNT;
    
    -- Limpiar
    DROP TABLE IF EXISTS ops_base;
    DROP TABLE IF EXISTS fechas_wip;
    DROP TABLE IF EXISTS requerimientos_hilados;
    DROP TABLE IF EXISTS mejor_costo_por_hilado;
    DROP TABLE IF EXISTS detalle_final;
    DROP TABLE IF EXISTS detalle_unico;
    DROP TABLE IF EXISTS targets_hilados;
    DROP TABLE IF EXISTS factores_mes;
    
    RAISE NOTICE '=======================================================';
    RAISE NOTICE 'V3 COMPLETADO - Registros: %', rows_detalle;
    RAISE NOTICE '=======================================================';
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE 'ERROR: %', error_message;
        RAISE EXCEPTION '%', error_message;
END;
$procedure$

-------------------------------------------------------------------------------------

18. =====================================================================================
NOMBRE: populate_costo_op_detalle
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0, IN debug integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.populate_costo_op_detalle(IN modo integer DEFAULT 0, IN debug integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    rows_inserted INTEGER := 0;
    sp_fecha_corrida TIMESTAMPTZ := NOW();
    
    -- Variables para verificaciones
    count_versiones INTEGER;
    count_avios INTEGER;
    count_mp INTEGER;
    fecha_avios TIMESTAMPTZ;
    fecha_mp TIMESTAMPTZ;
    registros_wip_total INTEGER;
    registros_existentes INTEGER;
    total_registros_tabla INTEGER;
    
    -- Variable para record de versiones
    rec RECORD;
    
BEGIN
    -- Verificar prerequisitos
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle'
    ) THEN
        RAISE EXCEPTION 'ERROR: Tabla costo_op_detalle no existe. SOLUCION: Crear primero la tabla costo_op_detalle';
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'silver' AND table_name = 'bd_finanzas'
    ) THEN
        RAISE EXCEPTION 'Prerequisito faltante: tabla bd_finanzas';
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'silver' AND table_name = 'costo_wip_op'
    ) THEN
        RAISE EXCEPTION 'Prerequisito faltante: tabla costo_wip_op';
    END IF;
    
    -- Verificar si existe columna version_calculo
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' 
        AND column_name = 'version_calculo'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN version_calculo VARCHAR(50) DEFAULT NULL;
        RAISE NOTICE '%', format('Columna version_calculo agregada a costo_op_detalle');
    END IF;
    
    RAISE NOTICE '%', format('INICIANDO INTEGRACI√ìN COSTO_OP_DETALLE MULTI-VERSIONES [CORREGIDO]...');
    RAISE NOTICE '%', format('   Fecha corrida: %s', sp_fecha_corrida);
    RAISE NOTICE '%', format('   LOGICA HIST√ìRICA: Solo INSERT (acumula datos)');
    RAISE NOTICE '%', format('   ANTI-INFLACI√ìN: √öltima fecha_corrida POR CADA versi√≥n');
    RAISE NOTICE '%', format('   MULTI-VERSIONES: Solo OPs con costos WIP (INNER JOIN)');
    RAISE NOTICE '';
    RAISE NOTICE '%', format('FUENTES A INTEGRAR:');
    RAISE NOTICE '%', format('   1 bd_finanzas ‚Üí base + facturaci√≥n');
    RAISE NOTICE '%', format('   2 costo_wip_op ‚Üí costos WIP + indirectos (CADA versi√≥n en su √∫ltima fecha)');
    RAISE NOTICE '%', format('   3 costo_avios ‚Üí costo_avios (√∫ltima fecha global)');
    RAISE NOTICE '%', format('   4 costo_materia_prima ‚Üí costo_materia_prima (√∫ltima fecha global)');
    
    -- PASO 1: CREAR TABLA DE VERSIONES CON SUS FECHAS ESPEC√çFICAS
    RAISE NOTICE '';
    RAISE NOTICE '%', format('Paso 1: Identificando versiones y sus fechas m√°s recientes...');
    
    DROP TABLE IF EXISTS versiones_fecha;
    CREATE TEMP TABLE versiones_fecha (
        version_calculo VARCHAR(50),
        fecha_corrida TIMESTAMPTZ,
        registros INTEGER,
        ops_unicas INTEGER
    );
    
    INSERT INTO versiones_fecha
    SELECT 
        version_calculo,
        MAX(fecha_corrida) as fecha_corrida,
        SUM(registros) as registros,
        SUM(ops_unicas) as ops_unicas
    FROM (
        SELECT 
            version_calculo,
            fecha_corrida,
            COUNT(*) as registros,
            COUNT(DISTINCT pr_id) as ops_unicas
        FROM silver.costo_wip_op
        WHERE version_calculo IN ('FLUIDA', 'truncado')  -- SOLO LAS DOS METODOLOG√çAS
        GROUP BY version_calculo, fecha_corrida
    ) x
    GROUP BY version_calculo;
    
    SELECT COUNT(*) INTO count_versiones FROM versiones_fecha;
    
    RAISE NOTICE '%', format('   Versiones encontradas: %s', count_versiones);
    
    -- Mostrar versiones detectadas
    FOR rec IN 
        SELECT 
            'VERSION_DETECTADA' as tipo,
            version_calculo,
            fecha_corrida,
            registros as registros_wip,
            ops_unicas as ops_procesadas
        FROM versiones_fecha
        ORDER BY fecha_corrida DESC, version_calculo
    LOOP
        RAISE NOTICE '%', format('   VERSION: %s, FECHA: %s, REGISTROS: %s, OPS: %s', 
                                rec.version_calculo, rec.fecha_corrida, rec.registros_wip, rec.ops_procesadas);
    END LOOP;
    
    -- PASO 2: Verificar fechas de otras fuentes
    SELECT COUNT(*), MAX(fecha_corrida) INTO count_avios, fecha_avios FROM silver.costo_avios;
    SELECT COUNT(*), MAX(fecha_corrida) INTO count_mp, fecha_mp FROM silver.costo_materia_prima;
    
    RAISE NOTICE '%', format('   COSTO_AVIOS: %s registros, √∫ltima fecha: %s', 
                            count_avios, COALESCE(fecha_avios::TEXT, 'N/A'));
    RAISE NOTICE '%', format('   COSTO_MATERIA_PRIMA: %s registros, √∫ltima fecha: %s', 
                            count_mp, COALESCE(fecha_mp::TEXT, 'N/A'));
    
    -- PASO 3: Agregar datos WIP por OP y VERSION con FECHAS ESPEC√çFICAS
    RAISE NOTICE '';
    RAISE NOTICE '%', format('Paso 2: Agregando datos WIP por OP y VERSION (con fechas espec√≠ficas)...');
    
    DROP TABLE IF EXISTS wip_agregado;
    CREATE TEMP TABLE wip_agregado (
        pr_id VARCHAR(50),
        version_calculo VARCHAR(50),
        costo_manufactura DECIMAL(18,4),
        costo_textil DECIMAL(18,4),
        costo_indirecto_fijo DECIMAL(18,4),
        gasto_administracion DECIMAL(18,4),
        gasto_ventas DECIMAL(18,4),
        PRIMARY KEY (pr_id, version_calculo)
    );
    
    -- CORRECCI√ìN CLAVE: Usar tabla de versiones_fecha para filtro correcto
    INSERT INTO wip_agregado
    SELECT 
        wip.pr_id,
        wip.version_calculo,
        SUM(COALESCE(wip.costo_manufactura, 0)) as costo_manufactura,
        SUM(COALESCE(wip.costo_textil, 0)) as costo_textil,
        SUM(COALESCE(wip.costo_indirecto_fijo, 0)) as costo_indirecto_fijo,
        SUM(COALESCE(wip.gasto_administracion, 0)) as gasto_administracion,
        SUM(COALESCE(wip.gasto_ventas, 0)) as gasto_ventas
    FROM silver.costo_wip_op wip
    INNER JOIN versiones_fecha vf 
        ON wip.version_calculo::text = vf.version_calculo::text
        AND wip.fecha_corrida = vf.fecha_corrida  -- FECHA ESPEC√çFICA POR VERSI√ìN
    WHERE wip.pr_id IS NOT NULL
    GROUP BY wip.pr_id, wip.version_calculo;
    
    GET DIAGNOSTICS registros_wip_total = ROW_COUNT;
    RAISE NOTICE '%', format('   WIP agregado por OP+VERSION (fechas espec√≠ficas): %s registros √∫nicos', registros_wip_total);
    
    -- MOSTRAR CONTEO POR VERSION
    IF debug = 1 THEN
        RAISE NOTICE '%', format('   Distribuci√≥n por versi√≥n:');
        
        FOR rec IN
            SELECT 
                'DEBUG_VERSION' as tipo,
                version_calculo,
                COUNT(*) as ops_procesadas,
                ROUND(SUM(costo_manufactura + costo_textil)::NUMERIC, 2) as total_costos_directos,
                ROUND(SUM(costo_indirecto_fijo + gasto_administracion + gasto_ventas)::NUMERIC, 2) as total_costos_indirectos
            FROM wip_agregado
            GROUP BY version_calculo
            ORDER BY version_calculo
        LOOP
            RAISE NOTICE '%', format('     %s: %s OPs, Directos: %s, Indirectos: %s', 
                                    rec.version_calculo, rec.ops_procesadas, rec.total_costos_directos, rec.total_costos_indirectos);
        END LOOP;
    END IF;
    
    -- MODO CONSULTA (0)
    IF modo = 0 THEN
        RAISE NOTICE '';
        RAISE NOTICE '%', format('MODO CONSULTA - Integraci√≥n MULTI-VERSIONES CORREGIDA SIN GUARDAR');
        RAISE NOTICE '%', format('================================================================================');
        
        -- Mostrar resultado de integraci√≥n POR VERSION (TOP 20)
        RAISE NOTICE '%', format('PREVIEW de registros que se insertar√≠an (TOP 20):');
        
        FOR rec IN
            SELECT 
                -- DATOS B√ÅSICOS
                bf.cod_ordpro as cod_ordpro,
                wip.version_calculo,
                bf.estilo_propio as estilo_propio,
                bf.cliente as cliente,
                bf.tipo_de_producto as tipo_de_producto,
                bf.familia_de_productos as familia_de_productos,
                bf.temporada as temporada,
                
                -- CANTIDADES Y FACTURACI√ìN
                COALESCE(bf.prendas_requeridas, 0) as prendas_requeridas,
                COALESCE(bf.monto_factura, 0) as monto_factura,
                bf.fecha_facturacion as fecha_facturacion,
                
                -- COSTOS WIP POR VERSION
                wip.costo_manufactura as costo_manufactura,
                wip.costo_textil as costo_textil,
                
                -- COSTOS INDIRECTOS POR VERSION
                wip.costo_indirecto_fijo as costo_indirecto_fijo,
                wip.gasto_administracion as gasto_administracion,
                wip.gasto_ventas as gasto_ventas,
                
                -- COSTOS MATERIALES
                COALESCE(av.costo_avios, 0) as costo_avios,
                COALESCE(mp.costo_total_mp_final, 0) as costo_materia_prima,
                
                -- Total por registro
                (wip.costo_manufactura + wip.costo_textil + 
                 wip.costo_indirecto_fijo + wip.gasto_administracion + 
                 wip.gasto_ventas + COALESCE(av.costo_avios, 0) + 
                 COALESCE(mp.costo_total_mp_final, 0))::DECIMAL(18,4) as costo_total
                
            FROM silver.bd_finanzas bf
            -- CROSS JOIN con versiones disponibles
            CROSS JOIN versiones_fecha versiones
            -- INNER JOIN: Solo OPs que tienen datos WIP
            INNER JOIN wip_agregado wip ON bf.cod_ordpro::text = wip.pr_id::text AND versiones.version_calculo::text = wip.version_calculo::text
            -- LEFT JOIN ANTI-INFLACI√ìN EN AV√çOS (con alias espec√≠fico)
            LEFT JOIN (
                SELECT op_codigo, imp_valorizado_neto_total as costo_avios
                FROM silver.costo_avios av_inner
                WHERE av_inner.fecha_corrida = COALESCE(fecha_avios, '1900-01-01'::TIMESTAMPTZ)
            ) av ON bf.cod_ordpro::text = av.op_codigo::text
            -- LEFT JOIN ANTI-INFLACI√ìN EN MATERIA PRIMA (con alias espec√≠fico)
            LEFT JOIN (
                SELECT op_codigo, costo_total_mp_final
                FROM silver.costo_materia_prima mp_inner 
                WHERE mp_inner.fecha_corrida = COALESCE(fecha_mp, '1900-01-01'::TIMESTAMPTZ)
            ) mp ON bf.cod_ordpro::text = mp.op_codigo::text
            
            WHERE bf.activo IS true
              AND bf.cod_ordpro IS NOT NULL
            ORDER BY bf.cod_ordpro, versiones.version_calculo
            LIMIT 20
        LOOP
            RAISE NOTICE '%', format('   %s [%s]: %s (%s) - Total: %s USD', 
                                    rec.cod_ordpro, rec.version_calculo, rec.estilo_propio, rec.cliente, 
                                    ROUND(rec.costo_total::NUMERIC, 2));
        END LOOP;
        
        -- Estad√≠sticas de consulta POR VERSION
        RAISE NOTICE '';
        RAISE NOTICE '%', format('ESTAD√çSTICAS DE CONSULTA CORREGIDAS POR VERSION:');
        
        FOR rec IN
            SELECT 
                versiones.version_calculo,
                COUNT(*) as total_ops,
                COUNT(*) as con_costos_wip,  -- Todos tienen costos WIP (INNER JOIN)
                ROUND(SUM(wip.costo_manufactura + wip.costo_textil)::NUMERIC, 2) as total_costo_directo,
                ROUND(SUM(wip.costo_indirecto_fijo + wip.gasto_administracion + wip.gasto_ventas)::NUMERIC, 2) as total_costo_indirecto,
                ROUND(SUM(COALESCE(av.costo_avios, 0) + COALESCE(mp.costo_total_mp_final, 0))::NUMERIC, 2) as total_materiales
            FROM silver.bd_finanzas bf
            CROSS JOIN versiones_fecha versiones
            INNER JOIN wip_agregado wip ON bf.cod_ordpro::text = wip.pr_id::text AND versiones.version_calculo::text = wip.version_calculo::text
            LEFT JOIN (
                SELECT op_codigo, imp_valorizado_neto_total as costo_avios
                FROM silver.costo_avios av_inner
                WHERE av_inner.fecha_corrida = COALESCE(fecha_avios, '1900-01-01'::TIMESTAMPTZ)
            ) av ON bf.cod_ordpro::text = av.op_codigo::text
            LEFT JOIN (
                SELECT op_codigo, costo_total_mp_final
                FROM silver.costo_materia_prima mp_inner 
                WHERE mp_inner.fecha_corrida = COALESCE(fecha_mp, '1900-01-01'::TIMESTAMPTZ)
            ) mp ON bf.cod_ordpro::text = mp.op_codigo::text
            WHERE bf.activo IS true AND bf.cod_ordpro IS NOT NULL
            GROUP BY versiones.version_calculo
            ORDER BY versiones.version_calculo
        LOOP
            RAISE NOTICE '%', format('   %s: %s OPs, Directos: %s, Indirectos: %s, Materiales: %s, Gran Total: %s', 
                                    rec.version_calculo, rec.total_ops, rec.total_costo_directo, 
                                    rec.total_costo_indirecto, rec.total_materiales, 
                                    ROUND((rec.total_costo_directo + rec.total_costo_indirecto + rec.total_materiales)::NUMERIC, 2));
        END LOOP;
        
        RAISE NOTICE '%', format('   Fecha_corrida que se asignar√≠a: %s', sp_fecha_corrida);
        RAISE NOTICE '%', format('   CORRECCI√ìN APLICADA: Cada versi√≥n usa su fecha m√°s reciente espec√≠fica');
    END IF;
    
    -- MODO GUARDAR (1)
    IF modo = 1 THEN
        RAISE NOTICE '';
        RAISE NOTICE '%', format('MODO GUARDAR - Ejecutando inserci√≥n MULTI-VERSIONES CORREGIDA');
        RAISE NOTICE '%', format('   LOGICA HIST√ìRICA: Solo INSERT (acumula datos por fecha_corrida)');
        RAISE NOTICE '%', format('   PROCESANDO: Solo OPs con costos WIP en %s versiones', count_versiones);
        
        -- Verificar si ya existen datos para esta fecha
        SELECT COUNT(*) INTO registros_existentes
        FROM silver.costo_op_detalle 
        WHERE fecha_corrida::DATE = sp_fecha_corrida::DATE;
        
        IF registros_existentes > 0 THEN
            RAISE NOTICE '%', format('   Ya existen %s registros para hoy', registros_existentes);
            RAISE NOTICE '%', format('   Agregando datos adicionales (l√≥gica hist√≥rica)');
        END IF;
        
        -- INSERT CORREGIDO CON ESTRUCTURA MULTI-VERSIONES
        INSERT INTO silver.costo_op_detalle (
            cod_ordpro, estilo_propio, cliente, tipo_de_producto, familia_de_productos, temporada,
            prendas_requeridas, monto_factura, fecha_facturacion,
            costo_manufactura, costo_textil,
            costo_indirecto_fijo, gasto_administracion, gasto_ventas,
            costo_avios, costo_materia_prima,
            pre_unitario, lote_estilo_kg, diversidad_familias, diversidad_estilos,
            esfuerzo_textil, esfuerzo_manufactura, esfuerzo_total, indice_complejidad,
            version_calculo, fecha_corrida
        )
        SELECT 
            -- DATOS B√ÅSICOS (6)
            bf.cod_ordpro as cod_ordpro,
            bf.estilo_propio as estilo_propio,
            bf.cliente as cliente,
            bf.tipo_de_producto as tipo_de_producto,
            bf.familia_de_productos as familia_de_productos,
            bf.temporada as temporada,
            
            -- CANTIDADES Y FACTURACI√ìN (3)
            COALESCE(bf.prendas_requeridas, 0) as prendas_requeridas,
            COALESCE(bf.monto_factura, 0) as monto_factura,
            bf.fecha_facturacion as fecha_facturacion,
            
            -- COSTOS WIP POR VERSION (2) - Ya no NULL por INNER JOIN
            wip.costo_manufactura as costo_manufactura,
            wip.costo_textil as costo_textil,
            
            -- COSTOS INDIRECTOS POR VERSION (3) - Ya no NULL por INNER JOIN
            wip.costo_indirecto_fijo as costo_indirecto_fijo,
            wip.gasto_administracion as gasto_administracion,
            wip.gasto_ventas as gasto_ventas,
            
            -- COSTOS MATERIALES (2)
            COALESCE(av.costo_avios, 0) as costo_avios,
            COALESCE(mp.costo_total_mp_final, 0) as costo_materia_prima,
            
            -- Variables avanzadas (valores default - se calculan despu√©s)
            0 as pre_unitario,
            0 as lote_estilo_kg,
            0 as diversidad_familias,
            0 as diversidad_estilos,
            1 as esfuerzo_textil,
            1 as esfuerzo_manufactura,
            2 as esfuerzo_total,
            NULL as indice_complejidad,
            
            -- METADATA DE AUDITOR√çA
            versiones.version_calculo,
            sp_fecha_corrida
            
        FROM silver.bd_finanzas bf
        -- CROSS JOIN con versiones disponibles
        CROSS JOIN versiones_fecha versiones
        -- INNER JOIN: Solo OPs que tienen datos WIP
        INNER JOIN wip_agregado wip ON bf.cod_ordpro::text = wip.pr_id::text AND versiones.version_calculo::text = wip.version_calculo::text
        -- LEFT JOIN ANTI-INFLACI√ìN EN AV√çOS (con alias espec√≠fico)
        LEFT JOIN (
            SELECT op_codigo, imp_valorizado_neto_total as costo_avios
            FROM silver.costo_avios av_inner
            WHERE av_inner.fecha_corrida = COALESCE(fecha_avios, '1900-01-01'::TIMESTAMPTZ)
        ) av ON bf.cod_ordpro::text = av.op_codigo::text
        -- LEFT JOIN ANTI-INFLACI√ìN EN MATERIA PRIMA (con alias espec√≠fico)
        LEFT JOIN (
            SELECT op_codigo, costo_total_mp_final
            FROM silver.costo_materia_prima mp_inner 
            WHERE mp_inner.fecha_corrida = COALESCE(fecha_mp, '1900-01-01'::TIMESTAMPTZ)
        ) mp ON bf.cod_ordpro::text = mp.op_codigo::text
        
        WHERE bf.activo IS true
          AND bf.cod_ordpro IS NOT NULL;
        
        GET DIAGNOSTICS rows_inserted = ROW_COUNT;
        
        -- Estad√≠sticas finales POR VERSION
        RAISE NOTICE '%', format('   Total registros insertados: %s', rows_inserted);
        RAISE NOTICE '';
        RAISE NOTICE '%', format('ESTAD√çSTICAS FINALES POR VERSION:');
        
        FOR rec IN
            SELECT 
                version_calculo,
                COUNT(*) as registros_insertados,
                ROUND(AVG(costo_manufactura + costo_textil + costo_indirecto_fijo + 
                    gasto_administracion + gasto_ventas + costo_avios + costo_materia_prima)::NUMERIC, 2) as costo_promedio_total,
                SUM(CASE WHEN (costo_manufactura > 0 OR costo_textil > 0 OR costo_avios > 0 OR costo_materia_prima > 0) THEN 1 ELSE 0 END) as con_costos_validos
            FROM silver.costo_op_detalle
            WHERE fecha_corrida = sp_fecha_corrida
              AND version_calculo IS NOT NULL
            GROUP BY version_calculo
            ORDER BY version_calculo
        LOOP
            RAISE NOTICE '%', format('   %s: %s registros, Costo Promedio: %s USD, Con Costos V√°lidos: %s', 
                                    rec.version_calculo, rec.registros_insertados, rec.costo_promedio_total, rec.con_costos_validos);
        END LOOP;
        
        SELECT COUNT(*) INTO total_registros_tabla FROM silver.costo_op_detalle;
        
        RAISE NOTICE '';
        RAISE NOTICE '%', format('   Total registros en tabla: %s', total_registros_tabla);
        RAISE NOTICE '%', format('   Fecha corrida: %s', sp_fecha_corrida);
        RAISE NOTICE '';
        RAISE NOTICE '%', format('   CORRECCI√ìN APLICADA:');
        RAISE NOTICE '%', format('     ‚Ä¢ FILTRO INTELIGENTE: Solo OPs con costos WIP (no registros vac√≠os)');
        RAISE NOTICE '%', format('     ‚Ä¢ FECHAS ESPEC√çFICAS: Cada versi√≥n usa su fecha m√°s reciente');
        RAISE NOTICE '%', format('     ‚Ä¢ MULTI-VERSIONES: Procesamiento autom√°tico de TODAS las versiones');
        RAISE NOTICE '%', format('     ‚Ä¢ ANTI-INFLACI√ìN: Solo √∫ltima fecha_corrida de cada fuente');
        RAISE NOTICE '%', format('     ‚Ä¢ Estructura: 26 columnas (incluye version_calculo)');
        RAISE NOTICE '%', format('     ‚Ä¢ Comparabilidad: Datos para an√°lisis A/B entre metodolog√≠as');
        RAISE NOTICE '';
        RAISE NOTICE '%', format('COSTO_OP_DETALLE MULTI-VERSIONES CORREGIDO E INTEGRADO EXITOSAMENTE');
        RAISE NOTICE '%', format('TABLA LISTA PARA C√ÅLCULO DE VARIABLES AVANZADAS POR VERSION');
    END IF;
    
    -- Limpiar tablas temporales
    DROP TABLE IF EXISTS wip_agregado;
    DROP TABLE IF EXISTS versiones_fecha;
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE '%', format('ERROR en silver.populate_costo_op_detalle: %s', error_message);
        
        -- Limpiar tablas temporales en caso de error
        DROP TABLE IF EXISTS wip_agregado;
        DROP TABLE IF EXISTS versiones_fecha;
        
        RAISE EXCEPTION '%', error_message;
END;
$procedure$

-------------------------------------------------------------------------------------

19. =====================================================================================
NOMBRE: populate_costo_op_detalle_v2
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0, IN debug integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.populate_costo_op_detalle_v2(IN modo integer DEFAULT 0, IN debug integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    rows_inserted INTEGER := 0;
    sp_fecha_corrida TIMESTAMPTZ := NOW();
    
    -- Variables para verificaciones
    count_versiones INTEGER;
    count_avios INTEGER;
    count_mp INTEGER;
    fecha_avios TIMESTAMPTZ;
    fecha_mp TIMESTAMPTZ;
    registros_wip_total INTEGER;
    registros_existentes INTEGER;
    total_registros_tabla INTEGER;
    count_tarifas INTEGER;
    
    -- Variable para record de versiones
    rec RECORD;
    
BEGIN
    -- Verificar prerequisitos
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle'
    ) THEN
        RAISE EXCEPTION 'ERROR: Tabla costo_op_detalle no existe. SOLUCION: Crear primero la tabla costo_op_detalle';
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'silver' AND table_name = 'bd_finanzas'
    ) THEN
        RAISE EXCEPTION 'Prerequisito faltante: tabla bd_finanzas';
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'silver' AND table_name = 'costo_wip_op'
    ) THEN
        RAISE EXCEPTION 'Prerequisito faltante: tabla costo_wip_op';
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'silver' AND table_name = 'costos_fijos_mensuales'
    ) THEN
        RAISE EXCEPTION 'Prerequisito faltante: tabla costos_fijos_mensuales';
    END IF;
    
    -- Verificar si existe columna version_calculo
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' 
        AND column_name = 'version_calculo'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN version_calculo VARCHAR(50) DEFAULT NULL;
        RAISE NOTICE '%', format('Columna version_calculo agregada a costo_op_detalle');
    END IF;
    
    RAISE NOTICE '%', format('INICIANDO INTEGRACI√ìN COSTO_OP_DETALLE [COSTOS INDIRECTOS UNITARIOS]...');
    RAISE NOTICE '%', format('   Fecha corrida: %s', sp_fecha_corrida);
    RAISE NOTICE '%', format('   LOGICA HIST√ìRICA: Solo INSERT (acumula datos)');
    RAISE NOTICE '%', format('   ANTI-INFLACI√ìN: √öltima fecha_corrida POR CADA versi√≥n');
    RAISE NOTICE '%', format('   MULTI-VERSIONES: TODAS las OPs √ó TODAS las versiones');
    RAISE NOTICE '%', format('   NUEVA METODOLOG√çA: Costos indirectos UNITARIOS ($/prenda)');
    RAISE NOTICE '';
    RAISE NOTICE '%', format('FUENTES A INTEGRAR:');
    RAISE NOTICE '%', format('   1 bd_finanzas ‚Üí base + facturaci√≥n');
    RAISE NOTICE '%', format('   2 costo_wip_op ‚Üí costos WIP directos (CADA versi√≥n en su √∫ltima fecha)');
    RAISE NOTICE '%', format('   3 costo_avios ‚Üí costo_avios (√∫ltima fecha global)');
    RAISE NOTICE '%', format('   4 costo_materia_prima ‚Üí costo_materia_prima (√∫ltima fecha global)');
    RAISE NOTICE '%', format('   5 costos_fijos_mensuales ‚Üí bolsas anuales');
    RAISE NOTICE '%', format('   6 cn_ventas ‚Üí prendas facturadas reales');
    
    -- PASO 1: CREAR TABLA DE VERSIONES CON SUS FECHAS ESPEC√çFICAS
    RAISE NOTICE '';
    RAISE NOTICE '%', format('Paso 1: Identificando versiones y sus fechas m√°s recientes...');
    
    DROP TABLE IF EXISTS versiones_fecha;
    CREATE TEMP TABLE versiones_fecha (
        version_calculo VARCHAR(50),
        fecha_corrida TIMESTAMPTZ,
        registros INTEGER,
        ops_unicas INTEGER
    );
    
    INSERT INTO versiones_fecha
    SELECT 
        version_calculo,
        MAX(fecha_corrida) as fecha_corrida,
        SUM(registros) as registros,
        SUM(ops_unicas) as ops_unicas
    FROM (
        SELECT 
            version_calculo,
            fecha_corrida,
            COUNT(*) as registros,
            COUNT(DISTINCT pr_id) as ops_unicas
        FROM silver.costo_wip_op
        WHERE version_calculo IN ('FLUIDA', 'truncado')  -- SOLO LAS DOS METODOLOG√çAS
        GROUP BY version_calculo, fecha_corrida
    ) x
    GROUP BY version_calculo;
    
    SELECT COUNT(*) INTO count_versiones FROM versiones_fecha;
    
    RAISE NOTICE '%', format('   Versiones encontradas: %s', count_versiones);
    
    -- Mostrar versiones detectadas
    FOR rec IN 
        SELECT 
            'VERSION_DETECTADA' as tipo,
            version_calculo,
            fecha_corrida,
            registros as registros_wip,
            ops_unicas as ops_procesadas
        FROM versiones_fecha
        ORDER BY fecha_corrida DESC, version_calculo
    LOOP
        RAISE NOTICE '%', format('   VERSION: %s, FECHA: %s, REGISTROS: %s, OPS: %s', 
                                rec.version_calculo, rec.fecha_corrida, rec.registros_wip, rec.ops_procesadas);
    END LOOP;
    
    -- PASO 1.5: CALCULAR TARIFAS UNITARIAS POR A√ëO USANDO CN_VENTAS
    RAISE NOTICE '';
    RAISE NOTICE '%', format('Paso 1.5: Calculando tarifas unitarias por a√±o desde CN_VENTAS...');
    
    DROP TABLE IF EXISTS tarifas_por_a√±o;
    CREATE TEMP TABLE tarifas_por_a√±o (
        a√±o INTEGER,
        bolsa_cif DECIMAL(18,4),
        bolsa_administracion DECIMAL(18,4),
        bolsa_ventas DECIMAL(18,4),
        total_prendas_a√±o DECIMAL(18,4),
        tarifa_cif_unitaria DECIMAL(10,6),
        tarifa_admin_unitaria DECIMAL(10,6),
        tarifa_ventas_unitaria DECIMAL(10,6),
        PRIMARY KEY (a√±o)
    );
    
    -- Calcular bolsas y tarifas por a√±o
    WITH bolsas_anuales AS (
        SELECT 
            a√±o,
            SUM(CASE WHEN tipo_costo = 'Costo Indirecto Fijo' THEN costo_total_usd ELSE 0 END) as bolsa_cif,
            SUM(CASE WHEN tipo_costo = 'Gasto de Administraci√≥n' THEN costo_total_usd ELSE 0 END) as bolsa_admin,
            SUM(CASE WHEN tipo_costo = 'Gasto de Ventas' THEN costo_total_usd ELSE 0 END) as bolsa_ventas
        FROM silver.costos_fijos_mensuales
        WHERE proceso_productivo IN ('Textil', 'Manufactura')
          AND tipo_costo IN ('Costo Indirecto Fijo', 'Gasto de Administraci√≥n', 'Gasto de Ventas')
        GROUP BY a√±o
    ),
    prendas_por_a√±o AS (
        SELECT 
            EXTRACT(YEAR FROM cn.fec_emidoc)::INTEGER as a√±o,
            SUM(cn_prenda.num_prendas) as total_prendas
        FROM bronze.cn_ventas cn
        INNER JOIN bronze.cn_ventas_prendas cn_prenda
            ON cn.num_corre = cn_prenda.num_corre
        WHERE cn.fec_emidoc IS NOT NULL
        GROUP BY EXTRACT(YEAR FROM cn.fec_emidoc)::INTEGER
    )
    INSERT INTO tarifas_por_a√±o
    SELECT 
        ba.a√±o,
        ba.bolsa_cif,
        ba.bolsa_admin,
        ba.bolsa_ventas,
        COALESCE(pa.total_prendas, 0) as total_prendas,
        CASE WHEN COALESCE(pa.total_prendas, 0) > 0 THEN ba.bolsa_cif / pa.total_prendas ELSE 0 END,
        CASE WHEN COALESCE(pa.total_prendas, 0) > 0 THEN ba.bolsa_admin / pa.total_prendas ELSE 0 END,
        CASE WHEN COALESCE(pa.total_prendas, 0) > 0 THEN ba.bolsa_ventas / pa.total_prendas ELSE 0 END
    FROM bolsas_anuales ba
    LEFT JOIN prendas_por_a√±o pa ON ba.a√±o = pa.a√±o;
    
    SELECT COUNT(*) INTO count_tarifas FROM tarifas_por_a√±o;
    
    RAISE NOTICE '%', format('   Tarifas calculadas para %s a√±os:', count_tarifas);
    
    -- Mostrar tarifas calculadas
    FOR rec IN 
        SELECT 
            a√±o,
            bolsa_cif,
            bolsa_administracion,
            bolsa_ventas,
            total_prendas_a√±o,
            tarifa_cif_unitaria,
            tarifa_admin_unitaria,
            tarifa_ventas_unitaria
        FROM tarifas_por_a√±o
        ORDER BY a√±o DESC
    LOOP
        RAISE NOTICE '%', format('   A√ëO %s: Prendas=%s, CIF=$%s/u, Admin=$%s/u, Ventas=$%s/u', 
                                rec.a√±o, 
                                ROUND(rec.total_prendas_a√±o::NUMERIC, 0),
                                ROUND(rec.tarifa_cif_unitaria::NUMERIC, 6),
                                ROUND(rec.tarifa_admin_unitaria::NUMERIC, 6),
                                ROUND(rec.tarifa_ventas_unitaria::NUMERIC, 6));
    END LOOP;
    
    -- PASO 2: Verificar fechas de otras fuentes
    SELECT COUNT(*), MAX(fecha_corrida) INTO count_avios, fecha_avios FROM silver.costo_avios;
    SELECT COUNT(*), MAX(fecha_corrida) INTO count_mp, fecha_mp FROM silver.costo_materia_prima;
    
    RAISE NOTICE '';
    RAISE NOTICE '%', format('Paso 2: Verificando fuentes adicionales...');
    RAISE NOTICE '%', format('   COSTO_AVIOS: %s registros, √∫ltima fecha: %s', 
                            count_avios, COALESCE(fecha_avios::TEXT, 'N/A'));
    RAISE NOTICE '%', format('   COSTO_MATERIA_PRIMA: %s registros, √∫ltima fecha: %s', 
                            count_mp, COALESCE(fecha_mp::TEXT, 'N/A'));
    
    -- PASO 3: Agregar datos WIP por OP y VERSION con FECHAS ESPEC√çFICAS (SOLO COSTOS DIRECTOS)
    RAISE NOTICE '';
    RAISE NOTICE '%', format('Paso 3: Agregando datos WIP por OP y VERSION (solo costos directos)...');
    
    DROP TABLE IF EXISTS wip_agregado;
    CREATE TEMP TABLE wip_agregado (
        pr_id VARCHAR(50),
        version_calculo VARCHAR(50),
        costo_manufactura DECIMAL(18,4),
        costo_textil DECIMAL(18,4),
        PRIMARY KEY (pr_id, version_calculo)
    );
    
    -- CORRECCI√ìN: Solo costos directos de WIP (manufactura y textil)
    INSERT INTO wip_agregado
    SELECT 
        wip.pr_id,
        wip.version_calculo,
        SUM(COALESCE(wip.costo_manufactura, 0)) as costo_manufactura,
        SUM(COALESCE(wip.costo_textil, 0)) as costo_textil
    FROM silver.costo_wip_op wip
    INNER JOIN versiones_fecha vf 
        ON wip.version_calculo::text = vf.version_calculo::text
        AND wip.fecha_corrida = vf.fecha_corrida  -- FECHA ESPEC√çFICA POR VERSI√ìN
    WHERE wip.pr_id IS NOT NULL
    GROUP BY wip.pr_id, wip.version_calculo;
    
    GET DIAGNOSTICS registros_wip_total = ROW_COUNT;
    RAISE NOTICE '%', format('   WIP agregado por OP+VERSION (fechas espec√≠ficas): %s registros √∫nicos', registros_wip_total);
    
    -- MOSTRAR CONTEO POR VERSION
    IF debug = 1 THEN
        RAISE NOTICE '%', format('   Distribuci√≥n por versi√≥n:');
        
        FOR rec IN
            SELECT 
                'DEBUG_VERSION' as tipo,
                version_calculo,
                COUNT(*) as ops_procesadas,
                ROUND(SUM(costo_manufactura + costo_textil)::NUMERIC, 2) as total_costos_directos
            FROM wip_agregado
            GROUP BY version_calculo
            ORDER BY version_calculo
        LOOP
            RAISE NOTICE '%', format('     %s: %s OPs, Costos Directos WIP: %s', 
                                    rec.version_calculo, rec.ops_procesadas, rec.total_costos_directos);
        END LOOP;
    END IF;
    
    -- MODO CONSULTA (0)
    IF modo = 0 THEN
        RAISE NOTICE '';
        RAISE NOTICE '%', format('MODO CONSULTA - COSTOS INDIRECTOS UNITARIOS ($/PRENDA) SIN GUARDAR');
        RAISE NOTICE '%', format('================================================================================');
        
        -- Mostrar resultado de integraci√≥n POR VERSION (TOP 20)
        RAISE NOTICE '%', format('PREVIEW de registros que se insertar√≠an (TOP 20):');
        
        FOR rec IN
            SELECT 
                -- DATOS B√ÅSICOS
                bf.cod_ordpro as cod_ordpro,
                versiones.version_calculo,
                bf.estilo_propio as estilo_propio,
                bf.cliente as cliente,
                EXTRACT(YEAR FROM bf.fecha_facturacion)::INTEGER as a√±o_facturacion,
                
                -- CANTIDADES Y FACTURACI√ìN
                COALESCE(bf.prendas_requeridas, 0) as prendas_requeridas,
                
                -- COSTOS WIP POR VERSION (DIRECTOS - TOTALES) - PUEDE SER NULL
                COALESCE(wip.costo_manufactura, 0) as costo_manufactura,
                COALESCE(wip.costo_textil, 0) as costo_textil,
                
                -- COSTOS INDIRECTOS UNITARIOS ($/PRENDA) ‚≠ê
                COALESCE(tf.tarifa_cif_unitaria, 0) as costo_indirecto_fijo_unitario,
                COALESCE(tf.tarifa_admin_unitaria, 0) as gasto_administracion_unitario,
                COALESCE(tf.tarifa_ventas_unitaria, 0) as gasto_ventas_unitario,
                
                -- COSTOS MATERIALES (TOTALES)
                COALESCE(av.costo_avios, 0) as costo_avios,
                COALESCE(mp.costo_total_mp_final, 0) as costo_materia_prima,
                
                -- Total estimado (usando unitarios √ó prendas)
                (COALESCE(wip.costo_manufactura, 0) + COALESCE(wip.costo_textil, 0) + 
                 (COALESCE(tf.tarifa_cif_unitaria, 0) * bf.prendas_requeridas) +
                 (COALESCE(tf.tarifa_admin_unitaria, 0) * bf.prendas_requeridas) +
                 (COALESCE(tf.tarifa_ventas_unitaria, 0) * bf.prendas_requeridas) +
                 COALESCE(av.costo_avios, 0) + 
                 COALESCE(mp.costo_total_mp_final, 0))::DECIMAL(18,4) as costo_total_estimado
                
            FROM silver.bd_finanzas bf
            -- CROSS JOIN: TODAS las versiones √ó TODAS las OPs
            CROSS JOIN versiones_fecha versiones
            -- ‚≠ê LEFT JOIN: TODAS las OPs reciben c√°lculo, tengan o no WIP
            LEFT JOIN wip_agregado wip 
                ON bf.cod_ordpro::text = wip.pr_id::text 
                AND versiones.version_calculo::text = wip.version_calculo::text
            -- LEFT JOIN CON TARIFAS POR A√ëO
            LEFT JOIN tarifas_por_a√±o tf 
                ON EXTRACT(YEAR FROM bf.fecha_facturacion)::INTEGER = tf.a√±o
            -- LEFT JOIN ANTI-INFLACI√ìN EN AV√çOS
            LEFT JOIN (
                SELECT op_codigo, imp_valorizado_neto_total as costo_avios
                FROM silver.costo_avios av_inner
                WHERE av_inner.fecha_corrida = COALESCE(fecha_avios, '1900-01-01'::TIMESTAMPTZ)
            ) av ON bf.cod_ordpro::text = av.op_codigo::text
            -- LEFT JOIN ANTI-INFLACI√ìN EN MATERIA PRIMA
            LEFT JOIN (
                SELECT op_codigo, costo_total_mp_final
                FROM silver.costo_materia_prima mp_inner 
                WHERE mp_inner.fecha_corrida = COALESCE(fecha_mp, '1900-01-01'::TIMESTAMPTZ)
            ) mp ON bf.cod_ordpro::text = mp.op_codigo::text
            
            WHERE bf.activo IS true
              AND bf.cod_ordpro IS NOT NULL
            ORDER BY bf.cod_ordpro, versiones.version_calculo
            LIMIT 20
        LOOP
            RAISE NOTICE '%', format('   %s [%s] A√±o:%s: %s - Prendas:%s - Admin/u:$%s - Total Est:$%s', 
                                    rec.cod_ordpro, rec.version_calculo, rec.a√±o_facturacion,
                                    rec.cliente, rec.prendas_requeridas,
                                    ROUND(rec.gasto_administracion_unitario::NUMERIC, 6),
                                    ROUND(rec.costo_total_estimado::NUMERIC, 2));
        END LOOP;
        
        -- Estad√≠sticas de consulta POR VERSION
        RAISE NOTICE '';
        RAISE NOTICE '%', format('ESTAD√çSTICAS DE CONSULTA POR VERSION (INDIRECTOS UNITARIOS):');
        
        FOR rec IN
            SELECT 
                versiones.version_calculo,
                COUNT(*) as total_ops,
                SUM(CASE WHEN wip.pr_id IS NOT NULL THEN 1 ELSE 0 END) as ops_con_wip,
                SUM(CASE WHEN wip.pr_id IS NULL THEN 1 ELSE 0 END) as ops_sin_wip,
                ROUND(AVG(COALESCE(tf.tarifa_cif_unitaria, 0))::NUMERIC, 6) as promedio_cif_unitario,
                ROUND(AVG(COALESCE(tf.tarifa_admin_unitaria, 0))::NUMERIC, 6) as promedio_admin_unitario,
                ROUND(AVG(COALESCE(tf.tarifa_ventas_unitaria, 0))::NUMERIC, 6) as promedio_ventas_unitario,
                SUM(bf.prendas_requeridas) as total_prendas
            FROM silver.bd_finanzas bf
            CROSS JOIN versiones_fecha versiones
            LEFT JOIN wip_agregado wip 
                ON bf.cod_ordpro::text = wip.pr_id::text 
                AND versiones.version_calculo::text = wip.version_calculo::text
            LEFT JOIN tarifas_por_a√±o tf 
                ON EXTRACT(YEAR FROM bf.fecha_facturacion)::INTEGER = tf.a√±o
            WHERE bf.activo IS true AND bf.cod_ordpro IS NOT NULL
            GROUP BY versiones.version_calculo
            ORDER BY versiones.version_calculo
        LOOP
            RAISE NOTICE '%', format('   %s: %s OPs (%s con WIP, %s sin WIP), %s prendas, Prom CIF/u:$%s, Admin/u:$%s, Ventas/u:$%s', 
                                    rec.version_calculo, rec.total_ops, rec.ops_con_wip, rec.ops_sin_wip,
                                    rec.total_prendas, rec.promedio_cif_unitario, 
                                    rec.promedio_admin_unitario, rec.promedio_ventas_unitario);
        END LOOP;
        
        RAISE NOTICE '%', format('   Fecha_corrida que se asignar√≠a: %s', sp_fecha_corrida);
        RAISE NOTICE '%', format('   ‚≠ê COSTOS INDIRECTOS: Guardados como UNITARIOS ($/prenda)');
        RAISE NOTICE '%', format('   ‚≠ê BASE PRENDAS: cn_ventas (prendas facturadas reales)');
        RAISE NOTICE '%', format('   ‚≠ê COBERTURA: TODAS las OPs √ó TODAS las versiones');
    END IF;
    
    -- MODO GUARDAR (1)
    IF modo = 1 THEN
        RAISE NOTICE '';
        RAISE NOTICE '%', format('MODO GUARDAR - Insertando COSTOS INDIRECTOS UNITARIOS');
        RAISE NOTICE '%', format('   LOGICA HIST√ìRICA: Solo INSERT (acumula datos por fecha_corrida)');
        RAISE NOTICE '%', format('   PROCESANDO: TODAS las OPs √ó %s versiones', count_versiones);
        RAISE NOTICE '%', format('   INDIRECTOS: Guardados como UNITARIOS ($/prenda) de %s a√±os', count_tarifas);
        
        -- Verificar si ya existen datos para esta fecha
        SELECT COUNT(*) INTO registros_existentes
        FROM silver.costo_op_detalle 
        WHERE fecha_corrida::DATE = sp_fecha_corrida::DATE;
        
        IF registros_existentes > 0 THEN
            RAISE NOTICE '%', format('   Ya existen %s registros para hoy', registros_existentes);
            RAISE NOTICE '%', format('   Agregando datos adicionales (l√≥gica hist√≥rica)');
        END IF;
        
        -- ‚≠ê INSERT CON LEFT JOIN: TODAS LAS OPs √ó TODAS LAS VERSIONES
        INSERT INTO silver.costo_op_detalle (
            cod_ordpro, estilo_propio, cliente, tipo_de_producto, familia_de_productos, temporada,
            prendas_requeridas, monto_factura, fecha_facturacion,
            costo_manufactura, costo_textil,
            costo_indirecto_fijo, gasto_administracion, gasto_ventas,
            costo_avios, costo_materia_prima,
            pre_unitario, lote_estilo_kg, diversidad_familias, diversidad_estilos,
            esfuerzo_textil, esfuerzo_manufactura, esfuerzo_total, indice_complejidad,
            version_calculo, fecha_corrida
        )
        SELECT 
            -- DATOS B√ÅSICOS (6)
            bf.cod_ordpro as cod_ordpro,
            bf.estilo_propio as estilo_propio,
            bf.cliente as cliente,
            bf.tipo_de_producto as tipo_de_producto,
            bf.familia_de_productos as familia_de_productos,
            bf.temporada as temporada,
            
            -- CANTIDADES Y FACTURACI√ìN (3)
            COALESCE(bf.prendas_requeridas, 0) as prendas_requeridas,
            COALESCE(bf.monto_factura, 0) as monto_factura,
            bf.fecha_facturacion as fecha_facturacion,
            
            -- COSTOS WIP POR VERSION (2) - COSTOS DIRECTOS (TOTALES) - PUEDE SER NULL
            COALESCE(wip.costo_manufactura, 0) as costo_manufactura,
            COALESCE(wip.costo_textil, 0) as costo_textil,
            
            -- COSTOS INDIRECTOS UNITARIOS (3) ‚≠ê SIN MULTIPLICAR POR PRENDAS
            COALESCE(tf.tarifa_cif_unitaria, 0) as costo_indirecto_fijo,
            COALESCE(tf.tarifa_admin_unitaria, 0) as gasto_administracion,
            COALESCE(tf.tarifa_ventas_unitaria, 0) as gasto_ventas,
            
            -- COSTOS MATERIALES (2) - TOTALES
            COALESCE(av.costo_avios, 0) as costo_avios,
            COALESCE(mp.costo_total_mp_final, 0) as costo_materia_prima,
            
            -- Variables avanzadas (valores default - se calculan despu√©s)
            0 as pre_unitario,
            0 as lote_estilo_kg,
            0 as diversidad_familias,
            0 as diversidad_estilos,
            1 as esfuerzo_textil,
            1 as esfuerzo_manufactura,
            2 as esfuerzo_total,
            NULL as indice_complejidad,
            
            -- METADATA DE AUDITOR√çA
            versiones.version_calculo,
            sp_fecha_corrida
            
        FROM silver.bd_finanzas bf
        -- CROSS JOIN: TODAS las versiones √ó TODAS las OPs
        CROSS JOIN versiones_fecha versiones
        -- ‚≠ê LEFT JOIN: TODAS las OPs reciben c√°lculo, tengan o no WIP
        LEFT JOIN wip_agregado wip 
            ON bf.cod_ordpro::text = wip.pr_id::text 
            AND versiones.version_calculo::text = wip.version_calculo::text
        -- LEFT JOIN CON TARIFAS POR A√ëO
        LEFT JOIN tarifas_por_a√±o tf 
            ON EXTRACT(YEAR FROM bf.fecha_facturacion)::INTEGER = tf.a√±o
        -- LEFT JOIN ANTI-INFLACI√ìN EN AV√çOS
        LEFT JOIN (
            SELECT op_codigo, imp_valorizado_neto_total as costo_avios
            FROM silver.costo_avios av_inner
            WHERE av_inner.fecha_corrida = COALESCE(fecha_avios, '1900-01-01'::TIMESTAMPTZ)
        ) av ON bf.cod_ordpro::text = av.op_codigo::text
        -- LEFT JOIN ANTI-INFLACI√ìN EN MATERIA PRIMA
        LEFT JOIN (
            SELECT op_codigo, costo_total_mp_final
            FROM silver.costo_materia_prima mp_inner 
            WHERE mp_inner.fecha_corrida = COALESCE(fecha_mp, '1900-01-01'::TIMESTAMPTZ)
        ) mp ON bf.cod_ordpro::text = mp.op_codigo::text
        
        WHERE bf.activo IS true
          AND bf.cod_ordpro IS NOT NULL;
        
        GET DIAGNOSTICS rows_inserted = ROW_COUNT;
        
        -- Estad√≠sticas finales POR VERSION
        RAISE NOTICE '%', format('   Total registros insertados: %s', rows_inserted);
        RAISE NOTICE '';
        RAISE NOTICE '%', format('ESTAD√çSTICAS FINALES POR VERSION (INDIRECTOS UNITARIOS):');
        
        FOR rec IN
            SELECT 
                version_calculo,
                COUNT(*) as registros_insertados,
                SUM(CASE WHEN (costo_manufactura + costo_textil) > 0 THEN 1 ELSE 0 END) as ops_con_wip,
                SUM(CASE WHEN (costo_manufactura + costo_textil) = 0 THEN 1 ELSE 0 END) as ops_sin_wip,
                ROUND(AVG(costo_manufactura + costo_textil)::NUMERIC, 2) as promedio_costos_directos,
                ROUND(AVG(costo_indirecto_fijo)::NUMERIC, 6) as promedio_cif_unitario,
                ROUND(AVG(gasto_administracion)::NUMERIC, 6) as promedio_admin_unitario,
                ROUND(AVG(gasto_ventas)::NUMERIC, 6) as promedio_ventas_unitario
            FROM silver.costo_op_detalle
            WHERE fecha_corrida = sp_fecha_corrida
              AND version_calculo IS NOT NULL
            GROUP BY version_calculo
            ORDER BY version_calculo
        LOOP
            RAISE NOTICE '%', format('   %s: %s registros (%s con WIP, %s sin WIP), Directos Prom:$%s, CIF/u:$%s, Admin/u:$%s, Ventas/u:$%s', 
                                    rec.version_calculo, rec.registros_insertados, 
                                    rec.ops_con_wip, rec.ops_sin_wip,
                                    rec.promedio_costos_directos, rec.promedio_cif_unitario,
                                    rec.promedio_admin_unitario, rec.promedio_ventas_unitario);
        END LOOP;
        
        SELECT COUNT(*) INTO total_registros_tabla FROM silver.costo_op_detalle;
        
        RAISE NOTICE '';
        RAISE NOTICE '%', format('   Total registros en tabla: %s', total_registros_tabla);
        RAISE NOTICE '%', format('   Fecha corrida: %s', sp_fecha_corrida);
        RAISE NOTICE '';
        RAISE NOTICE '%', format('   ‚≠ê METODOLOG√çA APLICADA:');
        RAISE NOTICE '%', format('     ‚Ä¢ COSTOS INDIRECTOS: Guardados como UNITARIOS ($/prenda)');
        RAISE NOTICE '%', format('     ‚Ä¢ C√ÅLCULO TOTAL: costo_indirecto √ó prendas_requeridas');
        RAISE NOTICE '%', format('     ‚Ä¢ BASE TARIFAS: cn_ventas (prendas facturadas reales)');
        RAISE NOTICE '%', format('     ‚Ä¢ TEMPORALIDAD: Cada OP usa tarifas de su a√±o de facturaci√≥n');
        RAISE NOTICE '%', format('     ‚Ä¢ FUENTE BOLSAS: costos_fijos_mensuales agregado por a√±o');
        RAISE NOTICE '%', format('     ‚Ä¢ COBERTURA TOTAL: TODAS las OPs √ó TODAS las versiones');
        RAISE NOTICE '%', format('     ‚Ä¢ MULTI-VERSIONES: Procesamiento de truncado y FLUIDA simult√°neamente');
        RAISE NOTICE '';
        RAISE NOTICE '%', format('‚úÖ COSTO_OP_DETALLE INTEGRADO CON COSTOS INDIRECTOS UNITARIOS');
        RAISE NOTICE '%', format('   Para obtener total: multiplicar unitarios √ó prendas_requeridas');
    END IF;
    
    -- Limpiar tablas temporales
    DROP TABLE IF EXISTS wip_agregado;
    DROP TABLE IF EXISTS versiones_fecha;
    DROP TABLE IF EXISTS tarifas_por_a√±o;
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE '%', format('ERROR en silver.populate_costo_op_detalle: %s', error_message);
        
        -- Limpiar tablas temporales en caso de error
        DROP TABLE IF EXISTS wip_agregado;
        DROP TABLE IF EXISTS versiones_fecha;
        DROP TABLE IF EXISTS tarifas_por_a√±o;
        
        RAISE EXCEPTION '%', error_message;
END;
$procedure$

-------------------------------------------------------------------------------------

20. =====================================================================================
NOMBRE: populate_costo_wip_op
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0, IN debug integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.populate_costo_wip_op(IN modo integer DEFAULT 0, IN debug integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    fecha_corrida TIMESTAMPTZ := NOW();
    rows_inserted INTEGER := 0;
    
    -- Variables para conteos
    count_base INTEGER;
    count_final INTEGER;
    count_bd_finanzas INTEGER;
    count_actividad INTEGER;
    
    -- Variables para costos indirectos
    cif_2024 DECIMAL(18,4);
    admin_2024 DECIMAL(18,4);
    ventas_2024 DECIMAL(18,4);
    base_indirectos DECIMAL(18,4);
    
    -- Variables para totales del resumen
    total_textil_pool DECIMAL(18,4);
    total_manufactura_pool DECIMAL(18,4);
    base_textil_bd_finanzas DECIMAL(18,4);
    base_manufactura_bd_finanzas DECIMAL(18,4);
    
BEGIN
    -- =====================================================================
    -- OPTIMIZACI√ìN 1: CREAR TABLAS TEMPORALES CON √çNDICES
    -- =====================================================================
    
    -- Tabla temporal con √≠ndices para mejor rendimiento
    DROP TABLE IF EXISTS universo_base;
    CREATE TEMP TABLE universo_base (
        pr_id VARCHAR(50) NOT NULL PRIMARY KEY
    );
    
    DROP TABLE IF EXISTS universo_final;
    CREATE TEMP TABLE universo_final (
        pr_id VARCHAR(50) NOT NULL PRIMARY KEY,
        prendas_requeridas DECIMAL(18,2),
        factor_volumen DECIMAL(6,3),
        en_bd_finanzas INTEGER
    );
    
    DROP TABLE IF EXISTS actividad_wip;
    CREATE TEMP TABLE actividad_wip (
        pr_id VARCHAR(50) NOT NULL,
        wip_id VARCHAR(10),
        a√±o INTEGER,
        mes INTEGER,
        month_ TIMESTAMPTZ,
        grupo_wip VARCHAR(20),
        base_textil DECIMAL(18,4),
        base_manufactura DECIMAL(18,4),
        factor_volumen DECIMAL(6,3)
    );
    
    -- Crear √≠ndices por separado (sintaxis correcta PostgreSQL)
    CREATE INDEX ix_actividad_wip_pr_id ON actividad_wip (pr_id);
    CREATE INDEX ix_actividad_wip_grupo_a√±o_mes ON actividad_wip (grupo_wip, a√±o, mes, wip_id);
    
    DROP TABLE IF EXISTS pools_mensuales;
    CREATE TEMP TABLE pools_mensuales (
        a√±o INTEGER,
        mes_num INTEGER,
        wip_id VARCHAR(10),
        grupo VARCHAR(20),
        pool_mes DECIMAL(18,4)
    );
    
    -- Crear √≠ndice por separado
    CREATE INDEX ix_pools_a√±o_mes_grupo ON pools_mensuales (a√±o, mes_num, grupo, wip_id);
    
    -- =====================================================================
    -- OPTIMIZACI√ìN 2: PASO 1 OPTIMIZADO
    -- =====================================================================
    IF debug = 1 THEN
        RAISE NOTICE '%', format('PASO 1: Cargando universo base optimizado...');
    END IF;
    
    INSERT INTO universo_base (pr_id)
    SELECT DISTINCT pr_id
    FROM silver.wip_time_allocation
    WHERE pr_id IS NOT NULL ;
    -- AND month_ >= '2023-01-01' 
    -- AND month_ < '2025-01-01';
    
    GET DIAGNOSTICS count_base = ROW_COUNT;
    IF debug = 1 THEN
        RAISE NOTICE '%', format('   ‚úÖ %s OPs en universo base', count_base);
    END IF; 
    
    -- =====================================================================
    -- OPTIMIZACI√ìN 3: PRE-CARGAR BD_FINANZAS EN TABLA TEMPORAL
    -- =====================================================================
    DROP TABLE IF EXISTS bd_finanzas_activo;
    CREATE TEMP TABLE bd_finanzas_activo (
        cod_ordpro VARCHAR(50) NOT NULL PRIMARY KEY,
        estilo_propio VARCHAR(100),
        cliente VARCHAR(100),
        tipo_de_producto VARCHAR(100),
        familia_de_productos VARCHAR(100),
        temporada VARCHAR(50),
        prendas_requeridas DECIMAL(18,2)
    );
    
    INSERT INTO bd_finanzas_activo
    SELECT cod_ordpro, estilo_propio, cliente, tipo_de_producto, 
           familia_de_productos, temporada, prendas_requeridas
    FROM silver.bd_finanzas
    WHERE activo IS true;
    
    -- =====================================================================
    -- OPTIMIZACI√ìN 4: PASO 2 SIMPLIFICADO CON CTE
    -- =====================================================================
    IF debug = 1 THEN
        RAISE NOTICE '%', format('PASO 2: Calculando universo final optimizado...');
    END IF;
    
    -- CTE para simplificar el JOIN complejo
    WITH prendas_por_op AS (
        SELECT 
            pr.cod_ordpro as pr_id,
            SUM(COALESCE(pol.num_prereq::numeric, 0)) as prendas_requeridas
    FROM bronze.tg_purord po
	INNER JOIN bronze.tg_lotest pol
    	ON pol.cod_cliente::text = po.cod_cliente::text
   		AND pol.cod_purord::text = po.cod_purord::text
	INNER JOIN bronze.tg_lotestpro pols
    	ON pols.cod_cliente::text = pol.cod_cliente::text
   		AND pols.cod_purord::text = pol.cod_purord::text
   		AND pols.cod_lotpurord::text = pol.cod_lotpurord::text
   		AND pols.cod_estcli::text = pol.cod_estcli::text
	INNER JOIN bronze.es_ordpro pr
    	ON pr.cod_fabrica::text = pols.cod_fabrica::text
   		AND pr.cod_ordpro::text = pols.cod_ordpro::text
	INNER JOIN universo_base u ON pr.cod_ordpro::text = u.pr_id::text
    --    WHERE po.cod_clapurord = 'PO' 
    --    AND po.cod_subclapurord = 'PR'
        GROUP BY pr.cod_ordpro
    )
    INSERT INTO universo_final (pr_id, prendas_requeridas, factor_volumen, en_bd_finanzas)
    SELECT 
        ppo.pr_id,
        ppo.prendas_requeridas,
        -- Factor de volumen optimizado
        CASE 
            WHEN ppo.prendas_requeridas < 850 THEN 1.5
            WHEN ppo.prendas_requeridas < 1700 THEN 1.2
            WHEN ppo.prendas_requeridas < 5700 THEN 0.9
            WHEN ppo.prendas_requeridas >= 5700 THEN 0.8
            ELSE 1.0
        END,
        -- Verificacion optimizada con LEFT JOIN
        CASE WHEN bf.cod_ordpro IS NOT NULL THEN 1 ELSE 0 END
    FROM prendas_por_op ppo
    LEFT JOIN bd_finanzas_activo bf ON ppo.pr_id = bf.cod_ordpro;
    
    GET DIAGNOSTICS count_final = ROW_COUNT;
    SELECT COUNT(*) INTO count_bd_finanzas FROM universo_final WHERE en_bd_finanzas = 1;
    
    IF debug = 1 THEN
        RAISE NOTICE '%', format('   ‚úÖ %s OPs finales, %s en bd_finanzas', count_final, count_bd_finanzas);
    END IF;
    
    -- =====================================================================
    -- OPTIMIZACI√ìN 5: ACTIVIDAD WIP CON FILTRO TEMPRANO Y VALIDACI√ìN DE FECHAS
    -- =====================================================================
    IF debug = 1 THEN
        RAISE NOTICE '%', format('PASO 3: Cargando actividad WIP solo bd_finanzas...');
    END IF;
    
    INSERT INTO actividad_wip
    SELECT 
        wta.pr_id,
        wta.wip_id,
        EXTRACT(YEAR FROM wta.month_)::INTEGER,
        EXTRACT(MONTH FROM wta.month_)::INTEGER,
        wta.month_,
        CASE 
            WHEN wta.wip_id IN ('16', '14', '19a', '19c', '24') THEN 'textil'
            WHEN wta.wip_id IN ('34', '40', '44', '37', '45', '49') THEN 'manufactura'
            ELSE 'otro'
        END,
        COALESCE(wta.prod_kg__allocated, 0) * COALESCE(uf.factor_volumen, 1.0),
        COALESCE(wta.days_in_range, 0),
        uf.factor_volumen
    FROM silver.wip_time_allocation wta
    INNER JOIN universo_final uf ON wta.pr_id::text = uf.pr_id::text
    WHERE wta.wip_id IN ('16', '14', '19a', '19c', '24', '34', '40', '44', '37', '45', '49')
      AND wta.month_ >= '2021-01-01'
      AND wta.month_ < '2025-01-01'
      AND uf.en_bd_finanzas = 1
      AND wta.month_ IS NOT NULL;  -- Validaci√≥n: Solo fechas v√°lidas (PostgreSQL no necesita ISDATE)
    
    GET DIAGNOSTICS count_actividad = ROW_COUNT;
    IF debug = 1 THEN
        RAISE NOTICE '%', format('   ‚úÖ %s registros WIP procesados', count_actividad);
    END IF;
    
    -- =====================================================================
    -- OPTIMIZACI√ìN 6: PRE-CALCULAR COSTOS INDIRECTOS
    -- =====================================================================
    
    -- Una sola consulta para todos los costos indirectos
    SELECT 
        SUM(CASE WHEN tipo_costo = 'Costo Indirecto Fijo' THEN costo_total_usd ELSE 0 END),
        SUM(CASE WHEN tipo_costo = 'Gasto de Administraci√≥n' THEN costo_total_usd ELSE 0 END),
        SUM(CASE WHEN tipo_costo = 'Gasto de Ventas' THEN costo_total_usd ELSE 0 END)
    INTO cif_2024, admin_2024, ventas_2024
    FROM silver.costos_fijos_mensuales
    WHERE a√±o = 2024 
      AND proceso_productivo IN ('Textil', 'Manufactura')
      AND tipo_costo IN ('Gasto de Administraci√≥n', 'Gasto de Ventas', 'Costo Indirecto Fijo');
    
    SELECT SUM(prendas_requeridas * factor_volumen) INTO base_indirectos
    FROM universo_final
    WHERE en_bd_finanzas = 1;
    
    -- =====================================================================
    -- OPTIMIZACI√ìN 7: POOLS MENSUALES OPTIMIZADO (CORREGIDO)
    -- =====================================================================
    INSERT INTO pools_mensuales
    SELECT 
        a√±o,
        CASE LOWER(TRIM(mes))
            WHEN 'ene' THEN 1 WHEN 'feb' THEN 2 WHEN 'mar' THEN 3 WHEN 'abr' THEN 4
            WHEN 'may' THEN 5 WHEN 'jun' THEN 6 WHEN 'jul' THEN 7 WHEN 'ago' THEN 8
            WHEN 'sep' THEN 9 WHEN 'oct' THEN 10 WHEN 'nov' THEN 11 WHEN 'dic' THEN 12
            ELSE NULL
        END as mes_num,
        wip_id,
        LOWER(TRIM(grupo)) as grupo,
        SUM(costo)
    FROM silver.costos_procesos
    WHERE a√±o = 2024
      AND costo > 0
      AND wip_id IN ('16', '14', '19a', '19c', '24', '34', '40', '44', '37', '45', '49')
      AND mes IS NOT NULL
      AND grupo IS NOT NULL
    GROUP BY a√±o, 
        CASE LOWER(TRIM(mes))
            WHEN 'ene' THEN 1 WHEN 'feb' THEN 2 WHEN 'mar' THEN 3 WHEN 'abr' THEN 4
            WHEN 'may' THEN 5 WHEN 'jun' THEN 6 WHEN 'jul' THEN 7 WHEN 'ago' THEN 8
            WHEN 'sep' THEN 9 WHEN 'oct' THEN 10 WHEN 'nov' THEN 11 WHEN 'dic' THEN 12
            ELSE NULL
        END, 
        wip_id,
        LOWER(TRIM(grupo))
    HAVING CASE LOWER(TRIM(mes))
            WHEN 'ene' THEN 1 WHEN 'feb' THEN 2 WHEN 'mar' THEN 3 WHEN 'abr' THEN 4
            WHEN 'may' THEN 5 WHEN 'jun' THEN 6 WHEN 'jul' THEN 7 WHEN 'ago' THEN 8
            WHEN 'sep' THEN 9 WHEN 'oct' THEN 10 WHEN 'nov' THEN 11 WHEN 'dic' THEN 12
            ELSE NULL
        END IS NOT NULL;
    
    -- =====================================================================
    -- OPTIMIZACI√ìN 8: TABLA TEMPORAL PARA CONTEOS POR OP (EVITAR SUBCONSULTAS)
    -- =====================================================================
    DROP TABLE IF EXISTS conteos_por_op;
    CREATE TEMP TABLE conteos_por_op (
        pr_id VARCHAR(50) NOT NULL PRIMARY KEY,
        registros_wip INTEGER,
        costo_indirecto_fijo DECIMAL(18,4),
        gasto_administracion DECIMAL(18,4),
        gasto_ventas DECIMAL(18,4)
    );
    
    -- Pre-calcular conteos y costos indirectos por OP
    INSERT INTO conteos_por_op
    SELECT 
        uf.pr_id,
        COALESCE(conteos.registros_wip, 1),  -- Evitar divisi√≥n por cero
        CASE WHEN base_indirectos > 0 THEN cif_2024 * ((uf.prendas_requeridas * uf.factor_volumen) / base_indirectos) ELSE 0 END,
        CASE WHEN base_indirectos > 0 THEN admin_2024 * ((uf.prendas_requeridas * uf.factor_volumen) / base_indirectos) ELSE 0 END,
        CASE WHEN base_indirectos > 0 THEN ventas_2024 * ((uf.prendas_requeridas * uf.factor_volumen) / base_indirectos) ELSE 0 END
    FROM universo_final uf
    LEFT JOIN (
        SELECT pr_id, COUNT(*) as registros_wip
        FROM actividad_wip
        GROUP BY pr_id
	) conteos ON uf.pr_id::text = conteos.pr_id::text
    WHERE uf.en_bd_finanzas = 1;
    
    -- =====================================================================
    -- MOSTRAR RESUMEN OPTIMIZADO
    -- =====================================================================
    IF modo = 0 THEN
        -- Pre-calcular totales para el resumen
        SELECT COALESCE(SUM(pool_mes), 0) INTO total_textil_pool FROM pools_mensuales WHERE grupo = 'textil';
        SELECT COALESCE(SUM(pool_mes), 0) INTO total_manufactura_pool FROM pools_mensuales WHERE grupo = 'manufactura';
        SELECT COALESCE(SUM(base_textil), 0) INTO base_textil_bd_finanzas FROM actividad_wip WHERE grupo_wip = 'textil';
        SELECT COALESCE(SUM(base_manufactura), 0) INTO base_manufactura_bd_finanzas FROM actividad_wip WHERE grupo_wip = 'manufactura';
        
        -- Mostrar resumen optimizado usando una sola query estructurada
        RAISE NOTICE '';
        RAISE NOTICE '%', format('RESUMEN OPTIMIZADO_BD_FINANZAS');
        RAISE NOTICE '%', format('================================================================================');
        RAISE NOTICE '%', format('Estado: OPTIMIZADO_BD_FINANZAS');
        RAISE NOTICE '%', format('Universo_Base_Total: %s', count_base);
        RAISE NOTICE '%', format('Universo_Final_PO_OP: %s', count_final);
        RAISE NOTICE '%', format('OPs_BD_Finanzas: %s', count_bd_finanzas);
        RAISE NOTICE '%', format('OPs_Con_WIP: %s', (SELECT COUNT(*) FROM conteos_por_op WHERE registros_wip > 1));
        RAISE NOTICE '%', format('Registros_Actividad_WIP: %s', count_actividad);
        RAISE NOTICE '%', format('Pools_WIP_Mes_2024: %s', (SELECT COUNT(*) FROM pools_mensuales));
        RAISE NOTICE '%', format('Total_Pool_Textil_USD: %s', ROUND(total_textil_pool::NUMERIC, 2));
        RAISE NOTICE '%', format('Total_Pool_Manufactura_USD: %s', ROUND(total_manufactura_pool::NUMERIC, 2));
        RAISE NOTICE '%', format('Pool_Total_Directos_USD: %s', ROUND((total_textil_pool + total_manufactura_pool)::NUMERIC, 2));
        RAISE NOTICE '%', format('CIF_2024_USD: %s', ROUND(COALESCE(cif_2024, 0)::NUMERIC, 2));
        RAISE NOTICE '%', format('Administracion_2024_USD: %s', ROUND(COALESCE(admin_2024, 0)::NUMERIC, 2));
        RAISE NOTICE '%', format('Ventas_2024_USD: %s', ROUND(COALESCE(ventas_2024, 0)::NUMERIC, 2));
        RAISE NOTICE '%', format('Total_Indirectos_2024_USD: %s', ROUND((COALESCE(cif_2024, 0) + COALESCE(admin_2024, 0) + COALESCE(ventas_2024, 0))::NUMERIC, 2));
        RAISE NOTICE '%', format('Gran_Total_A_Distribuir_USD: %s', ROUND((total_textil_pool + total_manufactura_pool + COALESCE(cif_2024, 0) + COALESCE(admin_2024, 0) + COALESCE(ventas_2024, 0))::NUMERIC, 2));
        RAISE NOTICE '%', format('Estado_Performance: OPTIMIZADO_LISTO');
        RAISE NOTICE '';
        RAISE NOTICE '%', format('PREVIEW OPTIMIZADO COMPLETADO - Mejoras de rendimiento aplicadas');
        RAISE NOTICE '%', format('   ‚úÖ Tablas temporales con √≠ndices en lugar de variables tabla');
        RAISE NOTICE '%', format('   ‚úÖ CTEs para simplificar JOINs complejos');
        RAISE NOTICE '%', format('   ‚úÖ Pre-c√°lculo de conteos para evitar subconsultas correlacionadas');
        RAISE NOTICE '%', format('   ‚úÖ Filtros tempranos para lecturas optimizadas');
        RAISE NOTICE '%', format('   ‚úÖ Eliminaci√≥n de EXISTS repetitivos con LEFT JOINs');
        
        -- Limpieza
        DROP TABLE IF EXISTS universo_base, universo_final, actividad_wip, pools_mensuales, bd_finanzas_activo, conteos_por_op;
        RETURN;
    END IF;
    
    -- =====================================================================
    -- INSERCI√ìN OPTIMIZADA (Solo si modo = 1)
    -- =====================================================================
    IF modo = 1 THEN
        -- Pre-calcular totales base por mes para evitar subconsultas en INSERT
        DROP TABLE IF EXISTS totales_base_mensual;
        CREATE TEMP TABLE totales_base_mensual (
            a√±o INTEGER,
            mes INTEGER,
            wip_id VARCHAR(10),
            grupo_wip VARCHAR(20),
            total_base_textil DECIMAL(18,4),
            total_base_manufactura DECIMAL(18,4)
        );
        
        -- Crear √≠ndice por separado
        CREATE INDEX ix_totales_a√±o_mes_wip ON totales_base_mensual (a√±o, mes, wip_id, grupo_wip);
        INSERT INTO totales_base_mensual
        SELECT 
            a√±o, mes, wip_id, grupo_wip,
            SUM(CASE WHEN grupo_wip = 'textil' THEN base_textil ELSE 0 END),
            SUM(CASE WHEN grupo_wip = 'manufactura' THEN base_manufactura ELSE 0 END)
        FROM actividad_wip
        GROUP BY a√±o, mes, wip_id, grupo_wip;
        -- Inserci√≥n optimizada sin subconsultas correlacionadas y con validaci√≥n de fechas
        INSERT INTO silver.costo_wip_op (
            factory_id, pr_id, wip_id, ini_t, end_t, month_,
            prod_kg, prod_q, days_in_range, total_days, 
            prod_kg__allocated, prod_q__allocated,
            estilo_propio, cliente, tipo_de_producto, familia_de_productos, temporada,
            costo_indirecto_fijo, gasto_administracion, gasto_ventas,
            costo_textil, costo_manufactura, fecha_corrida, version_calculo
        )
        SELECT 
            'DEFAULT', 
            aw.pr_id, 
            aw.wip_id,
            wta.ini_t,    -- Usar fechas reales de wip_time_allocation
            wta.end_t,    -- Usar fechas reales de wip_time_allocation
            aw.month_,    -- Ya era correcto
            wta.prod_kg, wta.prod_q, wta.days_in_range, wta.total_days, 
            wta.prod_kg__allocated, wta.prod_q__allocated,
            COALESCE(bf.estilo_propio, ''), 
            COALESCE(bf.cliente, ''),
            COALESCE(bf.tipo_de_producto, ''), 
            COALESCE(bf.familia_de_productos, ''),
            COALESCE(bf.temporada, ''),
            -- Costos indirectos distribuidos (pre-calculados)
            CASE 
                WHEN cpo.registros_wip > 0 THEN cpo.costo_indirecto_fijo / cpo.registros_wip
                ELSE 0 
            END,
            CASE 
                WHEN cpo.registros_wip > 0 THEN cpo.gasto_administracion / cpo.registros_wip
                ELSE 0 
            END,
            CASE 
                WHEN cpo.registros_wip > 0 THEN cpo.gasto_ventas / cpo.registros_wip
                ELSE 0 
            END,
            -- Costos directos optimizados
            CASE WHEN aw.grupo_wip = 'textil' AND COALESCE(pm.pool_mes, 0) > 0 AND COALESCE(tbm.total_base_textil, 0) > 0
                 THEN aw.base_textil * (pm.pool_mes / tbm.total_base_textil)
                 ELSE 0 END,
            CASE WHEN aw.grupo_wip = 'manufactura' AND COALESCE(pm.pool_mes, 0) > 0 AND COALESCE(tbm.total_base_manufactura, 0) > 0
                 THEN aw.base_manufactura * (pm.pool_mes / tbm.total_base_manufactura)
                 ELSE 0 END,
            fecha_corrida,
            'truncado'  -- VALOR CORRECTO: version_calculo
        FROM actividad_wip aw
        INNER JOIN conteos_por_op cpo ON aw.pr_id::text = cpo.pr_id::text
		INNER JOIN silver.wip_time_allocation wta 
   			ON aw.pr_id::text = wta.pr_id::text AND aw.wip_id::text = wta.wip_id::text AND aw.month_ = wta.month_
		LEFT JOIN bd_finanzas_activo bf ON aw.pr_id::text = bf.cod_ordpro::text
        LEFT JOIN pools_mensuales pm ON aw.a√±o = pm.a√±o AND aw.mes = pm.mes_num AND aw.wip_id::text = pm.wip_id::text
        LEFT JOIN totales_base_mensual tbm ON aw.a√±o = tbm.a√±o AND aw.mes = tbm.mes AND aw.wip_id::text = tbm.wip_id::text AND aw.grupo_wip::text = tbm.grupo_wip::text
        WHERE aw.month_ IS NOT NULL;  -- FILTRO FINAL: Solo registros con fechas v√°lidas
        
        GET DIAGNOSTICS rows_inserted = ROW_COUNT;
        
        RAISE NOTICE '';
        RAISE NOTICE '%', format('INSERCI√ìN OPTIMIZADA COMPLETADA');
        RAISE NOTICE '%', format('   ‚úÖ %s registros insertados con performance mejorada', rows_inserted);
        
        -- Limpieza espec√≠fica de inserci√≥n
        DROP TABLE IF EXISTS totales_base_mensual;
    END IF;
    
    -- Limpieza final
    DROP TABLE IF EXISTS universo_base, universo_final, actividad_wip, pools_mensuales, bd_finanzas_activo, conteos_por_op;
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE '%', format('ERROR OPTIMIZADO: %s', error_message);
        
        -- Limpiar todas las tablas temporales en caso de error
        DROP TABLE IF EXISTS universo_base, universo_final, actividad_wip, pools_mensuales, bd_finanzas_activo, conteos_por_op, totales_base_mensual;
        
        RAISE EXCEPTION '%', error_message;
END;
$procedure$

-------------------------------------------------------------------------------------

21. =====================================================================================
NOMBRE: populate_costo_wip_op_v2
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0, IN debug integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.populate_costo_wip_op_v2(IN modo integer DEFAULT 0, IN debug integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    fecha_corrida TIMESTAMPTZ := NOW();
    rows_inserted INTEGER := 0;
    
    -- Variables para conteos
    count_base INTEGER;
    count_final INTEGER;
    count_bd_finanzas INTEGER;
    count_actividad INTEGER;
    
    -- Variables para costos indirectos
    cif_2024 DECIMAL(18,4);
    admin_2024 DECIMAL(18,4);
    ventas_2024 DECIMAL(18,4);
    base_indirectos DECIMAL(18,4);
    
    -- Variables para totales del resumen
    total_textil_pool DECIMAL(18,4);
    total_manufactura_pool DECIMAL(18,4);
    base_textil_bd_finanzas DECIMAL(18,4);
    base_manufactura_bd_finanzas DECIMAL(18,4);
    
BEGIN
    -- =====================================================================
    -- OPTIMIZACI√ìN 1: CREAR TABLAS TEMPORALES CON √çNDICES
    -- =====================================================================
    
    -- Tabla temporal con √≠ndices para mejor rendimiento
    DROP TABLE IF EXISTS universo_base;
    CREATE TEMP TABLE universo_base (
        pr_id VARCHAR(50) NOT NULL PRIMARY KEY
    );
    
    DROP TABLE IF EXISTS universo_final;
    CREATE TEMP TABLE universo_final (
        pr_id VARCHAR(50) NOT NULL PRIMARY KEY,
        prendas_requeridas DECIMAL(18,2),
        factor_volumen DECIMAL(6,3),
        en_bd_finanzas INTEGER
    );
    
    DROP TABLE IF EXISTS actividad_wip;
    CREATE TEMP TABLE actividad_wip (
        pr_id VARCHAR(50) NOT NULL,
        wip_id VARCHAR(10),
        a√±o INTEGER,
        mes INTEGER,
        month_ TIMESTAMPTZ,
        grupo_wip VARCHAR(20),
        base_textil DECIMAL(18,4),
        base_manufactura DECIMAL(18,4),
        factor_volumen DECIMAL(6,3)
    );
    
    -- Crear √≠ndices por separado (sintaxis correcta PostgreSQL)
    CREATE INDEX ix_actividad_wip_pr_id ON actividad_wip (pr_id);
    CREATE INDEX ix_actividad_wip_grupo_a√±o_mes ON actividad_wip (grupo_wip, a√±o, mes, wip_id);
    
    DROP TABLE IF EXISTS pools_mensuales;
    CREATE TEMP TABLE pools_mensuales (
        a√±o INTEGER,
        mes_num INTEGER,
        wip_id VARCHAR(10),
        grupo VARCHAR(20),
        pool_mes DECIMAL(18,4)
    );
    
    -- Crear √≠ndice por separado
    CREATE INDEX ix_pools_a√±o_mes_grupo ON pools_mensuales (a√±o, mes_num, grupo, wip_id);
    
    -- =====================================================================
    -- OPTIMIZACI√ìN 2: PASO 1 OPTIMIZADO
    -- =====================================================================
    IF debug = 1 THEN
        RAISE NOTICE '%', format('PASO 1: Cargando universo base optimizado...');
    END IF;
    
    INSERT INTO universo_base (pr_id)
    SELECT DISTINCT pr_id
    FROM silver.wip_time_allocation
    WHERE pr_id IS NOT NULL ;
    -- AND month_ >= '2023-01-01' 
    -- AND month_ < '2025-01-01';
    
    GET DIAGNOSTICS count_base = ROW_COUNT;
    IF debug = 1 THEN
        RAISE NOTICE '%', format('   ‚úÖ %s OPs en universo base', count_base);
    END IF; 
    
    -- =====================================================================
    -- OPTIMIZACI√ìN 3: PRE-CARGAR BD_FINANZAS EN TABLA TEMPORAL
    -- =====================================================================
    DROP TABLE IF EXISTS bd_finanzas_activo;
    CREATE TEMP TABLE bd_finanzas_activo (
        cod_ordpro VARCHAR(50) NOT NULL PRIMARY KEY,
        estilo_propio VARCHAR(100),
        cliente VARCHAR(100),
        tipo_de_producto VARCHAR(100),
        familia_de_productos VARCHAR(100),
        temporada VARCHAR(50),
        prendas_requeridas DECIMAL(18,2)
    );
    
    INSERT INTO bd_finanzas_activo
    SELECT cod_ordpro, estilo_propio, cliente, tipo_de_producto, 
           familia_de_productos, temporada, prendas_requeridas
    FROM silver.bd_finanzas
    WHERE activo IS true;
    
    -- =====================================================================
    -- OPTIMIZACI√ìN 4: PASO 2 SIMPLIFICADO CON CTE
    -- =====================================================================
    IF debug = 1 THEN
        RAISE NOTICE '%', format('PASO 2: Calculando universo final optimizado...');
    END IF;
    
    -- CTE para simplificar el JOIN complejo
    WITH prendas_por_op AS (
        SELECT 
            pr.cod_ordpro as pr_id,
            SUM(COALESCE(pol.num_prereq::numeric, 0)) as prendas_requeridas
    FROM bronze.tg_purord po
	INNER JOIN bronze.tg_lotest pol
    	ON pol.cod_cliente::text = po.cod_cliente::text
   		AND pol.cod_purord::text = po.cod_purord::text
	INNER JOIN bronze.tg_lotestpro pols
    	ON pols.cod_cliente::text = pol.cod_cliente::text
   		AND pols.cod_purord::text = pol.cod_purord::text
   		AND pols.cod_lotpurord::text = pol.cod_lotpurord::text
   		AND pols.cod_estcli::text = pol.cod_estcli::text
	INNER JOIN bronze.es_ordpro pr
    	ON pr.cod_fabrica::text = pols.cod_fabrica::text
   		AND pr.cod_ordpro::text = pols.cod_ordpro::text
	INNER JOIN universo_base u ON pr.cod_ordpro::text = u.pr_id::text
    --    WHERE po.cod_clapurord = 'PO' 
    --    AND po.cod_subclapurord = 'PR'
        GROUP BY pr.cod_ordpro
    )
    INSERT INTO universo_final (pr_id, prendas_requeridas, factor_volumen, en_bd_finanzas)
    SELECT 
        ppo.pr_id,
        ppo.prendas_requeridas,
        -- Factor de volumen optimizado
        CASE 
            WHEN ppo.prendas_requeridas < 850 THEN 1.15
            WHEN ppo.prendas_requeridas < 1700 THEN 1.1
            WHEN ppo.prendas_requeridas < 5700 THEN 1
            WHEN ppo.prendas_requeridas >= 5700 THEN 0.9
            ELSE 1.0
        END,
        -- Verificacion optimizada con LEFT JOIN
        CASE WHEN bf.cod_ordpro IS NOT NULL THEN 1 ELSE 0 END
    FROM prendas_por_op ppo
    LEFT JOIN bd_finanzas_activo bf ON ppo.pr_id = bf.cod_ordpro;
    
    GET DIAGNOSTICS count_final = ROW_COUNT;
    SELECT COUNT(*) INTO count_bd_finanzas FROM universo_final WHERE en_bd_finanzas = 1;
    
    IF debug = 1 THEN
        RAISE NOTICE '%', format('   ‚úÖ %s OPs finales, %s en bd_finanzas', count_final, count_bd_finanzas);
    END IF;
    
    -- =====================================================================
    -- OPTIMIZACI√ìN 5: ACTIVIDAD WIP CON FILTRO TEMPRANO Y VALIDACI√ìN DE FECHAS
    -- =====================================================================
    IF debug = 1 THEN
        RAISE NOTICE '%', format('PASO 3: Cargando actividad WIP solo bd_finanzas...');
    END IF;
    
    INSERT INTO actividad_wip
    SELECT 
        wta.pr_id,
        wta.wip_id,
        EXTRACT(YEAR FROM wta.month_)::INTEGER,
        EXTRACT(MONTH FROM wta.month_)::INTEGER,
        wta.month_,
        CASE 
            WHEN wta.wip_id IN ('16','10c', '14', '19a', '19c', '24') THEN 'textil'
            WHEN wta.wip_id IN ('34', '36', '40', '44', '37', '45', '49', '43', '50') THEN 'manufactura'
            ELSE 'otro'
        END,
        COALESCE(wta.prod_kg__allocated, 0) * COALESCE(uf.factor_volumen, 1.0),
        COALESCE(wta.days_in_range, 0),
        uf.factor_volumen
    FROM silver.wip_time_allocation wta
    INNER JOIN universo_final uf ON wta.pr_id::text = uf.pr_id::text
    WHERE wta.wip_id IN ('16', '14', '19a', '19c', '24', '10c', '34', '36', '40', '44', '37', '45', '49', '43', '50')
      AND wta.month_ >= '2021-01-01'
      AND wta.month_ < '2025-01-01'
      AND uf.en_bd_finanzas = 1
      AND wta.month_ IS NOT NULL;  -- Validaci√≥n: Solo fechas v√°lidas (PostgreSQL no necesita ISDATE)
    
    GET DIAGNOSTICS count_actividad = ROW_COUNT;
    IF debug = 1 THEN
        RAISE NOTICE '%', format('   ‚úÖ %s registros WIP procesados', count_actividad);
    END IF;
    
    -- =====================================================================
    -- OPTIMIZACI√ìN 6: PRE-CALCULAR COSTOS INDIRECTOS
    -- =====================================================================
    
    -- Una sola consulta para todos los costos indirectos
    SELECT 
        SUM(CASE WHEN tipo_costo = 'Costo Indirecto Fijo' THEN costo_total_usd ELSE 0 END),
        SUM(CASE WHEN tipo_costo = 'Gasto de Administraci√≥n' THEN costo_total_usd ELSE 0 END),
        SUM(CASE WHEN tipo_costo = 'Gasto de Ventas' THEN costo_total_usd ELSE 0 END)
    INTO cif_2024, admin_2024, ventas_2024
    FROM silver.costos_fijos_mensuales
    WHERE a√±o = 2024 
      AND proceso_productivo IN ('Textil', 'Manufactura')
      AND tipo_costo IN ('Gasto de Administraci√≥n', 'Gasto de Ventas', 'Costo Indirecto Fijo');
    
    SELECT SUM(prendas_requeridas * factor_volumen) INTO base_indirectos
    FROM universo_final
    WHERE en_bd_finanzas = 1;
    
    -- =====================================================================
    -- OPTIMIZACI√ìN 7: POOLS MENSUALES OPTIMIZADO (CORREGIDO)
    -- =====================================================================
    INSERT INTO pools_mensuales
    SELECT 
        a√±o,
        CASE LOWER(TRIM(mes))
            WHEN 'ene' THEN 1 WHEN 'feb' THEN 2 WHEN 'mar' THEN 3 WHEN 'abr' THEN 4
            WHEN 'may' THEN 5 WHEN 'jun' THEN 6 WHEN 'jul' THEN 7 WHEN 'ago' THEN 8
            WHEN 'sep' THEN 9 WHEN 'oct' THEN 10 WHEN 'nov' THEN 11 WHEN 'dic' THEN 12
            ELSE NULL
        END as mes_num,
        wip_id,
        LOWER(TRIM(grupo)) as grupo,
        SUM(costo)
    FROM silver.costos_procesos
    WHERE a√±o = 2024
      AND costo > 0
      AND wip_id IN ('16', '14', '19a', '19c', '24', '10c', '34', '36', '40', '44', '37', '45', '49', '43', '50')
      AND mes IS NOT NULL
      AND grupo IS NOT NULL
    GROUP BY a√±o, 
        CASE LOWER(TRIM(mes))
            WHEN 'ene' THEN 1 WHEN 'feb' THEN 2 WHEN 'mar' THEN 3 WHEN 'abr' THEN 4
            WHEN 'may' THEN 5 WHEN 'jun' THEN 6 WHEN 'jul' THEN 7 WHEN 'ago' THEN 8
            WHEN 'sep' THEN 9 WHEN 'oct' THEN 10 WHEN 'nov' THEN 11 WHEN 'dic' THEN 12
            ELSE NULL
        END, 
        wip_id,
        LOWER(TRIM(grupo))
    HAVING CASE LOWER(TRIM(mes))
            WHEN 'ene' THEN 1 WHEN 'feb' THEN 2 WHEN 'mar' THEN 3 WHEN 'abr' THEN 4
            WHEN 'may' THEN 5 WHEN 'jun' THEN 6 WHEN 'jul' THEN 7 WHEN 'ago' THEN 8
            WHEN 'sep' THEN 9 WHEN 'oct' THEN 10 WHEN 'nov' THEN 11 WHEN 'dic' THEN 12
            ELSE NULL
        END IS NOT NULL;
    
    -- =====================================================================
    -- OPTIMIZACI√ìN 8: TABLA TEMPORAL PARA CONTEOS POR OP (EVITAR SUBCONSULTAS)
    -- =====================================================================
    DROP TABLE IF EXISTS conteos_por_op;
    CREATE TEMP TABLE conteos_por_op (
        pr_id VARCHAR(50) NOT NULL PRIMARY KEY,
        registros_wip INTEGER,
        costo_indirecto_fijo DECIMAL(18,4),
        gasto_administracion DECIMAL(18,4),
        gasto_ventas DECIMAL(18,4)
    );
    
    -- Pre-calcular conteos y costos indirectos por OP
    INSERT INTO conteos_por_op
    SELECT 
        uf.pr_id,
        COALESCE(conteos.registros_wip, 1),  -- Evitar divisi√≥n por cero
        CASE WHEN base_indirectos > 0 THEN cif_2024 * ((uf.prendas_requeridas * uf.factor_volumen) / base_indirectos) ELSE 0 END,
        CASE WHEN base_indirectos > 0 THEN admin_2024 * ((uf.prendas_requeridas * uf.factor_volumen) / base_indirectos) ELSE 0 END,
        CASE WHEN base_indirectos > 0 THEN ventas_2024 * ((uf.prendas_requeridas * uf.factor_volumen) / base_indirectos) ELSE 0 END
    FROM universo_final uf
    LEFT JOIN (
        SELECT pr_id, COUNT(*) as registros_wip
        FROM actividad_wip
        GROUP BY pr_id
	) conteos ON uf.pr_id::text = conteos.pr_id::text
    WHERE uf.en_bd_finanzas = 1;
    
    -- =====================================================================
    -- MOSTRAR RESUMEN OPTIMIZADO
    -- =====================================================================
    IF modo = 0 THEN
        -- Pre-calcular totales para el resumen
        SELECT COALESCE(SUM(pool_mes), 0) INTO total_textil_pool FROM pools_mensuales WHERE grupo = 'textil';
        SELECT COALESCE(SUM(pool_mes), 0) INTO total_manufactura_pool FROM pools_mensuales WHERE grupo = 'manufactura';
        SELECT COALESCE(SUM(base_textil), 0) INTO base_textil_bd_finanzas FROM actividad_wip WHERE grupo_wip = 'textil';
        SELECT COALESCE(SUM(base_manufactura), 0) INTO base_manufactura_bd_finanzas FROM actividad_wip WHERE grupo_wip = 'manufactura';
        
        -- Mostrar resumen optimizado usando una sola query estructurada
        RAISE NOTICE '';
        RAISE NOTICE '%', format('RESUMEN OPTIMIZADO_BD_FINANZAS');
        RAISE NOTICE '%', format('================================================================================');
        RAISE NOTICE '%', format('Estado: OPTIMIZADO_BD_FINANZAS');
        RAISE NOTICE '%', format('Universo_Base_Total: %s', count_base);
        RAISE NOTICE '%', format('Universo_Final_PO_OP: %s', count_final);
        RAISE NOTICE '%', format('OPs_BD_Finanzas: %s', count_bd_finanzas);
        RAISE NOTICE '%', format('OPs_Con_WIP: %s', (SELECT COUNT(*) FROM conteos_por_op WHERE registros_wip > 1));
        RAISE NOTICE '%', format('Registros_Actividad_WIP: %s', count_actividad);
        RAISE NOTICE '%', format('Pools_WIP_Mes_2024: %s', (SELECT COUNT(*) FROM pools_mensuales));
        RAISE NOTICE '%', format('Total_Pool_Textil_USD: %s', ROUND(total_textil_pool::NUMERIC, 2));
        RAISE NOTICE '%', format('Total_Pool_Manufactura_USD: %s', ROUND(total_manufactura_pool::NUMERIC, 2));
        RAISE NOTICE '%', format('Pool_Total_Directos_USD: %s', ROUND((total_textil_pool + total_manufactura_pool)::NUMERIC, 2));
        RAISE NOTICE '%', format('CIF_2024_USD: %s', ROUND(COALESCE(cif_2024, 0)::NUMERIC, 2));
        RAISE NOTICE '%', format('Administracion_2024_USD: %s', ROUND(COALESCE(admin_2024, 0)::NUMERIC, 2));
        RAISE NOTICE '%', format('Ventas_2024_USD: %s', ROUND(COALESCE(ventas_2024, 0)::NUMERIC, 2));
        RAISE NOTICE '%', format('Total_Indirectos_2024_USD: %s', ROUND((COALESCE(cif_2024, 0) + COALESCE(admin_2024, 0) + COALESCE(ventas_2024, 0))::NUMERIC, 2));
        RAISE NOTICE '%', format('Gran_Total_A_Distribuir_USD: %s', ROUND((total_textil_pool + total_manufactura_pool + COALESCE(cif_2024, 0) + COALESCE(admin_2024, 0) + COALESCE(ventas_2024, 0))::NUMERIC, 2));
        RAISE NOTICE '%', format('Estado_Performance: OPTIMIZADO_LISTO');
        RAISE NOTICE '';
        RAISE NOTICE '%', format('PREVIEW OPTIMIZADO COMPLETADO - Mejoras de rendimiento aplicadas');
        RAISE NOTICE '%', format('   ‚úÖ Tablas temporales con √≠ndices en lugar de variables tabla');
        RAISE NOTICE '%', format('   ‚úÖ CTEs para simplificar JOINs complejos');
        RAISE NOTICE '%', format('   ‚úÖ Pre-c√°lculo de conteos para evitar subconsultas correlacionadas');
        RAISE NOTICE '%', format('   ‚úÖ Filtros tempranos para lecturas optimizadas');
        RAISE NOTICE '%', format('   ‚úÖ Eliminaci√≥n de EXISTS repetitivos con LEFT JOINs');
        
        -- Limpieza
        DROP TABLE IF EXISTS universo_base, universo_final, actividad_wip, pools_mensuales, bd_finanzas_activo, conteos_por_op;
        RETURN;
    END IF;
    
    -- =====================================================================
    -- INSERCI√ìN OPTIMIZADA (Solo si modo = 1)
    -- =====================================================================
    IF modo = 1 THEN
        -- Pre-calcular totales base por mes para evitar subconsultas en INSERT
        DROP TABLE IF EXISTS totales_base_mensual;
        CREATE TEMP TABLE totales_base_mensual (
            a√±o INTEGER,
            mes INTEGER,
            wip_id VARCHAR(10),
            grupo_wip VARCHAR(20),
            total_base_textil DECIMAL(18,4),
            total_base_manufactura DECIMAL(18,4)
        );
        
        -- Crear √≠ndice por separado
        CREATE INDEX ix_totales_a√±o_mes_wip ON totales_base_mensual (a√±o, mes, wip_id, grupo_wip);
        INSERT INTO totales_base_mensual
        SELECT 
            a√±o, mes, wip_id, grupo_wip,
            SUM(CASE WHEN grupo_wip = 'textil' THEN base_textil ELSE 0 END),
            SUM(CASE WHEN grupo_wip = 'manufactura' THEN base_manufactura ELSE 0 END)
        FROM actividad_wip
        GROUP BY a√±o, mes, wip_id, grupo_wip;
        -- Inserci√≥n optimizada sin subconsultas correlacionadas y con validaci√≥n de fechas
        INSERT INTO silver.costo_wip_op (
            factory_id, pr_id, wip_id, ini_t, end_t, month_,
            prod_kg, prod_q, days_in_range, total_days, 
            prod_kg__allocated, prod_q__allocated,
            estilo_propio, cliente, tipo_de_producto, familia_de_productos, temporada,
            costo_indirecto_fijo, gasto_administracion, gasto_ventas,
            costo_textil, costo_manufactura, fecha_corrida, version_calculo
        )
        SELECT 
            'DEFAULT', 
            aw.pr_id, 
            aw.wip_id,
            wta.ini_t,    -- Usar fechas reales de wip_time_allocation
            wta.end_t,    -- Usar fechas reales de wip_time_allocation
            aw.month_,    -- Ya era correcto
            wta.prod_kg, wta.prod_q, wta.days_in_range, wta.total_days, 
            wta.prod_kg__allocated, wta.prod_q__allocated,
            COALESCE(bf.estilo_propio, ''), 
            COALESCE(bf.cliente, ''),
            COALESCE(bf.tipo_de_producto, ''), 
            COALESCE(bf.familia_de_productos, ''),
            COALESCE(bf.temporada, ''),
            -- Costos indirectos distribuidos (pre-calculados)
            CASE 
                WHEN cpo.registros_wip > 0 THEN cpo.costo_indirecto_fijo / cpo.registros_wip
                ELSE 0 
            END,
            CASE 
                WHEN cpo.registros_wip > 0 THEN cpo.gasto_administracion / cpo.registros_wip
                ELSE 0 
            END,
            CASE 
                WHEN cpo.registros_wip > 0 THEN cpo.gasto_ventas / cpo.registros_wip
                ELSE 0 
            END,
            -- Costos directos optimizados
            CASE WHEN aw.grupo_wip = 'textil' AND COALESCE(pm.pool_mes, 0) > 0 AND COALESCE(tbm.total_base_textil, 0) > 0
                 THEN aw.base_textil * (pm.pool_mes / tbm.total_base_textil)
                 ELSE 0 END,
            CASE WHEN aw.grupo_wip = 'manufactura' AND COALESCE(pm.pool_mes, 0) > 0 AND COALESCE(tbm.total_base_manufactura, 0) > 0
                 THEN aw.base_manufactura * (pm.pool_mes / tbm.total_base_manufactura)
                 ELSE 0 END,
            fecha_corrida,
            'truncado'  -- VALOR CORRECTO: version_calculo
        FROM actividad_wip aw
        INNER JOIN conteos_por_op cpo ON aw.pr_id::text = cpo.pr_id::text
		INNER JOIN silver.wip_time_allocation wta 
   			ON aw.pr_id::text = wta.pr_id::text AND aw.wip_id::text = wta.wip_id::text AND aw.month_ = wta.month_
		LEFT JOIN bd_finanzas_activo bf ON aw.pr_id::text = bf.cod_ordpro::text
        LEFT JOIN pools_mensuales pm ON aw.a√±o = pm.a√±o AND aw.mes = pm.mes_num AND aw.wip_id::text = pm.wip_id::text
        LEFT JOIN totales_base_mensual tbm ON aw.a√±o = tbm.a√±o AND aw.mes = tbm.mes AND aw.wip_id::text = tbm.wip_id::text AND aw.grupo_wip::text = tbm.grupo_wip::text
        WHERE aw.month_ IS NOT NULL;  -- FILTRO FINAL: Solo registros con fechas v√°lidas
        
        GET DIAGNOSTICS rows_inserted = ROW_COUNT;
        
        RAISE NOTICE '';
        RAISE NOTICE '%', format('INSERCI√ìN OPTIMIZADA COMPLETADA');
        RAISE NOTICE '%', format('   ‚úÖ %s registros insertados con performance mejorada', rows_inserted);
        
        -- Limpieza espec√≠fica de inserci√≥n
        DROP TABLE IF EXISTS totales_base_mensual;
    END IF;
    
    -- Limpieza final
    DROP TABLE IF EXISTS universo_base, universo_final, actividad_wip, pools_mensuales, bd_finanzas_activo, conteos_por_op;
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE '%', format('ERROR OPTIMIZADO: %s', error_message);
        
        -- Limpiar todas las tablas temporales en caso de error
        DROP TABLE IF EXISTS universo_base, universo_final, actividad_wip, pools_mensuales, bd_finanzas_activo, conteos_por_op, totales_base_mensual;
        
        RAISE EXCEPTION '%', error_message;
END;
$procedure$

-------------------------------------------------------------------------------------

22. =====================================================================================
NOMBRE: populate_costos_hibrido
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0, IN debug integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.populate_costos_hibrido(IN modo integer DEFAULT 0, IN debug integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$

DECLARE
    error_message TEXT;
    rows_inserted_wip INTEGER := 0;
    sp_fecha_corrida TIMESTAMPTZ := NOW();
    
    -- Variables para pools indirectos
    pool_cif DECIMAL(18,4);
    pool_admin DECIMAL(18,4);
    pool_ventas DECIMAL(18,4);
    total_base_indirectos DECIMAL(18,4);
    
    -- Variables para fechas materiales
    fecha_avios_max TIMESTAMPTZ;
    fecha_mp_max TIMESTAMPTZ;
    
    -- Variables para contadores
    count_universo_base INTEGER;
    count_universo_final INTEGER;
    count_actividad_wip INTEGER;
    count_pools_mensuales INTEGER;
    count_costos_fix INTEGER;
    count_costos_final INTEGER;
    
BEGIN
    RAISE NOTICE 'SP SIMPLE - REPLICANDO CONSULTA QUE FUNCIONABA...';
    RAISE NOTICE '   Fecha corrida: %', sp_fecha_corrida;
    RAISE NOTICE '   Esperado: 36.9M total (sin duplicaci√≥n)';
    RAISE NOTICE '   Solo inserta en COSTO_WIP_OP';
    RAISE NOTICE '';
    
    -- =====================================================================
    -- PASO 1: UNIVERSO BASE (EXACTO DE LA CONSULTA ORIGINAL)
    -- =====================================================================
    DROP TABLE IF EXISTS universo_base;
    
    CREATE TEMP TABLE universo_base AS
    SELECT DISTINCT pr_id
    FROM silver.wip_time_allocation
    WHERE pr_id IS NOT NULL
      AND month_ >= '2022-01-01' 
      AND month_ < '2025-04-01';
    
    GET DIAGNOSTICS count_universo_base = ROW_COUNT;
    RAISE NOTICE 'PASO 1: % OPs en universo base', count_universo_base;
    
    -- =====================================================================
    -- PASO 2: UNIVERSO FINAL (EXACTO DE LA CONSULTA ORIGINAL)
    -- =====================================================================
    DROP TABLE IF EXISTS universo_final;
    
    CREATE TEMP TABLE universo_final AS
    SELECT 
        pr.cod_ordpro as pr_id,
        SUM(COALESCE(pol.num_prereq, 0)) as prendas_requeridas,
    	CASE 
            WHEN SUM(COALESCE(pol.num_prereq, 0)) >= 0 AND SUM(COALESCE(pol.num_prereq, 0)) < 850 THEN 1.5
            WHEN SUM(COALESCE(pol.num_prereq, 0)) >= 850 AND SUM(COALESCE(pol.num_prereq, 0)) < 1700 THEN 1.2
            WHEN SUM(COALESCE(pol.num_prereq, 0)) >= 1700 AND SUM(COALESCE(pol.num_prereq, 0)) < 5700 THEN 0.9
            WHEN SUM(COALESCE(pol.num_prereq, 0)) >= 5700 THEN 0.8
            ELSE 1.0
        END as factor_volumen,
        CASE WHEN EXISTS (
            SELECT 1 FROM silver.bd_finanzas bf 
            WHERE bf.cod_ordpro = pr.cod_ordpro AND bf.activo IS true
        ) THEN 1 ELSE 0 END as en_bd_finanzas
    FROM bronze.tg_purord po
    INNER JOIN bronze.tg_lotest pol 
        ON pol.cod_cliente = po.cod_cliente
       AND pol.cod_purord = po.cod_purord
    INNER JOIN bronze.tg_lotestpro pols
        ON pols.cod_cliente = pol.cod_cliente
       AND pols.cod_purord = pol.cod_purord
       AND pols.cod_lotpurord = pol.cod_lotpurord
       AND pols.cod_estcli = pol.cod_estcli
    INNER JOIN bronze.es_ordpro pr
        ON pr.cod_fabrica = pols.cod_fabrica
       AND pr.cod_ordpro = pols.cod_ordpro
   	INNER JOIN universo_base u ON pr.cod_ordpro = u.pr_id
    WHERE po.cod_clapurord = 'PO' 
      AND po.cod_subclapurord = 'PR'
    GROUP BY pr.cod_ordpro;
	--INDEX
	CREATE INDEX idx_temp_universo_final ON universo_final (en_bd_finanzas, prendas_requeridas, factor_volumen);

    GET DIAGNOSTICS count_universo_final = ROW_COUNT;
    RAISE NOTICE 'PASO 2: % OPs en universo final', count_universo_final;
    
    -- =====================================================================
    -- PASO 3: ACTIVIDAD WIP (EXACTO DE LA CONSULTA ORIGINAL)
    -- =====================================================================
    DROP TABLE IF EXISTS actividad_wip;
    
    CREATE TEMP TABLE actividad_wip AS
    SELECT 
        wta.pr_id,
        wta.wip_id,
        EXTRACT(YEAR FROM wta.month_)::INTEGER as a√±o,
        EXTRACT(MONTH FROM wta.month_)::INTEGER as mes,
        wta.month_,
        
        CASE 
            WHEN wta.wip_id IN ('16', '14', '19a', '19c', '24') THEN 'textil'
            WHEN wta.wip_id IN ('34', '40', '44', '37', '45', '49') THEN 'manufactura'
            ELSE 'otro'
        END as grupo_wip,
        
        -- BASE TEXTIL: kg_allocated * factor_volumen
        COALESCE(wta.prod_kg__allocated, 0) * COALESCE(uf.factor_volumen, 1.0) as base_textil,
        
        -- BASE MANUFACTURA: days_in_range
        COALESCE(wta.days_in_range, 0) as base_manufactura,
        
        uf.en_bd_finanzas,
        uf.prendas_requeridas,
        uf.factor_volumen,
        COALESCE(wta.prod_q__allocated, 0) as q_allocated,
        COALESCE(wta.prod_kg__allocated, 0) as kg_allocated,
        COALESCE(wta.days_in_range, 0) as days_in_range
    
    FROM silver.wip_time_allocation wta
    INNER JOIN universo_final uf ON wta.pr_id = uf.pr_id
    WHERE wta.wip_id IN ('16', '14', '19a', '19c', '24', '34', '40', '44', '37', '45', '49')
      AND wta.month_ >= '2023-01-01'
      AND wta.month_ < '2025-01-01';
    
    GET DIAGNOSTICS count_actividad_wip = ROW_COUNT;
    RAISE NOTICE 'PASO 3: % registros actividad WIP', count_actividad_wip;
    
    -- =====================================================================
    -- PASO 4: POOLS MENSUALES (EXACTO DE LA CONSULTA ORIGINAL)
    -- =====================================================================
    DROP TABLE IF EXISTS pools_mensuales;
    
    CREATE TEMP TABLE pools_mensuales AS
    SELECT 
        a√±o,
        CASE LOWER(mes)
            WHEN 'ene' THEN 1 WHEN 'feb' THEN 2 WHEN 'mar' THEN 3 WHEN 'abr' THEN 4
            WHEN 'may' THEN 5 WHEN 'jun' THEN 6 WHEN 'jul' THEN 7 WHEN 'ago' THEN 8
            WHEN 'sep' THEN 9 WHEN 'oct' THEN 10 WHEN 'nov' THEN 11 WHEN 'dic' THEN 12
        END as mes_num,
        wip_id,
        LOWER(grupo) as grupo,
        SUM(costo) as pool_mes
    FROM silver.costos_procesos
    WHERE a√±o IN (2023, 2024)  
      AND costo IS NOT NULL   
      AND costo > 0
      AND wip_id IN ('16', '14', '19a', '19c', '24', '34', '40', '44', '37', '45', '49')
    GROUP BY a√±o, 
        CASE LOWER(mes)
            WHEN 'ene' THEN 1 WHEN 'feb' THEN 2 WHEN 'mar' THEN 3 WHEN 'abr' THEN 4
            WHEN 'may' THEN 5 WHEN 'jun' THEN 6 WHEN 'jul' THEN 7 WHEN 'ago' THEN 8
            WHEN 'sep' THEN 9 WHEN 'oct' THEN 10 WHEN 'nov' THEN 11 WHEN 'dic' THEN 12
        END, 
        wip_id,
        LOWER(grupo);
    
    GET DIAGNOSTICS count_pools_mensuales = ROW_COUNT;
    RAISE NOTICE 'PASO 4: % pools mensuales', count_pools_mensuales;
    
    -- =====================================================================
    -- PASO 5: DISTRIBUCI√ìN SIMPLE (EXACTA DE LA CONSULTA QUE FUNCIONABA)
    -- =====================================================================
			    
			-- PASO 5 OPTIMIZADO: Pre-calcular totales y hacer JOINs
			DROP TABLE IF EXISTS costos_fix;
			DROP TABLE IF EXISTS totales_base;  -- AGREGADO: Limpiar tabla temporal
			
			-- Paso 5.1: Calcular totales base por grupo una sola vez
			CREATE TEMP TABLE totales_base AS
			SELECT 
			    a√±o, mes, wip_id, grupo_wip,
			    SUM(CASE WHEN grupo_wip = 'textil' THEN base_textil ELSE 0 END) as total_base_textil,
			    SUM(CASE WHEN grupo_wip = 'manufactura' THEN base_manufactura ELSE 0 END) as total_base_manufactura
			FROM actividad_wip
			GROUP BY a√±o, mes, wip_id, grupo_wip;
			
			-- Crear √≠ndice en tabla temporal
			CREATE INDEX idx_totales_base_lookup ON totales_base (a√±o, mes, wip_id, grupo_wip);
			
			-- Paso 5.2: Crear costos_fix con JOINs en lugar de subconsultas
			CREATE TEMP TABLE costos_fix AS
	
			SELECT
			    aw.pr_id,
			    aw.wip_id,
			    aw.a√±o,
			    aw.mes,
			    aw.grupo_wip,
			    aw.en_bd_finanzas,
			    aw.base_textil,
			    aw.base_manufactura,
			    aw.prendas_requeridas,
			    aw.factor_volumen,
			    -- POOL DIRECTO con LEFT JOIN
			    COALESCE(pm.pool_mes, 0) as pool_mes,
			    
			    -- TOTALES BASE con LEFT JOIN
			    COALESCE(tb.total_base_textil, 0) as total_base_textil,
			    COALESCE(tb.total_base_manufactura, 0) as total_base_manufactura,
			    
			    -- COSTO TEXTIL (c√°lculo directo sin subconsultas)
			    CASE WHEN aw.grupo_wip = 'textil' AND COALESCE(tb.total_base_textil, 0) > 0
			         THEN aw.base_textil * (COALESCE(pm.pool_mes, 0) / tb.total_base_textil)
			         ELSE 0 END as costo_textil,
			    
			    -- COSTO MANUFACTURA (c√°lculo directo sin subconsultas)
			    CASE WHEN aw.grupo_wip = 'manufactura' AND COALESCE(tb.total_base_manufactura, 0) > 0
			         THEN aw.base_manufactura * (COALESCE(pm.pool_mes, 0) / tb.total_base_manufactura)
			         ELSE 0 END as costo_manufactura
			
			FROM actividad_wip aw
			LEFT JOIN pools_mensuales pm ON pm.a√±o = aw.a√±o AND pm.mes_num = aw.mes AND pm.wip_id = aw.wip_id
			LEFT JOIN totales_base tb ON tb.a√±o = aw.a√±o AND tb.mes = aw.mes AND tb.wip_id = aw.wip_id AND tb.grupo_wip = aw.grupo_wip;
			--INDEX
			CREATE INDEX idx_temp_costos_fix ON costos_fix (pr_id, en_bd_finanzas, wip_id);
			    
    GET DIAGNOSTICS count_costos_fix = ROW_COUNT;
    RAISE NOTICE 'PASO 5: % registros con distribuci√≥n simple', count_costos_fix;
    
    -- =====================================================================
    -- PASO 6: AGREGAR COSTOS INDIRECTOS Y MATERIALES (SIN LEFT JOINS)
    -- =====================================================================
    -- Fechas materiales
    SELECT MAX(fecha_corrida) INTO fecha_avios_max FROM silver.costo_avios;
    SELECT MAX(fecha_corrida) INTO fecha_mp_max FROM silver.costo_materia_prima;
    
    -- Pools indirectos 2024
    SELECT 
        SUM(CASE WHEN tipo_costo = 'Costo Indirecto Fijo' THEN costo_total_usd ELSE 0 END),
        SUM(CASE WHEN tipo_costo = 'Gasto de Administraci√≥n' THEN costo_total_usd ELSE 0 END),
        SUM(CASE WHEN tipo_costo = 'Gasto de Ventas' THEN costo_total_usd ELSE 0 END)
    INTO pool_cif, pool_admin, pool_ventas
    FROM silver.costos_fijos_mensuales
    WHERE a√±o = 2024 
      AND proceso_productivo IN ('Textil', 'Manufactura')
      AND tipo_costo IN ('Gasto de Administraci√≥n', 'Gasto de Ventas', 'Costo Indirecto Fijo');
    
    -- Base distribuci√≥n indirectos
    SELECT SUM(prendas_requeridas * factor_volumen) INTO total_base_indirectos
    FROM universo_final 
    WHERE en_bd_finanzas = 1;
    
    -- Tabla final con todo
    DROP TABLE IF EXISTS costos_final;
    CREATE TEMP TABLE costos_final AS
    SELECT 
        cf.*,
        -- COSTOS INDIRECTOS (distribuci√≥n simple)
        CASE WHEN total_base_indirectos > 0 AND pool_cif > 0
             THEN (pool_cif * ((cf.prendas_requeridas * cf.factor_volumen) / total_base_indirectos)) / 
                  NULLIF((SELECT COUNT(*) FROM costos_fix cf2 WHERE cf2.pr_id = cf.pr_id AND cf2.en_bd_finanzas = 1), 0)
             ELSE 0 END as costo_indirecto_fijo,
        CASE WHEN total_base_indirectos > 0 AND pool_admin > 0
             THEN (pool_admin * ((cf.prendas_requeridas * cf.factor_volumen) / total_base_indirectos)) / 
                  NULLIF((SELECT COUNT(*) FROM costos_fix cf2 WHERE cf2.pr_id = cf.pr_id AND cf2.en_bd_finanzas = 1), 0)
             ELSE 0 END as gasto_administracion,
        CASE WHEN total_base_indirectos > 0 AND pool_ventas > 0
             THEN (pool_ventas * ((cf.prendas_requeridas * cf.factor_volumen) / total_base_indirectos)) / 
                  NULLIF((SELECT COUNT(*) FROM costos_fix cf2 WHERE cf2.pr_id = cf.pr_id AND cf2.en_bd_finanzas = 1), 0)
             ELSE 0 END as gasto_ventas,
       -- MATERIALES (solo en primer WIP por OP) - usar alias expl√≠citos
		CASE WHEN cf.wip_id = (SELECT MIN(wip_id) FROM costos_fix cf2 WHERE cf2.pr_id = cf.pr_id AND cf2.en_bd_finanzas = 1)
     		THEN COALESCE((SELECT av.imp_valorizado_neto_total FROM silver.costo_avios av 
                WHERE av.op_codigo = cf.pr_id AND av.fecha_corrida = fecha_avios_max), 0)
     			ELSE 0 END as costo_avios,
     	CASE WHEN cf.wip_id = (SELECT MIN(wip_id) FROM costos_fix cf2 WHERE cf2.pr_id = cf.pr_id AND cf2.en_bd_finanzas = 1)
     		THEN COALESCE((SELECT mp.costo_total_mp_final FROM silver.costo_materia_prima mp 
                WHERE mp.op_codigo = cf.pr_id AND mp.fecha_corrida = fecha_mp_max), 0)
     			ELSE 0 END as costo_materia_prima
    FROM costos_fix cf
    WHERE cf.en_bd_finanzas = 1;  -- Solo bd_finanzas
	--INDEX
	CREATE INDEX idx_temp_costos_final ON costos_final (pr_id, wip_id);
    GET DIAGNOSTICS count_costos_final = ROW_COUNT;
    RAISE NOTICE 'PASO 6: % registros finales', count_costos_final;
    RAISE NOTICE 'DEBUG - fecha_avios_max: %, fecha_mp_max: %', fecha_avios_max, fecha_mp_max;
	
    -- =====================================================================
    -- MODO CONSULTA (0)
    -- =====================================================================
    IF modo = 0 THEN
        RAISE NOTICE '';
        RAISE NOTICE 'MODO CONSULTA - L√ìGICA SIMPLE REPLICADA';
        RAISE NOTICE '================================================================================';
        
        -- VALIDAR TOTAL (DEBE SER 36.9M)
        RAISE NOTICE 'VALIDACION_TOTAL_SIMPLE:';
        RAISE NOTICE 'textil_total: %', (SELECT ROUND(SUM(costo_textil)::NUMERIC, 2) FROM costos_final);
        RAISE NOTICE 'manufactura_total: %', (SELECT ROUND(SUM(costo_manufactura)::NUMERIC, 2) FROM costos_final);
        RAISE NOTICE 'wip_total: %', (SELECT ROUND(SUM(costo_textil + costo_manufactura)::NUMERIC, 2) FROM costos_final);
        RAISE NOTICE 'indirectos_total: %', (SELECT ROUND(SUM(costo_indirecto_fijo + gasto_administracion + gasto_ventas)::NUMERIC, 2) FROM costos_final);
        RAISE NOTICE 'materiales_total: %', (SELECT ROUND(SUM(costo_avios + costo_materia_prima)::NUMERIC, 2) FROM costos_final);
        RAISE NOTICE 'gran_total: %', (SELECT ROUND(SUM(costo_textil + costo_manufactura + costo_indirecto_fijo + 
                     gasto_administracion + gasto_ventas + costo_avios + costo_materia_prima)::NUMERIC, 2) FROM costos_final);
        
        RAISE NOTICE '';
        RAISE NOTICE 'Si WIP total = 36.9M ‚Üí L√≥gica correcta';
        RAISE NOTICE 'Si WIP total = 51M ‚Üí A√∫n hay duplicaci√≥n';
        RAISE NOTICE 'Para insertar: modo = 1';
        RETURN;
    END IF;
    
    -- =====================================================================
    -- MODO GUARDAR (1) - SOLO COSTO_WIP_OP
    -- =====================================================================
    IF modo = 1 THEN
        RAISE NOTICE '';
        RAISE NOTICE 'MODO GUARDAR - Solo tabla COSTO_WIP_OP';
        
        -- COSTO_WIP_OP (detallado) - √öNICA INSERCI√ìN
        INSERT INTO silver.costo_wip_op (
            factory_id, pr_id, wip_id, ini_t, end_t, month_,
            prod_kg, prod_q, days_in_range, total_days, 
            prod_kg__allocated, prod_q__allocated,
            estilo_propio, cliente, tipo_de_producto, familia_de_productos, temporada,
            costo_indirecto_fijo, gasto_administracion, gasto_ventas,
            costo_textil, costo_manufactura, version_calculo, fecha_corrida
        )
        SELECT 
            wta.factory_id, wta.pr_id, wta.wip_id, wta.ini_t, wta.end_t, wta.month_,
            wta.prod_kg, wta.prod_q, wta.days_in_range, wta.total_days, 
            wta.prod_kg__allocated, wta.prod_q__allocated,
            COALESCE(bf.estilo_propio, ''), COALESCE(bf.cliente, ''), COALESCE(bf.tipo_de_producto, ''),
            COALESCE(bf.familia_de_productos, ''), COALESCE(bf.temporada, ''),
            cf.costo_indirecto_fijo, cf.gasto_administracion, cf.gasto_ventas,
            cf.costo_textil, cf.costo_manufactura,
            'FLUIDA', sp_fecha_corrida
        FROM costos_final cf
        INNER JOIN silver.wip_time_allocation wta 
            ON cf.pr_id = wta.pr_id AND cf.wip_id = wta.wip_id 
            AND EXTRACT(YEAR FROM wta.month_)::INTEGER = cf.a√±o AND EXTRACT(MONTH FROM wta.month_)::INTEGER = cf.mes
        LEFT JOIN silver.bd_finanzas bf ON cf.pr_id = bf.cod_ordpro AND bf.activo IS true
        WHERE cf.costo_textil + cf.costo_manufactura > 0;
        GET DIAGNOSTICS rows_inserted_wip = ROW_COUNT;
        
        RAISE NOTICE '';
        RAISE NOTICE 'SP COMPLETADO - SOLO COSTO_WIP_OP';
        RAISE NOTICE '   COSTO_WIP_OP: % registros insertados', rows_inserted_wip;
        RAISE NOTICE '   Version: FLUIDA';
        RAISE NOTICE '   Fecha: %', sp_fecha_corrida;
    END IF;
    
    -- Limpiar
    DROP TABLE IF EXISTS universo_base;
    DROP TABLE IF EXISTS universo_final;
    DROP TABLE IF EXISTS actividad_wip;
    DROP TABLE IF EXISTS pools_mensuales;
    DROP TABLE IF EXISTS totales_base;  -- AGREGADO: Limpiar tabla temporal
    DROP TABLE IF EXISTS costos_fix;
    DROP TABLE IF EXISTS costos_final;
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE 'ERROR: %', error_message;
        
        -- Limpiar en caso de error
        DROP TABLE IF EXISTS universo_base;
        DROP TABLE IF EXISTS universo_final;
        DROP TABLE IF EXISTS actividad_wip;
        DROP TABLE IF EXISTS pools_mensuales;
        DROP TABLE IF EXISTS totales_base;  -- AGREGADO: Limpiar tabla temporal
        DROP TABLE IF EXISTS costos_fix;
        DROP TABLE IF EXISTS costos_final;
        
        RAISE EXCEPTION '%', error_message;

END;
$procedure$

-------------------------------------------------------------------------------------

23. =====================================================================================
NOMBRE: populate_costos_hibrido_fluido
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0, IN debug integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.populate_costos_hibrido_fluido(IN modo integer DEFAULT 0, IN debug integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$

DECLARE
    error_message TEXT;
    rows_inserted_wip INTEGER := 0;
    rows_batch INTEGER := 0;
    sp_fecha_corrida TIMESTAMPTZ := NOW();
    
    pool_cif DECIMAL(18,4);
    pool_admin DECIMAL(18,4);
    pool_ventas DECIMAL(18,4);
    total_base_indirectos DECIMAL(18,4);
    
    fecha_avios_max TIMESTAMPTZ;
    fecha_mp_max TIMESTAMPTZ;
    
    count_universo_base INTEGER;
    count_universo_final INTEGER;
    count_actividad_wip INTEGER;
    count_pools_mensuales INTEGER;
    count_costos_fix INTEGER;
    count_costos_final INTEGER;
    
    batch_year INTEGER;
    batch_month INTEGER;
    
BEGIN
    RAISE NOTICE 'SP FLUIDO OPTIMIZADO - INICIO';
    RAISE NOTICE '   Fecha corrida: %', sp_fecha_corrida;
    RAISE NOTICE '';
    
    -- =====================================================================
    -- PASO 1: UNIVERSO BASE
    -- =====================================================================
    DROP TABLE IF EXISTS universo_base_final;
    
    CREATE TEMP TABLE universo_base_final AS
    SELECT DISTINCT pr_id
    FROM silver.wip_time_allocation
    WHERE pr_id IS NOT NULL
      AND month_ >= '2023-01-01'
      AND month_ < '2025-01-01';
    
    CREATE INDEX idx_ub_prid ON universo_base_final (pr_id);
    
    GET DIAGNOSTICS count_universo_base = ROW_COUNT;
    IF debug = 1 THEN
        RAISE NOTICE 'PASO 1: % OPs en universo base', count_universo_base;
    END IF;
    
    -- =====================================================================
    -- PASO 2: UNIVERSO FINAL CON BD_FINANZAS
    -- =====================================================================
    DROP TABLE IF EXISTS universo_final_final;
    
    CREATE TEMP TABLE universo_final_final AS
    SELECT 
        ub.pr_id,
        COALESCE(bf.prendas_requeridas, 1000) as prendas_requeridas,
        CASE 
            WHEN COALESCE(bf.prendas_requeridas, 1000) < 850 THEN 1.15
            WHEN COALESCE(bf.prendas_requeridas, 1000) < 1700 THEN 1.1
            WHEN COALESCE(bf.prendas_requeridas, 1000) < 5700 THEN 1
            WHEN COALESCE(bf.prendas_requeridas, 1000) >= 5700 THEN 0.9
            ELSE 1.0
        END as factor_volumen,
        CASE WHEN bf.cod_ordpro IS NOT NULL THEN 1 ELSE 0 END as en_bd_finanzas
    FROM universo_base_final ub
    LEFT JOIN silver.bd_finanzas bf 
        ON ub.pr_id = bf.cod_ordpro
        AND bf.activo IS true;
    
    CREATE INDEX idx_uf_prid ON universo_final_final (pr_id);
    CREATE INDEX idx_uf_enbd ON universo_final_final (en_bd_finanzas);

    GET DIAGNOSTICS count_universo_final = ROW_COUNT;
    IF debug = 1 THEN
        RAISE NOTICE 'PASO 2: % OPs en universo final', count_universo_final;
    END IF;
    
    -- =====================================================================
    -- PASO 3: ACTIVIDAD WIP
    -- =====================================================================
    DROP TABLE IF EXISTS actividad_wip_final;
    
    CREATE TEMP TABLE actividad_wip_final AS
    SELECT 
        wta.pr_id,
        wta.wip_id,
        EXTRACT(YEAR FROM wta.month_)::INTEGER as a√±o,
        EXTRACT(MONTH FROM wta.month_)::INTEGER as mes,
        wta.month_,
        
        CASE 
            WHEN wta.wip_id IN ('16', '14', '19a', '19c', '24', '10c') THEN 'textil'
            WHEN wta.wip_id IN ('34', '36', '40', '44', '37', '45', '49', '43', '50') THEN 'manufactura'
            ELSE 'otro'
        END as grupo_wip,
        
        COALESCE(wta.prod_kg__allocated, 0) * COALESCE(uf.factor_volumen, 1.0) as base_textil,
        COALESCE(wta.days_in_range, 0) as base_manufactura,
        
        uf.en_bd_finanzas,
        uf.prendas_requeridas,
        uf.factor_volumen,
        COALESCE(wta.prod_q__allocated, 0) as q_allocated,
        COALESCE(wta.prod_kg__allocated, 0) as kg_allocated,
        COALESCE(wta.days_in_range, 0) as days_in_range
    
    FROM silver.wip_time_allocation wta
    INNER JOIN universo_final_final uf 
        ON wta.pr_id = uf.pr_id
    WHERE wta.wip_id IN ('16', '14', '19a', '19c', '24', '10c', '34', '36', '40', '44', '37', '45', '49', '43', '50')
      AND wta.month_ >= '2023-01-01'
      AND wta.month_ < '2025-01-01';
    
    CREATE INDEX idx_aw_year_mes ON actividad_wip_final (a√±o, mes, wip_id, grupo_wip);
    CREATE INDEX idx_aw_prid ON actividad_wip_final (pr_id);
    
    GET DIAGNOSTICS count_actividad_wip = ROW_COUNT;
    IF debug = 1 THEN
        RAISE NOTICE 'PASO 3: % registros actividad WIP', count_actividad_wip;
    END IF;
    
    -- =====================================================================
    -- PASO 4: POOLS MENSUALES
    -- =====================================================================
    DROP TABLE IF EXISTS pools_mensuales_final;
    
    CREATE TEMP TABLE pools_mensuales_final AS
    SELECT 
        a√±o,
        CASE LOWER(TRIM(mes))
            WHEN 'ene' THEN 1 WHEN 'feb' THEN 2 WHEN 'mar' THEN 3 WHEN 'abr' THEN 4
            WHEN 'may' THEN 5 WHEN 'jun' THEN 6 WHEN 'jul' THEN 7 WHEN 'ago' THEN 8
            WHEN 'sep' THEN 9 WHEN 'oct' THEN 10 WHEN 'nov' THEN 11 WHEN 'dic' THEN 12
        END as mes_num,
        wip_id,
        SUM(costo) as pool_mes
    FROM silver.costos_procesos
    WHERE a√±o IN (2023, 2024)  
      AND costo > 0
      AND wip_id IN ('16', '14', '19a', '19c', '24', '10c', '34', '36', '40', '44', '37', '45', '49', '43', '50')
    GROUP BY a√±o, mes, wip_id
    HAVING CASE LOWER(TRIM(mes))
            WHEN 'ene' THEN 1 WHEN 'feb' THEN 2 WHEN 'mar' THEN 3 WHEN 'abr' THEN 4
            WHEN 'may' THEN 5 WHEN 'jun' THEN 6 WHEN 'jul' THEN 7 WHEN 'ago' THEN 8
            WHEN 'sep' THEN 9 WHEN 'oct' THEN 10 WHEN 'nov' THEN 11 WHEN 'dic' THEN 12
        END IS NOT NULL;
    
    CREATE INDEX idx_pm_year_mes_wip ON pools_mensuales_final (a√±o, mes_num, wip_id);
    
    GET DIAGNOSTICS count_pools_mensuales = ROW_COUNT;
    IF debug = 1 THEN
        RAISE NOTICE 'PASO 4: % pools mensuales', count_pools_mensuales;
    END IF;
    
    -- =====================================================================
    -- PASO 5: DISTRIBUCI√ìN
    -- =====================================================================
    DROP TABLE IF EXISTS totales_base_final;
    
    CREATE TEMP TABLE totales_base_final AS
    SELECT 
        a√±o, mes, wip_id, grupo_wip,
        SUM(CASE WHEN grupo_wip = 'textil' THEN base_textil ELSE 0 END) as total_base_textil,
        SUM(CASE WHEN grupo_wip = 'manufactura' THEN base_manufactura ELSE 0 END) as total_base_manufactura
    FROM actividad_wip_final
    GROUP BY a√±o, mes, wip_id, grupo_wip;
    
    CREATE INDEX idx_tb_year_mes ON totales_base_final (a√±o, mes, wip_id, grupo_wip);
    
    DROP TABLE IF EXISTS costos_fix_final;
    
    CREATE TEMP TABLE costos_fix_final AS
    SELECT
        aw.pr_id,
        aw.wip_id,
        aw.a√±o,
        aw.mes,
        aw.grupo_wip,
        aw.en_bd_finanzas,
        aw.base_textil,
        aw.base_manufactura,
        aw.prendas_requeridas,
        aw.factor_volumen,
        
        CASE WHEN aw.grupo_wip = 'textil' AND tb.total_base_textil > 0
             THEN aw.base_textil * (pm.pool_mes / tb.total_base_textil)
             ELSE 0 END as costo_textil,
        
        CASE WHEN aw.grupo_wip = 'manufactura' AND tb.total_base_manufactura > 0
             THEN aw.base_manufactura * (pm.pool_mes / tb.total_base_manufactura)
             ELSE 0 END as costo_manufactura
    
    FROM actividad_wip_final aw
    LEFT JOIN pools_mensuales_final pm 
        ON pm.a√±o = aw.a√±o 
        AND pm.mes_num = aw.mes 
        AND pm.wip_id = aw.wip_id
    LEFT JOIN totales_base_final tb 
        ON tb.a√±o = aw.a√±o 
        AND tb.mes = aw.mes 
        AND tb.wip_id = aw.wip_id 
        AND tb.grupo_wip = aw.grupo_wip;
    
    CREATE INDEX idx_cf_prid ON costos_fix_final (pr_id);
    CREATE INDEX idx_cf_enbd ON costos_fix_final (en_bd_finanzas);
    CREATE INDEX idx_cf_year_mes ON costos_fix_final (a√±o, mes);
    
    GET DIAGNOSTICS count_costos_fix = ROW_COUNT;
    IF debug = 1 THEN
        RAISE NOTICE 'PASO 5: % registros con costos', count_costos_fix;
    END IF;
    
    -- =====================================================================
    -- PASO 6: MATERIALES Y COSTOS INDIRECTOS
    -- =====================================================================
    SELECT MAX(fecha_corrida) INTO fecha_avios_max FROM silver.costo_avios;
    SELECT MAX(fecha_corrida) INTO fecha_mp_max FROM silver.costo_materia_prima;
    
    SELECT 
        SUM(CASE WHEN tipo_costo = 'Costo Indirecto Fijo' THEN costo_total_usd ELSE 0 END),
        SUM(CASE WHEN tipo_costo = 'Gasto de Administraci√≥n' THEN costo_total_usd ELSE 0 END),
        SUM(CASE WHEN tipo_costo = 'Gasto de Ventas' THEN costo_total_usd ELSE 0 END)
    INTO pool_cif, pool_admin, pool_ventas
    FROM silver.costos_fijos_mensuales
    WHERE a√±o = 2024 
      AND proceso_productivo IN ('Textil', 'Manufactura')
      AND tipo_costo IN ('Gasto de Administraci√≥n', 'Gasto de Ventas', 'Costo Indirecto Fijo');
    
    SELECT SUM(prendas_requeridas * factor_volumen) INTO total_base_indirectos
    FROM universo_final_final 
    WHERE en_bd_finanzas = 1;
    
    DROP TABLE IF EXISTS wips_por_op;
    CREATE TEMP TABLE wips_por_op AS
    SELECT 
        pr_id,
        COUNT(*) as num_wips,
        MIN(wip_id) as primer_wip
    FROM costos_fix_final
    WHERE en_bd_finanzas = 1
    GROUP BY pr_id;
    
    CREATE INDEX idx_wpo_prid ON wips_por_op (pr_id);
    
    DROP TABLE IF EXISTS materiales_temp;
    CREATE TEMP TABLE materiales_temp AS
    SELECT 
        av.op_codigo as pr_id,
        COALESCE(av.imp_valorizado_neto_total, 0) as costo_avios,
        COALESCE(mp.costo_total_mp_final, 0) as costo_materia_prima
    FROM silver.costo_avios av
    LEFT JOIN silver.costo_materia_prima mp 
        ON av.op_codigo = mp.op_codigo 
        AND mp.fecha_corrida = fecha_mp_max
    WHERE av.fecha_corrida = fecha_avios_max;
    
    CREATE INDEX idx_mt_prid ON materiales_temp (pr_id);
    
    DROP TABLE IF EXISTS costos_final_final;
    CREATE TEMP TABLE costos_final_final AS
    SELECT 
        cf.*,
        
        CASE WHEN total_base_indirectos > 0 AND pool_cif > 0 AND cf.en_bd_finanzas = 1
             THEN (pool_cif * ((cf.prendas_requeridas * cf.factor_volumen) / total_base_indirectos)) / wpo.num_wips
             ELSE 0 END as costo_indirecto_fijo,
        
        CASE WHEN total_base_indirectos > 0 AND pool_admin > 0 AND cf.en_bd_finanzas = 1
             THEN (pool_admin * ((cf.prendas_requeridas * cf.factor_volumen) / total_base_indirectos)) / wpo.num_wips
             ELSE 0 END as gasto_administracion,
        
        CASE WHEN total_base_indirectos > 0 AND pool_ventas > 0 AND cf.en_bd_finanzas = 1
             THEN (pool_ventas * ((cf.prendas_requeridas * cf.factor_volumen) / total_base_indirectos)) / wpo.num_wips
             ELSE 0 END as gasto_ventas,
        
        CASE WHEN cf.wip_id = wpo.primer_wip THEN COALESCE(mt.costo_avios, 0) ELSE 0 END as costo_avios,
        CASE WHEN cf.wip_id = wpo.primer_wip THEN COALESCE(mt.costo_materia_prima, 0) ELSE 0 END as costo_materia_prima
    
    FROM costos_fix_final cf
    LEFT JOIN wips_por_op wpo ON cf.pr_id = wpo.pr_id AND cf.en_bd_finanzas = 1
    LEFT JOIN materiales_temp mt ON cf.pr_id = mt.pr_id;
    
    CREATE INDEX idx_cff_prid_wip ON costos_final_final (pr_id, wip_id);
    CREATE INDEX idx_cff_year_mes ON costos_final_final (a√±o, mes);
    
    GET DIAGNOSTICS count_costos_final = ROW_COUNT;
    IF debug = 1 THEN
        RAISE NOTICE 'PASO 6: % registros finales', count_costos_final;
    END IF;
    
    -- =====================================================================
    -- MODO CONSULTA (0)
    -- =====================================================================
    IF modo = 0 THEN
        RAISE NOTICE '';
        RAISE NOTICE 'MODO CONSULTA';
        RAISE NOTICE '========================================';
        
        RAISE NOTICE 'textil_total: %', (SELECT ROUND(SUM(costo_textil)::NUMERIC, 2) FROM costos_final_final);
        RAISE NOTICE 'manufactura_total: %', (SELECT ROUND(SUM(costo_manufactura)::NUMERIC, 2) FROM costos_final_final);
        RAISE NOTICE 'wip_total: %', (SELECT ROUND(SUM(costo_textil + costo_manufactura)::NUMERIC, 2) FROM costos_final_final);
        RAISE NOTICE 'indirectos_total: %', (SELECT ROUND(SUM(costo_indirecto_fijo + gasto_administracion + gasto_ventas)::NUMERIC, 2) FROM costos_final_final);
        RAISE NOTICE 'materiales_total: %', (SELECT ROUND(SUM(costo_avios + costo_materia_prima)::NUMERIC, 2) FROM costos_final_final);
        RAISE NOTICE 'gran_total: %', (SELECT ROUND(SUM(costo_textil + costo_manufactura + costo_indirecto_fijo + 
                     gasto_administracion + gasto_ventas + costo_avios + costo_materia_prima)::NUMERIC, 2) FROM costos_final_final);
        
        RAISE NOTICE '';
        RAISE NOTICE 'Total OPs: %', (SELECT COUNT(DISTINCT pr_id) FROM costos_final_final);
        RAISE NOTICE 'OPs en bd_finanzas: %', (SELECT COUNT(DISTINCT pr_id) FROM costos_final_final WHERE en_bd_finanzas = 1);
        RAISE NOTICE '';
        RAISE NOTICE 'Para insertar ejecuta: CALL silver.populate_costos_hibrido_fluido(1, 1)';
        RETURN;
    END IF;
    
    -- =====================================================================
    -- MODO GUARDAR (1) - POR LOTES MENSUALES
    -- =====================================================================
    IF modo = 1 THEN
        RAISE NOTICE '';
        RAISE NOTICE 'MODO GUARDAR - Inserci√≥n por lotes mensuales';
        RAISE NOTICE '';
        
        -- Iterar por cada a√±o-mes
        FOR batch_year, batch_month IN 
            SELECT DISTINCT a√±o, mes 
            FROM costos_final_final 
            ORDER BY a√±o, mes
        LOOP
            RAISE NOTICE '  Procesando: A√±o %, Mes %', batch_year, batch_month;
            
            DROP TABLE IF EXISTS datos_batch_temp;
            
            -- Preparar lote del mes
            CREATE TEMP TABLE datos_batch_temp AS
            SELECT 
                COALESCE(wta.factory_id, 'DEFAULT') as factory_id,
                wta.pr_id,
                wta.wip_id,
                wta.ini_t,
                wta.end_t,
                wta.month_,
                wta.prod_kg,
                wta.prod_q,
                wta.days_in_range,
                wta.total_days,
                wta.prod_kg__allocated,
                wta.prod_q__allocated,
                COALESCE(bf.estilo_propio, '') as estilo_propio,
                COALESCE(bf.cliente, '') as cliente,
                COALESCE(bf.tipo_de_producto, '') as tipo_de_producto,
                COALESCE(bf.familia_de_productos, '') as familia_de_productos,
                COALESCE(bf.temporada, '') as temporada,
                cf.costo_indirecto_fijo,
                cf.gasto_administracion,
                cf.gasto_ventas,
                cf.costo_textil,
                cf.costo_manufactura
            FROM costos_final_final cf
            INNER JOIN silver.wip_time_allocation wta 
                ON cf.pr_id = wta.pr_id 
                AND cf.wip_id = wta.wip_id 
                AND EXTRACT(YEAR FROM wta.month_)::INTEGER = cf.a√±o 
                AND EXTRACT(MONTH FROM wta.month_)::INTEGER = cf.mes
            LEFT JOIN silver.bd_finanzas bf 
                ON cf.pr_id = bf.cod_ordpro 
                AND bf.activo IS true
            WHERE cf.a√±o = batch_year 
              AND cf.mes = batch_month
              AND wta.month_ IS NOT NULL;
            
            -- Insertar lote
            INSERT INTO silver.costo_wip_op (
                factory_id, pr_id, wip_id, ini_t, end_t, month_,
                prod_kg, prod_q, days_in_range, total_days, 
                prod_kg__allocated, prod_q__allocated,
                estilo_propio, cliente, tipo_de_producto, familia_de_productos, temporada,
                costo_indirecto_fijo, gasto_administracion, gasto_ventas,
                costo_textil, costo_manufactura, version_calculo, fecha_corrida
            )
            SELECT 
                factory_id, pr_id, wip_id, ini_t, end_t, month_,
                prod_kg, prod_q, days_in_range, total_days, 
                prod_kg__allocated, prod_q__allocated,
                estilo_propio, cliente, tipo_de_producto, familia_de_productos, temporada,
                costo_indirecto_fijo, gasto_administracion, gasto_ventas,
                costo_textil, costo_manufactura,
                'FLUIDA', sp_fecha_corrida
            FROM datos_batch_temp;
            
            GET DIAGNOSTICS rows_batch = ROW_COUNT;
            rows_inserted_wip := rows_inserted_wip + rows_batch;
            
            RAISE NOTICE '    -> Insertados: % registros', rows_batch;
            
            DROP TABLE IF EXISTS datos_batch_temp;
            
        END LOOP;
        
        RAISE NOTICE '';
        RAISE NOTICE '‚úì COMPLETADO - % registros insertados en total', rows_inserted_wip;
        RAISE NOTICE '‚úì Version: FLUIDA';
        RAISE NOTICE '‚úì Fecha: %', sp_fecha_corrida;
    END IF;
    
    -- Limpiar
    DROP TABLE IF EXISTS universo_base_final, universo_final_final, actividad_wip_final;
    DROP TABLE IF EXISTS pools_mensuales_final, totales_base_final, costos_fix_final;
    DROP TABLE IF EXISTS costos_final_final, wips_por_op, materiales_temp, datos_batch_temp;
    
EXCEPTION 
    WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS error_message = MESSAGE_TEXT;
        RAISE NOTICE 'ERROR: %', error_message;
        
        DROP TABLE IF EXISTS universo_base_final, universo_final_final, actividad_wip_final;
        DROP TABLE IF EXISTS pools_mensuales_final, totales_base_final, costos_fix_final;
        DROP TABLE IF EXISTS costos_final_final, wips_por_op, materiales_temp, datos_batch_temp;
        
        RAISE EXCEPTION '%', error_message;
END;
$procedure$

-------------------------------------------------------------------------------------

24. =====================================================================================
NOMBRE: populate_esfuerzo_op_detalle
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0, IN debug integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.populate_esfuerzo_op_detalle(IN modo integer DEFAULT 0, IN debug integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    rows_updated INTEGER := 0;
    tiempo_inicio TIMESTAMPTZ := NOW();
    
    -- Variables para verificaciones
    total_registros INTEGER;
    ops_unicas INTEGER;
    total_consulta INTEGER;
    esfuerzo_promedio DECIMAL(10,2);
    duracion_minutos DECIMAL(10,2);
    
    -- Variables para factorizaci√≥n M√©todo 2
    media_manufactura DECIMAL(18,4);
    min_manufactura DECIMAL(18,4);
    r_manufactura DECIMAL(18,4);
    limite1 DECIMAL(18,4);
    limite2 DECIMAL(18,4);
    limite3 DECIMAL(18,4);
    limite4 DECIMAL(18,4);
    
    -- Variable para records en loops
    rec RECORD;
    
BEGIN
    -- Verificar prerequisito
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle'
    ) THEN
        RAISE EXCEPTION 'ERROR: Tabla costo_op_detalle no existe. Prerequisito faltante: tabla costo_op_detalle';
    END IF;
    
    RAISE NOTICE '%', format('INICIANDO C√ÅLCULO VARIABLES DE ESFUERZO + kg_prenda [MULTI-VERSIONES OPTIMIZADO]...');
    
    -- Verificar contexto multi-versiones
    SELECT COUNT(*) INTO total_registros FROM silver.costo_op_detalle;
    SELECT COUNT(DISTINCT cod_ordpro) INTO ops_unicas FROM silver.costo_op_detalle;
    
    RAISE NOTICE '%', format('Registros: %s total, %s OPs √∫nicas', total_registros, ops_unicas);
    
    -- Agregar columnas nuevas (si no existen)
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' AND column_name = 'pre_unitario'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN pre_unitario DECIMAL(18,4) DEFAULT 0;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' AND column_name = 'kg_prenda'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN kg_prenda DECIMAL(18,4) DEFAULT 0;
        RAISE NOTICE '%', format('Columna kg_prenda agregada');
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' AND column_name = 'lote_estilo_kg'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN lote_estilo_kg DECIMAL(18,4) DEFAULT 0;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' AND column_name = 'diversidad_familias'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN diversidad_familias INTEGER DEFAULT 0;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' AND column_name = 'diversidad_estilos'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN diversidad_estilos INTEGER DEFAULT 0;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' AND column_name = 'esfuerzo_textil'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN esfuerzo_textil INTEGER DEFAULT 1;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' AND column_name = 'esfuerzo_manufactura'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN esfuerzo_manufactura INTEGER DEFAULT 1;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' AND column_name = 'esfuerzo_total'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN esfuerzo_total INTEGER DEFAULT 2;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' AND column_name = 'indice_complejidad'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN indice_complejidad DECIMAL(18,6) DEFAULT NULL;
    END IF;

    -- ============================================================================
    -- NUEVA SECCI√ìN: kg_prenda POR ESTILO
    -- ============================================================================
    RAISE NOTICE '%', format('Calculando kg_prenda por estilo...');
    
    DROP TABLE IF EXISTS kg_prenda_estilo;
    CREATE TEMP TABLE kg_prenda_estilo (
        cod_estpro VARCHAR(50),
        kilos_prenda DECIMAL(18,4),
        fec_ult_costeo TIMESTAMPTZ
    );
    
    -- Obtener el registro con fecha m√°s reciente por estilo
    INSERT INTO kg_prenda_estilo
    SELECT DISTINCT ON (cod_estpro)
        cod_estpro,
        kilos_prenda,
        fec_ult_costeo
    FROM bronze.tg_cotizacion_estilospropios
    WHERE cod_estpro IS NOT NULL
      AND kilos_prenda IS NOT NULL
      AND fec_ult_costeo IS NOT NULL
    ORDER BY cod_estpro, fec_ult_costeo DESC;

    CREATE INDEX idx_kg_prenda_estilo ON kg_prenda_estilo(cod_estpro);
    RAISE NOTICE '%', format('kg_prenda calculados: %s estilos', (SELECT COUNT(*) FROM kg_prenda_estilo));

    -- ============================================================================
    -- SECCI√ìN 1: PRECIOS OP
    -- ============================================================================
    RAISE NOTICE '%', format('Calculando precios por OP...');
    
    DROP TABLE IF EXISTS precios_op;
    CREATE TEMP TABLE precios_op (
        cod_ordpro VARCHAR(50),
        pre_unitario DECIMAL(18,4)
    );
    
    INSERT INTO precios_op
    SELECT DISTINCT
        lot.cod_ordpro,
        AVG(ven.pre_unitario) as pre_unitario
    FROM bronze.tg_lotestpro lot
    INNER JOIN bronze.cn_ventas_prendas ven 
        ON lot.cod_purord::text = ven.cod_purord::text
        AND lot.cod_lotpurord::text = ven.cod_lotpurord::text
    WHERE lot.cod_ordpro IS NOT NULL
      AND ven.pre_unitario IS NOT NULL
      AND ven.pre_unitario > 0
    GROUP BY lot.cod_ordpro;

    CREATE INDEX idx_precios_op_ordpro ON precios_op(cod_ordpro);
    RAISE NOTICE '%', format('Precios calculados: %s registros', (SELECT COUNT(*) FROM precios_op));

    -- ============================================================================
    -- SECCI√ìN 2: LOTES ESTILO
    -- ============================================================================
    RAISE NOTICE '%', format('Calculando lotes por estilo...');
    
    DROP TABLE IF EXISTS lotes_estilo;
    CREATE TEMP TABLE lotes_estilo (
        cod_ordpro VARCHAR(50),
        cod_estpro VARCHAR(50),
        lote_estilo_kg DECIMAL(18,4)
    );
    
    INSERT INTO lotes_estilo
    SELECT 
        op.cod_ordpro,
        op.cod_estpro,
        SUM(COALESCE(cot.kilos_prenda, 0) * COALESCE(ven.num_prendas, 0)) as lote_estilo_kg
    FROM bronze.es_ordpro op
    LEFT JOIN bronze.tg_cotizacion_estilospropios cot ON op.cod_estpro::text = cot.cod_estpro::text
    LEFT JOIN bronze.tg_lotestpro lot ON op.cod_ordpro::text = lot.cod_ordpro::text
    LEFT JOIN bronze.cn_ventas_prendas ven ON lot.cod_purord::text = ven.cod_purord::text AND lot.cod_lotpurord::text = ven.cod_lotpurord::text
    WHERE op.cod_ordpro IS NOT NULL
      AND op.cod_estpro IS NOT NULL
    GROUP BY op.cod_ordpro, op.cod_estpro;

    CREATE INDEX idx_lotes_estilo_ordpro ON lotes_estilo(cod_ordpro);
    CREATE INDEX idx_lotes_estilo_estpro ON lotes_estilo(cod_estpro);
    RAISE NOTICE '%', format('Lotes calculados: %s registros', (SELECT COUNT(*) FROM lotes_estilo));

    -- ============================================================================
    -- SECCI√ìN 3: DIVERSIDAD MARCA
    -- ============================================================================
    RAISE NOTICE '%', format('Calculando diversidad por marca...');
    
    DROP TABLE IF EXISTS diversidad_marca;
    CREATE TEMP TABLE diversidad_marca (
        cod_ordpro VARCHAR(50),
        diversidad_familias INTEGER,
        diversidad_estilos INTEGER
    );
    
    INSERT INTO diversidad_marca
    SELECT 
        cod_principal.cod_ordpro,
        COUNT(DISTINCT cod_otros.familia_de_productos) as diversidad_familias,
        COUNT(DISTINCT cod_otros.estilo_propio) as diversidad_estilos
    FROM (
        SELECT DISTINCT cod_ordpro, cliente
        FROM silver.costo_op_detalle
        WHERE cliente IS NOT NULL
    ) cod_principal
    INNER JOIN (
        SELECT DISTINCT cliente, familia_de_productos, estilo_propio
        FROM silver.costo_op_detalle
        WHERE familia_de_productos IS NOT NULL
          AND estilo_propio IS NOT NULL
    ) cod_otros ON cod_principal.cliente::text = cod_otros.cliente::text
    GROUP BY cod_principal.cod_ordpro, cod_principal.cliente;

    CREATE INDEX idx_diversidad_marca_ordpro ON diversidad_marca(cod_ordpro);
    RAISE NOTICE '%', format('Diversidad calculada: %s registros', (SELECT COUNT(*) FROM diversidad_marca));

    -- ============================================================================
    -- SECCI√ìN 4: COLORES POR ESTILO (OPTIMIZADO)
    -- ============================================================================
    RAISE NOTICE '%', format('Calculando colores por estilo...');
    
    DROP TABLE IF EXISTS colores_por_estilo;
    CREATE TEMP TABLE colores_por_estilo (
        cod_estpro VARCHAR(50),
        cantidad_colores_sinstd INTEGER
    );
    
    INSERT INTO colores_por_estilo
    SELECT 
        ecp.cod_estpro,
        COUNT(DISTINCT ecp.cod_colcli) as cantidad_colores_sinstd
    FROM bronze.tg_estclicolpre ecp 
    WHERE ecp.cod_colcli IS NOT NULL 
      AND ecp.cod_colcli::text != 'STD'
      AND ecp.cod_estpro IS NOT NULL
    GROUP BY ecp.cod_estpro;
    
    CREATE INDEX idx_colores_por_estilo_estpro ON colores_por_estilo(cod_estpro);
    RAISE NOTICE '%', format('Colores calculados: %s registros', (SELECT COUNT(*) FROM colores_por_estilo));

    -- ============================================================================
    -- SECCI√ìN 5: TELAS POR ESTILO (OPTIMIZADO)
    -- ============================================================================
    RAISE NOTICE '%', format('Calculando telas por estilo...');
    
    DROP TABLE IF EXISTS telas_por_estilo;
    CREATE TEMP TABLE telas_por_estilo (
        cod_estpro VARCHAR(50),
        cantidad_telas_unicas INTEGER
    );
    
    INSERT INTO telas_por_estilo
    SELECT 
        tctm.cod_estpro,
        COUNT(DISTINCT tctm.cod_tela) as cantidad_telas_unicas
    FROM bronze.tg_cotizacion_telas_matriz tctm 
    WHERE tctm.cod_tela IS NOT NULL
      AND tctm.cod_estpro IS NOT NULL
    GROUP BY tctm.cod_estpro;
    
    CREATE INDEX idx_telas_por_estilo_estpro ON telas_por_estilo(cod_estpro);
    RAISE NOTICE '%', format('Telas calculadas: %s registros', (SELECT COUNT(*) FROM telas_por_estilo));

    -- ============================================================================
    -- SECCI√ìN 6: ESFUERZOS BASE (SIN SUBCONSULTAS)
    -- ============================================================================
    RAISE NOTICE '%', format('Consolidando esfuerzos base...');
    
    DROP TABLE IF EXISTS esfuerzos_base;
    CREATE TEMP TABLE esfuerzos_base (
        cod_ordpro VARCHAR(50),
        cod_estpro VARCHAR(50),
        cantidad_colores_sinstd INTEGER,
        cantidad_telas_unicas INTEGER,
        tiempo_total_minutos DECIMAL(18,4)
    );
    
    INSERT INTO esfuerzos_base
    SELECT 
        op.cod_ordpro,
        op.cod_estpro,
        COALESCE(cpe.cantidad_colores_sinstd, 0) as cantidad_colores_sinstd,
        COALESCE(tpe.cantidad_telas_unicas, 0) as cantidad_telas_unicas,
        AVG(COALESCE(cot.min_corte, 0) + COALESCE(cot.min_costura, 0) + COALESCE(cot.min_acabado, 0)) as tiempo_total_minutos
    FROM bronze.es_ordpro op
    LEFT JOIN bronze.tg_cotizacion_estilospropios cot ON op.cod_estpro::text = cot.cod_estpro::text
    LEFT JOIN colores_por_estilo cpe ON op.cod_estpro::text = cpe.cod_estpro::text
    LEFT JOIN telas_por_estilo tpe ON op.cod_estpro::text = tpe.cod_estpro::text
    WHERE op.cod_ordpro IS NOT NULL
    GROUP BY op.cod_ordpro, op.cod_estpro, cpe.cantidad_colores_sinstd, tpe.cantidad_telas_unicas;

    CREATE INDEX idx_esfuerzos_base_ordpro ON esfuerzos_base(cod_ordpro);
    CREATE INDEX idx_esfuerzos_base_estpro ON esfuerzos_base(cod_estpro);
    RAISE NOTICE '%', format('Esfuerzos base calculados: %s registros', (SELECT COUNT(*) FROM esfuerzos_base));

    -- ============================================================================
    -- SECCI√ìN 7: FACTORIZACI√ìN M√âTODO 2
    -- ============================================================================
    RAISE NOTICE '%', format('Calculando factorizaci√≥n para manufactura...');
    
    SELECT 
        AVG(tiempo_total_minutos),
        MIN(tiempo_total_minutos)
    INTO media_manufactura, min_manufactura
    FROM esfuerzos_base 
    WHERE tiempo_total_minutos > 0;
    
    r_manufactura := CASE 
        WHEN media_manufactura > min_manufactura THEN (media_manufactura - min_manufactura) / 5.0 
        ELSE 1 
    END;
    
    limite1 := min_manufactura + 2 * r_manufactura;
    limite2 := min_manufactura + 4 * r_manufactura;
    limite3 := min_manufactura + 6 * r_manufactura;
    limite4 := min_manufactura + 8 * r_manufactura;

    RAISE NOTICE '%', format('L√≠mites manufactura - L1: %s, L2: %s, L3: %s, L4: %s', 
                 ROUND(limite1::NUMERIC, 2), ROUND(limite2::NUMERIC, 2), 
                 ROUND(limite3::NUMERIC, 2), ROUND(limite4::NUMERIC, 2));

    -- ============================================================================
    -- SECCI√ìN 8: CONSOLIDACI√ìN FINAL (CON kg_prenda)
    -- ============================================================================
    RAISE NOTICE '%', format('Consolidando datos calculados...');
    
    DROP TABLE IF EXISTS datos_calculados;
    CREATE TEMP TABLE datos_calculados (
        cod_ordpro VARCHAR(50),
        pre_unitario DECIMAL(18,4),
        kg_prenda DECIMAL(18,4),
        lote_estilo_kg DECIMAL(18,4),
        diversidad_familias INTEGER,
        diversidad_estilos INTEGER,
        cantidad_colores_sinstd INTEGER,
        cantidad_telas_unicas INTEGER,
        tiempo_total_minutos DECIMAL(18,4),
        esfuerzo_textil INTEGER,
        esfuerzo_manufactura INTEGER,
        esfuerzo_total INTEGER,
        indice_complejidad DECIMAL(18,6)
    );
    
    INSERT INTO datos_calculados
    SELECT 
        eb.cod_ordpro,
        COALESCE(po.pre_unitario, 0) as pre_unitario,
        COALESCE(kp.kilos_prenda, 0) as kg_prenda,
        COALESCE(le.lote_estilo_kg, 0) as lote_estilo_kg,
        COALESCE(dm.diversidad_familias, 0) as diversidad_familias,
        COALESCE(dm.diversidad_estilos, 0) as diversidad_estilos,
        eb.cantidad_colores_sinstd,
        eb.cantidad_telas_unicas,
        eb.tiempo_total_minutos,
        -- Esfuerzo textil (rangos fijos)
        CASE 
            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 1 THEN 1
            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 3 THEN 2
            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 10 THEN 3
            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 17 THEN 4
            ELSE 5
        END as esfuerzo_textil,
        -- Esfuerzo manufactura (intervalos din√°micos)
        CASE 
            WHEN eb.tiempo_total_minutos <= 0 THEN 1
            WHEN eb.tiempo_total_minutos <= limite1 THEN 1
            WHEN eb.tiempo_total_minutos <= limite2 THEN 2
            WHEN eb.tiempo_total_minutos <= limite3 THEN 3
            WHEN eb.tiempo_total_minutos <= limite4 THEN 4
            ELSE 5
        END as esfuerzo_manufactura,
        -- Esfuerzo total
        (CASE 
            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 1 THEN 1
            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 3 THEN 2
            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 10 THEN 3
            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 17 THEN 4
            ELSE 5
        END + 
        CASE 
            WHEN eb.tiempo_total_minutos <= 0 THEN 1
            WHEN eb.tiempo_total_minutos <= limite1 THEN 1
            WHEN eb.tiempo_total_minutos <= limite2 THEN 2
            WHEN eb.tiempo_total_minutos <= limite3 THEN 3
            WHEN eb.tiempo_total_minutos <= limite4 THEN 4
            ELSE 5
        END) as esfuerzo_total,
        -- √çndice de complejidad: LOG NATURAL
        CASE 
            WHEN COALESCE(le.lote_estilo_kg, 0) <= 0 THEN NULL
            WHEN COALESCE(dm.diversidad_familias, 0) = 0 THEN NULL
            WHEN COALESCE(dm.diversidad_estilos, 0) = 0 THEN NULL
            ELSE 
                CASE 
                    WHEN (
                        ((CASE 
                            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 1 THEN 1
                            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 3 THEN 2
                            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 10 THEN 3
                            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 17 THEN 4
                            ELSE 5
                        END + 
                        CASE 
                            WHEN eb.tiempo_total_minutos <= 0 THEN 1
                            WHEN eb.tiempo_total_minutos <= limite1 THEN 1
                            WHEN eb.tiempo_total_minutos <= limite2 THEN 2
                            WHEN eb.tiempo_total_minutos <= limite3 THEN 3
                            WHEN eb.tiempo_total_minutos <= limite4 THEN 4
                            ELSE 5
                        END) * dm.diversidad_familias * dm.diversidad_estilos) / le.lote_estilo_kg
                    ) > 0 THEN 
                        LN(((CASE 
                            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 1 THEN 1
                            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 3 THEN 2
                            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 10 THEN 3
                            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 17 THEN 4
                            ELSE 5
                        END + 
                        CASE 
                            WHEN eb.tiempo_total_minutos <= 0 THEN 1
                            WHEN eb.tiempo_total_minutos <= limite1 THEN 1
                            WHEN eb.tiempo_total_minutos <= limite2 THEN 2
                            WHEN eb.tiempo_total_minutos <= limite3 THEN 3
                            WHEN eb.tiempo_total_minutos <= limite4 THEN 4
                            ELSE 5
                        END)::DECIMAL(18,6) * dm.diversidad_familias::DECIMAL(18,6) * dm.diversidad_estilos::DECIMAL(18,6)) / le.lote_estilo_kg::DECIMAL(18,6))
                    ELSE NULL
                END
        END as indice_complejidad
    FROM esfuerzos_base eb
    LEFT JOIN precios_op po ON eb.cod_ordpro::text = po.cod_ordpro::text
    LEFT JOIN kg_prenda_estilo kp ON eb.cod_estpro::text = kp.cod_estpro::text
    LEFT JOIN lotes_estilo le ON eb.cod_ordpro::text = le.cod_ordpro::text
    LEFT JOIN diversidad_marca dm ON eb.cod_ordpro::text = dm.cod_ordpro::text;
    
    GET DIAGNOSTICS total_consulta = ROW_COUNT;
    RAISE NOTICE '%', format('Datos consolidados: %s registros', total_consulta);
    
    -- MODO CONSULTA (0)
    IF modo = 0 THEN
        RAISE NOTICE '%', format('MODO CONSULTA - Variables calculadas SIN GUARDAR');
        RAISE NOTICE '';
        RAISE NOTICE '%', format('TOP 10 registros por esfuerzo total e √≠ndice de complejidad:');
        
        FOR rec IN
            SELECT 
                dc.cod_ordpro,
                ROUND(dc.pre_unitario::NUMERIC, 2) as pre_unitario,
                ROUND(dc.kg_prenda::NUMERIC, 4) as kg_prenda,
                ROUND(dc.lote_estilo_kg::NUMERIC, 2) as lote_estilo_kg,
                dc.diversidad_familias,
                dc.diversidad_estilos,
                dc.esfuerzo_textil,
                dc.esfuerzo_manufactura,
                dc.esfuerzo_total,
                ROUND(COALESCE(dc.indice_complejidad, 0)::NUMERIC, 6) as indice_complejidad
            FROM datos_calculados dc
            ORDER BY dc.esfuerzo_total DESC, dc.indice_complejidad DESC NULLS LAST
            LIMIT 10
        LOOP
            RAISE NOTICE '%', format('   %s: Precio: %s, kg_prenda: %s kg, Lote: %s kg, Familias: %s, Estilos: %s, Textil: %s, Manuf: %s, Total: %s, √çndice: %s', 
                                    rec.cod_ordpro, rec.pre_unitario, rec.kg_prenda, rec.lote_estilo_kg, rec.diversidad_familias, 
                                    rec.diversidad_estilos, rec.esfuerzo_textil, rec.esfuerzo_manufactura, rec.esfuerzo_total, rec.indice_complejidad);
        END LOOP;
        
        SELECT 
            COUNT(*),
            AVG(esfuerzo_total::NUMERIC)
        INTO total_consulta, esfuerzo_promedio
        FROM datos_calculados;
        
        RAISE NOTICE '';
        RAISE NOTICE '%', format('Registros calculados: %s, Esfuerzo promedio: %s', total_consulta, ROUND(esfuerzo_promedio, 2));
    END IF;
    
    -- MODO GUARDAR (1)
    IF modo = 1 THEN
        RAISE NOTICE '';
        RAISE NOTICE '%', format('MODO GUARDAR - Actualizando variables + kg_prenda');
        
        UPDATE silver.costo_op_detalle
        SET 
            pre_unitario = dc.pre_unitario,
            kg_prenda = dc.kg_prenda,
            lote_estilo_kg = dc.lote_estilo_kg,
            diversidad_familias = dc.diversidad_familias,
            diversidad_estilos = dc.diversidad_estilos,
            esfuerzo_textil = dc.esfuerzo_textil,
            esfuerzo_manufactura = dc.esfuerzo_manufactura,
            esfuerzo_total = dc.esfuerzo_total,
            indice_complejidad = dc.indice_complejidad
        FROM datos_calculados dc 
        WHERE silver.costo_op_detalle.cod_ordpro::text = dc.cod_ordpro::text;
        
        GET DIAGNOSTICS rows_updated = ROW_COUNT;
        
        duracion_minutos := EXTRACT(EPOCH FROM (NOW() - tiempo_inicio)) / 60.0;
        
        RAISE NOTICE '';
        RAISE NOTICE '%', format('Registros actualizados: %s en %s min', rows_updated, ROUND(duracion_minutos::NUMERIC, 2));
        RAISE NOTICE '%', format('Variables aplicadas a TODAS las versiones por OP');
        RAISE NOTICE '%', format('‚úÖ kg_prenda actualizado desde tg_cotizacion_estilospropios (√∫ltima fecha por estilo)');
    END IF;
    
    -- Limpiar tablas temporales
    DROP TABLE IF EXISTS kg_prenda_estilo;
    DROP TABLE IF EXISTS precios_op;
    DROP TABLE IF EXISTS lotes_estilo;
    DROP TABLE IF EXISTS diversidad_marca;
    DROP TABLE IF EXISTS colores_por_estilo;
    DROP TABLE IF EXISTS telas_por_estilo;
    DROP TABLE IF EXISTS esfuerzos_base;
    DROP TABLE IF EXISTS datos_calculados;
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE '%', format('ERROR: %s', error_message);
        
        -- Limpiar tablas temporales en caso de error
        DROP TABLE IF EXISTS kg_prenda_estilo;
        DROP TABLE IF EXISTS precios_op;
        DROP TABLE IF EXISTS lotes_estilo;
        DROP TABLE IF EXISTS diversidad_marca;
        DROP TABLE IF EXISTS colores_por_estilo;
        DROP TABLE IF EXISTS telas_por_estilo;
        DROP TABLE IF EXISTS esfuerzos_base;
        DROP TABLE IF EXISTS datos_calculados;
        
        RAISE EXCEPTION '%', error_message;
END;
$procedure$

-------------------------------------------------------------------------------------

25. =====================================================================================
NOMBRE: populate_esfuerzo_op_detalle_v2
SCHEMA: silver
ARGUMENTOS: IN modo integer DEFAULT 0, IN debug integer DEFAULT 0

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.populate_esfuerzo_op_detalle_v2(IN modo integer DEFAULT 0, IN debug integer DEFAULT 0)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    error_message TEXT;
    rows_updated INTEGER := 0;
    rows_updated_wip INTEGER := 0;
    tiempo_inicio TIMESTAMPTZ := NOW();
    
    -- Variables para verificaciones
    total_registros INTEGER;
    ops_unicas INTEGER;
    total_consulta INTEGER;
    esfuerzo_promedio DECIMAL(10,2);
    duracion_minutos DECIMAL(10,2);
    
    -- Variables para factorizaci√≥n M√©todo 2
    media_manufactura DECIMAL(18,4);
    min_manufactura DECIMAL(18,4);
    r_manufactura DECIMAL(18,4);
    limite1 DECIMAL(18,4);
    limite2 DECIMAL(18,4);
    limite3 DECIMAL(18,4);
    limite4 DECIMAL(18,4);
    
    -- Variable para records en loops
    rec RECORD;
    
BEGIN
    -- Verificar prerequisito
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle'
    ) THEN
        RAISE EXCEPTION 'ERROR: Tabla costo_op_detalle no existe. Prerequisito faltante: tabla costo_op_detalle';
    END IF;
    
    RAISE NOTICE '%', format('INICIANDO C√ÅLCULO VARIABLES DE ESFUERZO + kg_prenda + estilo_cliente [MULTI-VERSIONES OPTIMIZADO]...');
    
    -- Verificar contexto multi-versiones
    SELECT COUNT(*) INTO total_registros FROM silver.costo_op_detalle;
    SELECT COUNT(DISTINCT cod_ordpro) INTO ops_unicas FROM silver.costo_op_detalle;
    
    RAISE NOTICE '%', format('Registros: %s total, %s OPs √∫nicas', total_registros, ops_unicas);
    
    -- Agregar columnas nuevas (si no existen) - COSTO_OP_DETALLE
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' AND column_name = 'pre_unitario'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN pre_unitario DECIMAL(18,4) DEFAULT 0;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' AND column_name = 'kg_prenda'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN kg_prenda DECIMAL(18,4) DEFAULT 0;
        RAISE NOTICE '%', format('Columna kg_prenda agregada a costo_op_detalle');
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' AND column_name = 'estilo_cliente'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN estilo_cliente VARCHAR(100);
        RAISE NOTICE '%', format('Columna estilo_cliente agregada a costo_op_detalle');
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' AND column_name = 'lote_estilo_kg'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN lote_estilo_kg DECIMAL(18,4) DEFAULT 0;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' AND column_name = 'diversidad_familias'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN diversidad_familias INTEGER DEFAULT 0;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' AND column_name = 'diversidad_estilos'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN diversidad_estilos INTEGER DEFAULT 0;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' AND column_name = 'esfuerzo_textil'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN esfuerzo_textil INTEGER DEFAULT 1;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' AND column_name = 'esfuerzo_manufactura'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN esfuerzo_manufactura INTEGER DEFAULT 1;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' AND column_name = 'esfuerzo_total'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN esfuerzo_total INTEGER DEFAULT 2;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'silver' AND table_name = 'costo_op_detalle' AND column_name = 'indice_complejidad'
    ) THEN
        ALTER TABLE silver.costo_op_detalle ADD COLUMN indice_complejidad DECIMAL(18,6) DEFAULT NULL;
    END IF;

    -- Agregar columnas a COSTO_WIP_OP si existe la tabla
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_schema = 'silver' AND table_name = 'costo_wip_op'
    ) THEN
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_schema = 'silver' AND table_name = 'costo_wip_op' AND column_name = 'estilo_cliente'
        ) THEN
            ALTER TABLE silver.costo_wip_op ADD COLUMN estilo_cliente VARCHAR(100);
            RAISE NOTICE '%', format('Columna estilo_cliente agregada a costo_wip_op');
        END IF;
    END IF;

    -- ============================================================================
    -- NUEVA SECCI√ìN: ESTILO CLIENTE POR ESTILO PROPIO
    -- ============================================================================
    RAISE NOTICE '%', format('Calculando estilo cliente por estilo propio...');
    
    DROP TABLE IF EXISTS estilo_cliente_mapping;
    CREATE TEMP TABLE estilo_cliente_mapping (
        estilo_propio VARCHAR(50),
        estilo_cliente VARCHAR(100)
    );
    
    INSERT INTO estilo_cliente_mapping
    SELECT DISTINCT 
        fs.cod_estpro as estilo_propio,
        cs.cod_estcli as estilo_cliente
    FROM bronze.es_estpro fs
    LEFT JOIN bronze.tg_lotestpro pols ON fs.cod_estpro = pols.cod_estpro
    LEFT JOIN bronze.tg_lotest pol ON pols.cod_cliente = pol.cod_cliente 
        AND pols.cod_purord = pol.cod_purord
        AND pols.cod_lotpurord = pol.cod_lotpurord  
        AND pols.cod_estcli = pol.cod_estcli
    LEFT JOIN bronze.tg_estcli cs ON cs.cod_cliente = pol.cod_cliente 
        AND cs.cod_estcli = pol.cod_estcli
    WHERE fs.cod_estpro IS NOT NULL 
      AND cs.cod_estcli IS NOT NULL;

    CREATE INDEX idx_estilo_cliente_mapping ON estilo_cliente_mapping(estilo_propio);
    RAISE NOTICE '%', format('Estilo cliente mapeado: %s registros', (SELECT COUNT(*) FROM estilo_cliente_mapping));

    -- ============================================================================
    -- SECCI√ìN: kg_prenda POR ESTILO
    -- ============================================================================
    RAISE NOTICE '%', format('Calculando kg_prenda por estilo...');
    
    DROP TABLE IF EXISTS kg_prenda_estilo;
    CREATE TEMP TABLE kg_prenda_estilo (
        cod_estpro VARCHAR(50),
        kilos_prenda DECIMAL(18,4),
        fec_ult_costeo TIMESTAMPTZ
    );
    
    -- Obtener el registro con fecha m√°s reciente por estilo
    INSERT INTO kg_prenda_estilo
    SELECT DISTINCT ON (cod_estpro)
        cod_estpro,
        kilos_prenda,
        fec_ult_costeo
    FROM bronze.tg_cotizacion_estilospropios
    WHERE cod_estpro IS NOT NULL
      AND kilos_prenda IS NOT NULL
      AND fec_ult_costeo IS NOT NULL
    ORDER BY cod_estpro, fec_ult_costeo DESC;

    CREATE INDEX idx_kg_prenda_estilo ON kg_prenda_estilo(cod_estpro);
    RAISE NOTICE '%', format('kg_prenda calculados: %s estilos', (SELECT COUNT(*) FROM kg_prenda_estilo));

    -- ============================================================================
    -- SECCI√ìN: PRECIOS OP
    -- ============================================================================
    RAISE NOTICE '%', format('Calculando precios por OP...');
    
    DROP TABLE IF EXISTS precios_op;
    CREATE TEMP TABLE precios_op (
        cod_ordpro VARCHAR(50),
        pre_unitario DECIMAL(18,4)
    );
    
    INSERT INTO precios_op
    SELECT DISTINCT
        lot.cod_ordpro,
        AVG(ven.pre_unitario) as pre_unitario
    FROM bronze.tg_lotestpro lot
    INNER JOIN bronze.cn_ventas_prendas ven 
        ON lot.cod_purord::text = ven.cod_purord::text
        AND lot.cod_lotpurord::text = ven.cod_lotpurord::text
    WHERE lot.cod_ordpro IS NOT NULL
      AND ven.pre_unitario IS NOT NULL
      AND ven.pre_unitario > 0
    GROUP BY lot.cod_ordpro;

    CREATE INDEX idx_precios_op_ordpro ON precios_op(cod_ordpro);
    RAISE NOTICE '%', format('Precios calculados: %s registros', (SELECT COUNT(*) FROM precios_op));

    -- ============================================================================
    -- SECCI√ìN: LOTES ESTILO
    -- ============================================================================
    RAISE NOTICE '%', format('Calculando lotes por estilo...');
    
    DROP TABLE IF EXISTS lotes_estilo;
    CREATE TEMP TABLE lotes_estilo (
        cod_ordpro VARCHAR(50),
        cod_estpro VARCHAR(50),
        lote_estilo_kg DECIMAL(18,4)
    );
    
    INSERT INTO lotes_estilo
    SELECT 
        op.cod_ordpro,
        op.cod_estpro,
        SUM(COALESCE(cot.kilos_prenda, 0) * COALESCE(ven.num_prendas, 0)) as lote_estilo_kg
    FROM bronze.es_ordpro op
    LEFT JOIN bronze.tg_cotizacion_estilospropios cot ON op.cod_estpro::text = cot.cod_estpro::text
    LEFT JOIN bronze.tg_lotestpro lot ON op.cod_ordpro::text = lot.cod_ordpro::text
    LEFT JOIN bronze.cn_ventas_prendas ven ON lot.cod_purord::text = ven.cod_purord::text AND lot.cod_lotpurord::text = ven.cod_lotpurord::text
    WHERE op.cod_ordpro IS NOT NULL
      AND op.cod_estpro IS NOT NULL
    GROUP BY op.cod_ordpro, op.cod_estpro;

    CREATE INDEX idx_lotes_estilo_ordpro ON lotes_estilo(cod_ordpro);
    CREATE INDEX idx_lotes_estilo_estpro ON lotes_estilo(cod_estpro);
    RAISE NOTICE '%', format('Lotes calculados: %s registros', (SELECT COUNT(*) FROM lotes_estilo));

    -- ============================================================================
    -- SECCI√ìN: DIVERSIDAD MARCA
    -- ============================================================================
    RAISE NOTICE '%', format('Calculando diversidad por marca...');
    
    DROP TABLE IF EXISTS diversidad_marca;
    CREATE TEMP TABLE diversidad_marca (
        cod_ordpro VARCHAR(50),
        diversidad_familias INTEGER,
        diversidad_estilos INTEGER
    );
    
    INSERT INTO diversidad_marca
    SELECT 
        cod_principal.cod_ordpro,
        COUNT(DISTINCT cod_otros.familia_de_productos) as diversidad_familias,
        COUNT(DISTINCT cod_otros.estilo_propio) as diversidad_estilos
    FROM (
        SELECT DISTINCT cod_ordpro, cliente
        FROM silver.costo_op_detalle
        WHERE cliente IS NOT NULL
    ) cod_principal
    INNER JOIN (
        SELECT DISTINCT cliente, familia_de_productos, estilo_propio
        FROM silver.costo_op_detalle
        WHERE familia_de_productos IS NOT NULL
          AND estilo_propio IS NOT NULL
    ) cod_otros ON cod_principal.cliente::text = cod_otros.cliente::text
    GROUP BY cod_principal.cod_ordpro, cod_principal.cliente;

    CREATE INDEX idx_diversidad_marca_ordpro ON diversidad_marca(cod_ordpro);
    RAISE NOTICE '%', format('Diversidad calculada: %s registros', (SELECT COUNT(*) FROM diversidad_marca));

    -- ============================================================================
    -- SECCI√ìN: COLORES POR ESTILO (OPTIMIZADO)
    -- ============================================================================
    RAISE NOTICE '%', format('Calculando colores por estilo...');
    
    DROP TABLE IF EXISTS colores_por_estilo;
    CREATE TEMP TABLE colores_por_estilo (
        cod_estpro VARCHAR(50),
        cantidad_colores_sinstd INTEGER
    );
    
    INSERT INTO colores_por_estilo
    SELECT 
        ecp.cod_estpro,
        COUNT(DISTINCT ecp.cod_colcli) as cantidad_colores_sinstd
    FROM bronze.tg_estclicolpre ecp 
    WHERE ecp.cod_colcli IS NOT NULL 
      AND ecp.cod_colcli::text != 'STD'
      AND ecp.cod_estpro IS NOT NULL
    GROUP BY ecp.cod_estpro;
    
    CREATE INDEX idx_colores_por_estilo_estpro ON colores_por_estilo(cod_estpro);
    RAISE NOTICE '%', format('Colores calculados: %s registros', (SELECT COUNT(*) FROM colores_por_estilo));

    -- ============================================================================
    -- SECCI√ìN: TELAS POR ESTILO (OPTIMIZADO)
    -- ============================================================================
    RAISE NOTICE '%', format('Calculando telas por estilo...');
    
    DROP TABLE IF EXISTS telas_por_estilo;
    CREATE TEMP TABLE telas_por_estilo (
        cod_estpro VARCHAR(50),
        cantidad_telas_unicas INTEGER
    );
    
    INSERT INTO telas_por_estilo
    SELECT 
        tctm.cod_estpro,
        COUNT(DISTINCT tctm.cod_tela) as cantidad_telas_unicas
    FROM bronze.tg_cotizacion_telas_matriz tctm 
    WHERE tctm.cod_tela IS NOT NULL
      AND tctm.cod_estpro IS NOT NULL
    GROUP BY tctm.cod_estpro;
    
    CREATE INDEX idx_telas_por_estilo_estpro ON telas_por_estilo(cod_estpro);
    RAISE NOTICE '%', format('Telas calculadas: %s registros', (SELECT COUNT(*) FROM telas_por_estilo));

    -- ============================================================================
    -- SECCI√ìN: ESFUERZOS BASE (SIN SUBCONSULTAS)
    -- ============================================================================
    RAISE NOTICE '%', format('Consolidando esfuerzos base...');
    
    DROP TABLE IF EXISTS esfuerzos_base;
    CREATE TEMP TABLE esfuerzos_base (
        cod_ordpro VARCHAR(50),
        cod_estpro VARCHAR(50),
        cantidad_colores_sinstd INTEGER,
        cantidad_telas_unicas INTEGER,
        tiempo_total_minutos DECIMAL(18,4)
    );
    
    INSERT INTO esfuerzos_base
    SELECT 
        op.cod_ordpro,
        op.cod_estpro,
        COALESCE(cpe.cantidad_colores_sinstd, 0) as cantidad_colores_sinstd,
        COALESCE(tpe.cantidad_telas_unicas, 0) as cantidad_telas_unicas,
        AVG(COALESCE(cot.min_corte, 0) + COALESCE(cot.min_costura, 0) + COALESCE(cot.min_acabado, 0)) as tiempo_total_minutos
    FROM bronze.es_ordpro op
    LEFT JOIN bronze.tg_cotizacion_estilospropios cot ON op.cod_estpro::text = cot.cod_estpro::text
    LEFT JOIN colores_por_estilo cpe ON op.cod_estpro::text = cpe.cod_estpro::text
    LEFT JOIN telas_por_estilo tpe ON op.cod_estpro::text = tpe.cod_estpro::text
    WHERE op.cod_ordpro IS NOT NULL
    GROUP BY op.cod_ordpro, op.cod_estpro, cpe.cantidad_colores_sinstd, tpe.cantidad_telas_unicas;

    CREATE INDEX idx_esfuerzos_base_ordpro ON esfuerzos_base(cod_ordpro);
    CREATE INDEX idx_esfuerzos_base_estpro ON esfuerzos_base(cod_estpro);
    RAISE NOTICE '%', format('Esfuerzos base calculados: %s registros', (SELECT COUNT(*) FROM esfuerzos_base));

    -- ============================================================================
    -- SECCI√ìN: FACTORIZACI√ìN M√âTODO 2
    -- ============================================================================
    RAISE NOTICE '%', format('Calculando factorizaci√≥n para manufactura...');
    
    SELECT 
        AVG(tiempo_total_minutos),
        MIN(tiempo_total_minutos)
    INTO media_manufactura, min_manufactura
    FROM esfuerzos_base 
    WHERE tiempo_total_minutos > 0;
    
    r_manufactura := CASE 
        WHEN media_manufactura > min_manufactura THEN (media_manufactura - min_manufactura) / 5.0 
        ELSE 1 
    END;
    
    limite1 := min_manufactura + 2 * r_manufactura;
    limite2 := min_manufactura + 4 * r_manufactura;
    limite3 := min_manufactura + 6 * r_manufactura;
    limite4 := min_manufactura + 8 * r_manufactura;

    RAISE NOTICE '%', format('L√≠mites manufactura - L1: %s, L2: %s, L3: %s, L4: %s', 
                 ROUND(limite1::NUMERIC, 2), ROUND(limite2::NUMERIC, 2), 
                 ROUND(limite3::NUMERIC, 2), ROUND(limite4::NUMERIC, 2));

    -- ============================================================================
    -- SECCI√ìN: CONSOLIDACI√ìN FINAL (CON kg_prenda + estilo_cliente)
    -- ============================================================================
    RAISE NOTICE '%', format('Consolidando datos calculados...');
    
    DROP TABLE IF EXISTS datos_calculados;
    CREATE TEMP TABLE datos_calculados (
        cod_ordpro VARCHAR(50),
        pre_unitario DECIMAL(18,4),
        kg_prenda DECIMAL(18,4),
        estilo_cliente VARCHAR(100),
        lote_estilo_kg DECIMAL(18,4),
        diversidad_familias INTEGER,
        diversidad_estilos INTEGER,
        cantidad_colores_sinstd INTEGER,
        cantidad_telas_unicas INTEGER,
        tiempo_total_minutos DECIMAL(18,4),
        esfuerzo_textil INTEGER,
        esfuerzo_manufactura INTEGER,
        esfuerzo_total INTEGER,
        indice_complejidad DECIMAL(18,6)
    );
    
    INSERT INTO datos_calculados
    SELECT 
        eb.cod_ordpro,
        COALESCE(po.pre_unitario, 0) as pre_unitario,
        COALESCE(kp.kilos_prenda, 0) as kg_prenda,
        ecm.estilo_cliente,
        COALESCE(le.lote_estilo_kg, 0) as lote_estilo_kg,
        COALESCE(dm.diversidad_familias, 0) as diversidad_familias,
        COALESCE(dm.diversidad_estilos, 0) as diversidad_estilos,
        eb.cantidad_colores_sinstd,
        eb.cantidad_telas_unicas,
        eb.tiempo_total_minutos,
        -- Esfuerzo textil (rangos fijos)
        CASE 
            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 1 THEN 1
            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 3 THEN 2
            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 10 THEN 3
            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 17 THEN 4
            ELSE 5
        END as esfuerzo_textil,
        -- Esfuerzo manufactura (intervalos din√°micos)
        CASE 
            WHEN eb.tiempo_total_minutos <= 0 THEN 1
            WHEN eb.tiempo_total_minutos <= limite1 THEN 1
            WHEN eb.tiempo_total_minutos <= limite2 THEN 2
            WHEN eb.tiempo_total_minutos <= limite3 THEN 3
            WHEN eb.tiempo_total_minutos <= limite4 THEN 4
            ELSE 5
        END as esfuerzo_manufactura,
        -- Esfuerzo total
        (CASE 
            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 1 THEN 1
            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 3 THEN 2
            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 10 THEN 3
            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 17 THEN 4
            ELSE 5
        END + 
        CASE 
            WHEN eb.tiempo_total_minutos <= 0 THEN 1
            WHEN eb.tiempo_total_minutos <= limite1 THEN 1
            WHEN eb.tiempo_total_minutos <= limite2 THEN 2
            WHEN eb.tiempo_total_minutos <= limite3 THEN 3
            WHEN eb.tiempo_total_minutos <= limite4 THEN 4
            ELSE 5
        END) as esfuerzo_total,
        -- √çndice de complejidad: LOG NATURAL
        CASE 
            WHEN COALESCE(le.lote_estilo_kg, 0) <= 0 THEN NULL
            WHEN COALESCE(dm.diversidad_familias, 0) = 0 THEN NULL
            WHEN COALESCE(dm.diversidad_estilos, 0) = 0 THEN NULL
            ELSE 
                CASE 
                    WHEN (
                        ((CASE 
                            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 1 THEN 1
                            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 3 THEN 2
                            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 10 THEN 3
                            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 17 THEN 4
                            ELSE 5
                        END + 
                        CASE 
                            WHEN eb.tiempo_total_minutos <= 0 THEN 1
                            WHEN eb.tiempo_total_minutos <= limite1 THEN 1
                            WHEN eb.tiempo_total_minutos <= limite2 THEN 2
                            WHEN eb.tiempo_total_minutos <= limite3 THEN 3
                            WHEN eb.tiempo_total_minutos <= limite4 THEN 4
                            ELSE 5
                        END) * dm.diversidad_familias * dm.diversidad_estilos) / le.lote_estilo_kg
                    ) > 0 THEN 
                        LN(((CASE 
                            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 1 THEN 1
                            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 3 THEN 2
                            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 10 THEN 3
                            WHEN (eb.cantidad_colores_sinstd + eb.cantidad_telas_unicas) <= 17 THEN 4
                            ELSE 5
                        END + 
                        CASE 
                            WHEN eb.tiempo_total_minutos <= 0 THEN 1
                            WHEN eb.tiempo_total_minutos <= limite1 THEN 1
                            WHEN eb.tiempo_total_minutos <= limite2 THEN 2
                            WHEN eb.tiempo_total_minutos <= limite3 THEN 3
                            WHEN eb.tiempo_total_minutos <= limite4 THEN 4
                            ELSE 5
                        END)::DECIMAL(18,6) * dm.diversidad_familias::DECIMAL(18,6) * dm.diversidad_estilos::DECIMAL(18,6)) / le.lote_estilo_kg::DECIMAL(18,6))
                    ELSE NULL
                END
        END as indice_complejidad
    FROM esfuerzos_base eb
    LEFT JOIN precios_op po ON eb.cod_ordpro::text = po.cod_ordpro::text
    LEFT JOIN kg_prenda_estilo kp ON eb.cod_estpro::text = kp.cod_estpro::text
    LEFT JOIN estilo_cliente_mapping ecm ON eb.cod_estpro::text = ecm.estilo_propio::text
    LEFT JOIN lotes_estilo le ON eb.cod_ordpro::text = le.cod_ordpro::text
    LEFT JOIN diversidad_marca dm ON eb.cod_ordpro::text = dm.cod_ordpro::text;
    
    GET DIAGNOSTICS total_consulta = ROW_COUNT;
    RAISE NOTICE '%', format('Datos consolidados: %s registros', total_consulta);
    
    -- MODO CONSULTA (0)
    IF modo = 0 THEN
        RAISE NOTICE '%', format('MODO CONSULTA - Variables calculadas SIN GUARDAR');
        RAISE NOTICE '';
        RAISE NOTICE '%', format('TOP 10 registros por esfuerzo total e √≠ndice de complejidad:');
        
        FOR rec IN
            SELECT 
                dc.cod_ordpro,
                dc.estilo_cliente,
                ROUND(dc.pre_unitario::NUMERIC, 2) as pre_unitario,
                ROUND(dc.kg_prenda::NUMERIC, 4) as kg_prenda,
                ROUND(dc.lote_estilo_kg::NUMERIC, 2) as lote_estilo_kg,
                dc.diversidad_familias,
                dc.diversidad_estilos,
                dc.esfuerzo_textil,
                dc.esfuerzo_manufactura,
                dc.esfuerzo_total,
                ROUND(COALESCE(dc.indice_complejidad, 0)::NUMERIC, 6) as indice_complejidad
            FROM datos_calculados dc
            ORDER BY dc.esfuerzo_total DESC, dc.indice_complejidad DESC NULLS LAST
            LIMIT 10
        LOOP
            RAISE NOTICE '%', format('   %s: Estilo: %s, Precio: %s, kg: %s, Lote: %s kg, Fam: %s, Est: %s, Text: %s, Manuf: %s, Total: %s, √çndice: %s', 
                                    rec.cod_ordpro, COALESCE(rec.estilo_cliente, 'N/A'), rec.pre_unitario, rec.kg_prenda, rec.lote_estilo_kg, rec.diversidad_familias, 
                                    rec.diversidad_estilos, rec.esfuerzo_textil, rec.esfuerzo_manufactura, rec.esfuerzo_total, rec.indice_complejidad);
        END LOOP;
        
        SELECT 
            COUNT(*),
            AVG(esfuerzo_total::NUMERIC)
        INTO total_consulta, esfuerzo_promedio
        FROM datos_calculados;
        
        RAISE NOTICE '';
        RAISE NOTICE '%', format('Registros calculados: %s, Esfuerzo promedio: %s', total_consulta, ROUND(esfuerzo_promedio, 2));
    END IF;
    
    -- MODO GUARDAR (1)
    IF modo = 1 THEN
        RAISE NOTICE '';
        RAISE NOTICE '%', format('MODO GUARDAR - Actualizando variables + kg_prenda + estilo_cliente');
        
        -- Actualizar COSTO_OP_DETALLE
        UPDATE silver.costo_op_detalle
        SET 
            pre_unitario = dc.pre_unitario,
            kg_prenda = dc.kg_prenda,
            estilo_cliente = dc.estilo_cliente,
            lote_estilo_kg = dc.lote_estilo_kg,
            diversidad_familias = dc.diversidad_familias,
            diversidad_estilos = dc.diversidad_estilos,
            esfuerzo_textil = dc.esfuerzo_textil,
            esfuerzo_manufactura = dc.esfuerzo_manufactura,
            esfuerzo_total = dc.esfuerzo_total,
            indice_complejidad = dc.indice_complejidad
        FROM datos_calculados dc 
        WHERE silver.costo_op_detalle.cod_ordpro::text = dc.cod_ordpro::text;
        
        GET DIAGNOSTICS rows_updated = ROW_COUNT;
        
        -- Actualizar COSTO_WIP_OP si existe
        IF EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_schema = 'silver' AND table_name = 'costo_wip_op'
        ) THEN
            UPDATE silver.costo_wip_op
            SET estilo_cliente = ecm.estilo_cliente
            FROM estilo_cliente_mapping ecm
            WHERE silver.costo_wip_op.estilo_propio::text = ecm.estilo_propio::text;
            
            GET DIAGNOSTICS rows_updated_wip = ROW_COUNT;
            RAISE NOTICE '%', format('Registros actualizados en costo_wip_op: %s', rows_updated_wip);
        END IF;
        
        duracion_minutos := EXTRACT(EPOCH FROM (NOW() - tiempo_inicio)) / 60.0;
        
        RAISE NOTICE '';
        RAISE NOTICE '%', format('Registros actualizados en costo_op_detalle: %s en %s min', rows_updated, ROUND(duracion_minutos::NUMERIC, 2));
        RAISE NOTICE '%', format('Variables aplicadas a TODAS las versiones por OP');
        RAISE NOTICE '%', format('‚úÖ kg_prenda actualizado desde tg_cotizacion_estilospropios (√∫ltima fecha por estilo)');
        RAISE NOTICE '%', format('‚úÖ estilo_cliente actualizado desde mapeo estilo_propio -> cod_estcli');
    END IF;
    
    -- Limpiar tablas temporales
    DROP TABLE IF EXISTS estilo_cliente_mapping;
    DROP TABLE IF EXISTS kg_prenda_estilo;
    DROP TABLE IF EXISTS precios_op;
    DROP TABLE IF EXISTS lotes_estilo;
    DROP TABLE IF EXISTS diversidad_marca;
    DROP TABLE IF EXISTS colores_por_estilo;
    DROP TABLE IF EXISTS telas_por_estilo;
    DROP TABLE IF EXISTS esfuerzos_base;
    DROP TABLE IF EXISTS datos_calculados;
    
EXCEPTION 
    WHEN OTHERS THEN
        error_message := SQLERRM;
        RAISE NOTICE '%', format('ERROR: %s', error_message);
        
        -- Limpiar tablas temporales en caso de error
        DROP TABLE IF EXISTS estilo_cliente_mapping;
        DROP TABLE IF EXISTS kg_prenda_estilo;
        DROP TABLE IF EXISTS precios_op;
        DROP TABLE IF EXISTS lotes_estilo;
        DROP TABLE IF EXISTS diversidad_marca;
        DROP TABLE IF EXISTS colores_por_estilo;
        DROP TABLE IF EXISTS telas_por_estilo;
        DROP TABLE IF EXISTS esfuerzos_base;
        DROP TABLE IF EXISTS datos_calculados;
        
        RAISE EXCEPTION '%', error_message;
END;
$procedure$

-------------------------------------------------------------------------------------

26. =====================================================================================
NOMBRE: sp_cargar_costos_procesos
SCHEMA: silver
ARGUMENTOS: 

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.sp_cargar_costos_procesos()
 LANGUAGE plpgsql
AS $procedure$
BEGIN
    -- Limpiar tabla destino
    TRUNCATE TABLE silver.costos_procesos;
    
    -- Insertar datos transformados de horizontal a vertical
    INSERT INTO silver.costos_procesos (
        wip_id,
        wip_name,
        grupo,
        subproceso,
        a√±o,
        mes,
        costo,
        unidades,
        costo_unitario,
        usuario_carga,
        estado_registro
    )
    SELECT 
        wip_id,
        wip_name,
        grupo,
        subproceso,
        CAST(SPLIT_PART(periodo, '_', 1) AS INTEGER) AS a√±o,
        CASE SPLIT_PART(periodo, '_', 2)
            WHEN '01' THEN 'ene'
            WHEN '02' THEN 'feb'
            WHEN '03' THEN 'mar'
            WHEN '04' THEN 'abr'
            WHEN '05' THEN 'may'
            WHEN '06' THEN 'jun'
            WHEN '07' THEN 'jul'
            WHEN '08' THEN 'ago'
            WHEN '09' THEN 'sep'
            WHEN '10' THEN 'oct'
            WHEN '11' THEN 'nov'
            WHEN '12' THEN 'dic'
        END AS mes,
        costo_valor,
        NULL AS unidades,
        NULL AS costo_unitario,
        CURRENT_USER AS usuario_carga,
        'ACTIVO' AS estado_registro
    FROM silver.costos_procesos_tdv_temp
    CROSS JOIN LATERAL (
        VALUES 
            ('2023_01', "2023_01"),
            ('2023_02', "2023_02"),
            ('2023_03', "2023_03"),
            ('2023_04', "2023_04"),
            ('2023_05', "2023_05"),
            ('2023_06', "2023_06"),
            ('2023_07', "2023_07"),
            ('2023_08', "2023_08"),
            ('2023_09', "2023_09"),
            ('2023_10', "2023_10"),
            ('2023_11', "2023_11"),
            ('2023_12', "2023_12"),
            ('2024_01', "2024_01"),
            ('2024_02', "2024_02"),
            ('2024_03', "2024_03"),
            ('2024_04', "2024_04"),
            ('2024_05', "2024_05"),
            ('2024_06', "2024_06"),
            ('2024_07', "2024_07"),
            ('2024_08', "2024_08"),
            ('2024_09', "2024_09"),
            ('2024_10', "2024_10"),
            ('2024_11', "2024_11"),
            ('2024_12', "2024_12")
    ) AS periodos(periodo, costo_valor)
    WHERE costo_valor IS NOT NULL; -- Opcional: solo insertar valores no nulos
    
    -- Mensaje de confirmaci√≥n
    RAISE NOTICE 'Proceso completado. Total registros insertados: %', 
        (SELECT COUNT(*) FROM silver.costos_procesos);
        
END;
$procedure$

-------------------------------------------------------------------------------------

27. =====================================================================================
NOMBRE: sp_transform_costos
SCHEMA: silver
ARGUMENTOS: IN p_accion integer DEFAULT 1, IN "p_a√±o" integer DEFAULT NULL::integer

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.sp_transform_costos(IN p_accion integer DEFAULT 1, IN "p_a√±o" integer DEFAULT NULL::integer)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    v_lote_carga VARCHAR(50);
    v_registros_insertados INTEGER := 0;
    v_registros_eliminados INTEGER := 0;
    v_max_id INTEGER;
BEGIN
    -- Generar lote de carga autom√°tico
    v_lote_carga := TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD_HH24MISS');
    
    RAISE NOTICE '=================================================';
    RAISE NOTICE 'TRANSFORMACI√ìN DE COSTOS INDIRECTOS';
    RAISE NOTICE 'Lote: %', v_lote_carga;
    RAISE NOTICE 'Acci√≥n: % (1=Agregar, 2=Limpiar+Agregar)', p_accion;
    IF p_a√±o IS NOT NULL THEN
        RAISE NOTICE 'A√±o: %', p_a√±o;
    END IF;
    RAISE NOTICE '=================================================';
    
    -- OPCI√ìN 2: Limpiar datos antes de insertar
    IF p_accion = 2 THEN
        IF p_a√±o IS NULL THEN
            RAISE NOTICE 'Limpiando TODOS los registros...';
            DELETE FROM silver.costos_fijos_mensuales;
        ELSE
            RAISE NOTICE 'Limpiando registros del a√±o %...', p_a√±o;
            DELETE FROM silver.costos_fijos_mensuales WHERE a√±o = p_a√±o;
        END IF;
        
        GET DIAGNOSTICS v_registros_eliminados = ROW_COUNT;
        RAISE NOTICE 'Registros eliminados: %', v_registros_eliminados;
    END IF;
    
    -- Obtener el m√°ximo ID actual
    SELECT COALESCE(MAX(id), 0) INTO v_max_id 
    FROM silver.costos_fijos_mensuales;
    
    RAISE NOTICE 'ID inicial: %', v_max_id + 1;
    
    -- INSERTAR DATOS TRANSFORMADOS
    INSERT INTO silver.costos_fijos_mensuales (
        id,
        tipo_costo,
        proceso_productivo,
        mes,
        a√±o,
        costo_total_usd,
        fecha_carga,
        lote_carga,
        usuario_carga,
        activo
    )
    SELECT 
        ROW_NUMBER() OVER (ORDER BY a√±o, mes, orden) + v_max_id as id,
        tipo_costo,
        proceso_productivo,
        mes,
        a√±o,
        costo_total_usd,
        CURRENT_TIMESTAMP as fecha_carga,
        v_lote_carga as lote_carga,
        'Sistema' as usuario_carga,
        B'1' as activo
    FROM (
        -- 1. COSTO INDIRECTO FIJO - TEXTIL (45%)
        SELECT 
            mes,
            a√±o,
            'Costo Indirecto Fijo' as tipo_costo,
            'Textil' as proceso_productivo,
            ROUND(costo_indirecto * 0.45, 2) as costo_total_usd,
            1 as orden
        FROM silver.costos_indirectos_tdv
        WHERE costo_indirecto IS NOT NULL
        AND (p_a√±o IS NULL OR a√±o = p_a√±o)
        
        UNION ALL
        
        -- 2. COSTO INDIRECTO FIJO - MANUFACTURA (55%)
        SELECT 
            mes,
            a√±o,
            'Costo Indirecto Fijo' as tipo_costo,
            'Manufactura' as proceso_productivo,
            ROUND(costo_indirecto * 0.55, 2) as costo_total_usd,
            2 as orden
        FROM silver.costos_indirectos_tdv
        WHERE costo_indirecto IS NOT NULL
        AND (p_a√±o IS NULL OR a√±o = p_a√±o)
        
        UNION ALL
        
        -- 3. Gasto de Administraci√≥n - TEXTIL (55%)
        SELECT 
            mes,
            a√±o,
            'Gasto de Administraci√≥n' as tipo_costo,
            'Textil' as proceso_productivo,
            ROUND(gastos_adm * 0.55, 2) as costo_total_usd,
            3 as orden
        FROM silver.costos_indirectos_tdv
        WHERE gastos_adm IS NOT NULL
        AND (p_a√±o IS NULL OR a√±o = p_a√±o)
        
        UNION ALL
        
        -- 4. Gasto de Administraci√≥n - MANUFACTURA (45%)
        SELECT 
            mes,
            a√±o,
            'Gasto de Administraci√≥n' as tipo_costo,
            'Manufactura' as proceso_productivo,
            ROUND(gastos_adm * 0.45, 2) as costo_total_usd,
            4 as orden
        FROM silver.costos_indirectos_tdv
        WHERE gastos_adm IS NOT NULL
        AND (p_a√±o IS NULL OR a√±o = p_a√±o)
        
        UNION ALL
        
        -- 5. Gasto de Ventas - MANUFACTURA (100%)
        SELECT 
            mes,
            a√±o,
            'Gasto de Ventas' as tipo_costo,
            'Manufactura' as proceso_productivo,
            ROUND(gastos_ventas * 1.00, 2) as costo_total_usd,
            5 as orden
        FROM silver.costos_indirectos_tdv
        WHERE gastos_ventas IS NOT NULL
        AND (p_a√±o IS NULL OR a√±o = p_a√±o)
    ) datos_transformados
    ORDER BY a√±o, mes, orden;
    
    GET DIAGNOSTICS v_registros_insertados = ROW_COUNT;
    
    RAISE NOTICE '=================================================';
    RAISE NOTICE 'TRANSFORMACI√ìN COMPLETADA';
    RAISE NOTICE 'Registros insertados: %', v_registros_insertados;
    RAISE NOTICE 'Lote: %', v_lote_carga;
    RAISE NOTICE '=================================================';
    
    -- NO usar COMMIT ni ROLLBACK - PostgreSQL los maneja autom√°ticamente
    
END;
$procedure$

-------------------------------------------------------------------------------------

28. =====================================================================================
NOMBRE: sp_transform_costos_proc
SCHEMA: silver
ARGUMENTOS: 

DEFINICION:
-------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE silver.sp_transform_costos_proc()
 LANGUAGE plpgsql
AS $procedure$
BEGIN
    -- 1. Crear tabla temporal con la estructura de costos_procesos_tdv
    DROP TABLE IF EXISTS silver.costos_procesos_tdv_temp;
    
    CREATE TABLE silver.costos_procesos_tdv_temp AS
    SELECT * FROM silver.costos_procesos_tdv;
    
    -- 2. TRANSFORMACI√ìN BORDADO (caso verde - 50/50)
    -- Dividir el BORDADO actual (wip 37, area_id 17) en dos partes:
    -- - 50% para wip 37 con subproceso "BORDADO (pda)"
    -- - 50% para wip 43 con subproceso "BORDADO (pz)"
    
    -- Primero, actualizar el registro existente de BORDADO para que sea BORDADO (pz)
    UPDATE silver.costos_procesos_tdv_temp
    SET 
        subproceso = 'BORDADO (pz)',
        "2023_01" = "2023_01" * 0.5,
        "2023_02" = "2023_02" * 0.5,
        "2023_03" = "2023_03" * 0.5,
        "2023_04" = "2023_04" * 0.5,
        "2023_05" = "2023_05" * 0.5,
        "2023_06" = "2023_06" * 0.5,
        "2023_07" = "2023_07" * 0.5,
        "2023_08" = "2023_08" * 0.5,
        "2023_09" = "2023_09" * 0.5,
        "2023_10" = "2023_10" * 0.5,
        "2023_11" = "2023_11" * 0.5,
        "2023_12" = "2023_12" * 0.5,
        "2024_01" = "2024_01" * 0.5,
        "2024_02" = "2024_02" * 0.5,
        "2024_03" = "2024_03" * 0.5,
        "2024_04" = "2024_04" * 0.5,
        "2024_05" = "2024_05" * 0.5,
        "2024_06" = "2024_06" * 0.5,
        "2024_07" = "2024_07" * 0.5,
        "2024_08" = "2024_08" * 0.5,
        "2024_09" = "2024_09" * 0.5,
        "2024_10" = "2024_10" * 0.5,
        "2024_11" = "2024_11" * 0.5,
        "2024_12" = "2024_12" * 0.5
    WHERE wip_id = '37' AND area_id = 17 AND subproceso = 'BORDADO';
    
    -- Segundo, insertar nuevo registro para wip 43 con el otro 50%
    INSERT INTO silver.costos_procesos_tdv_temp
    SELECT 
        '43' as wip_id,
        'Bordado Prenda' as wip_name,
        grupo,
        19 as area_id, -- nuevo area_id para bordado pda
        'BORDADO (pda)' as subproceso,
        "2023_01" * 0.5,
        "2023_02" * 0.5,
        "2023_03" * 0.5,
        "2023_04" * 0.5,
        "2023_05" * 0.5,
        "2023_06" * 0.5,
        "2023_07" * 0.5,
        "2023_08" * 0.5,
        "2023_09" * 0.5,
        "2023_10" * 0.5,
        "2023_11" * 0.5,
        "2023_12" * 0.5,
        "2024_01" * 0.5,
        "2024_02" * 0.5,
        "2024_03" * 0.5,
        "2024_04" * 0.5,
        "2024_05" * 0.5,
        "2024_06" * 0.5,
        "2024_07" * 0.5,
        "2024_08" * 0.5,
        "2024_09" * 0.5,
        "2024_10" * 0.5,
        "2024_11" * 0.5,
        "2024_12" * 0.5
    FROM silver.costos_procesos_tdv
    WHERE wip_id = '37' AND area_id = 17 AND subproceso = 'BORDADO';
    
    -- SERV BORDADO NO SE DIVIDE - se queda tal cual

    -- 3. TRANSFORMACI√ìN ESTAMPADO (caso amarillo - prorrateo por producci√≥n)
    -- Para ESTAMPADO SERIGRAFICO: distribuir seg√∫n producci√≥n de ap_id 27 (pz) y 28 (pda)
    
    -- 3.1 Crear tabla auxiliar con factores de prorrateo por mes
    DROP TABLE IF EXISTS temp_factor_estampado_serigrafico;
    CREATE TEMP TABLE temp_factor_estampado_serigrafico AS
    WITH produccion_total AS (
        SELECT 
            COALESCE(pz."2023_01", 0) + COALESCE(pda."2023_01", 0) as total_2023_01,
            COALESCE(pz."2023_02", 0) + COALESCE(pda."2023_02", 0) as total_2023_02,
            COALESCE(pz."2023_03", 0) + COALESCE(pda."2023_03", 0) as total_2023_03,
            COALESCE(pz."2023_04", 0) + COALESCE(pda."2023_04", 0) as total_2023_04,
            COALESCE(pz."2023_05", 0) + COALESCE(pda."2023_05", 0) as total_2023_05,
            COALESCE(pz."2023_06", 0) + COALESCE(pda."2023_06", 0) as total_2023_06,
            COALESCE(pz."2023_07", 0) + COALESCE(pda."2023_07", 0) as total_2023_07,
            COALESCE(pz."2023_08", 0) + COALESCE(pda."2023_08", 0) as total_2023_08,
            COALESCE(pz."2023_09", 0) + COALESCE(pda."2023_09", 0) as total_2023_09,
            COALESCE(pz."2023_10", 0) + COALESCE(pda."2023_10", 0) as total_2023_10,
            COALESCE(pz."2023_11", 0) + COALESCE(pda."2023_11", 0) as total_2023_11,
            COALESCE(pz."2023_12", 0) + COALESCE(pda."2023_12", 0) as total_2023_12,
            COALESCE(pz."2024_01", 0) + COALESCE(pda."2024_01", 0) as total_2024_01,
            COALESCE(pz."2024_02", 0) + COALESCE(pda."2024_02", 0) as total_2024_02,
            COALESCE(pz."2024_03", 0) + COALESCE(pda."2024_03", 0) as total_2024_03,
            COALESCE(pz."2024_04", 0) + COALESCE(pda."2024_04", 0) as total_2024_04,
            COALESCE(pz."2024_05", 0) + COALESCE(pda."2024_05", 0) as total_2024_05,
            COALESCE(pz."2024_06", 0) + COALESCE(pda."2024_06", 0) as total_2024_06,
            COALESCE(pz."2024_07", 0) + COALESCE(pda."2024_07", 0) as total_2024_07,
            COALESCE(pz."2024_08", 0) + COALESCE(pda."2024_08", 0) as total_2024_08,
            COALESCE(pz."2024_09", 0) + COALESCE(pda."2024_09", 0) as total_2024_09,
            COALESCE(pz."2024_10", 0) + COALESCE(pda."2024_10", 0) as total_2024_10,
            COALESCE(pz."2024_11", 0) + COALESCE(pda."2024_11", 0) as total_2024_11,
            COALESCE(pz."2024_12", 0) + COALESCE(pda."2024_12", 0) as total_2024_12,
            -- Factores para pz
            CASE WHEN COALESCE(pz."2023_01", 0) + COALESCE(pda."2023_01", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_01", 0) / NULLIF(COALESCE(pz."2023_01", 0) + COALESCE(pda."2023_01", 0), 0) END as factor_pz_2023_01,
            CASE WHEN COALESCE(pz."2023_02", 0) + COALESCE(pda."2023_02", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_02", 0) / NULLIF(COALESCE(pz."2023_02", 0) + COALESCE(pda."2023_02", 0), 0) END as factor_pz_2023_02,
            CASE WHEN COALESCE(pz."2023_03", 0) + COALESCE(pda."2023_03", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_03", 0) / NULLIF(COALESCE(pz."2023_03", 0) + COALESCE(pda."2023_03", 0), 0) END as factor_pz_2023_03,
            CASE WHEN COALESCE(pz."2023_04", 0) + COALESCE(pda."2023_04", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_04", 0) / NULLIF(COALESCE(pz."2023_04", 0) + COALESCE(pda."2023_04", 0), 0) END as factor_pz_2023_04,
            CASE WHEN COALESCE(pz."2023_05", 0) + COALESCE(pda."2023_05", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_05", 0) / NULLIF(COALESCE(pz."2023_05", 0) + COALESCE(pda."2023_05", 0), 0) END as factor_pz_2023_05,
            CASE WHEN COALESCE(pz."2023_06", 0) + COALESCE(pda."2023_06", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_06", 0) / NULLIF(COALESCE(pz."2023_06", 0) + COALESCE(pda."2023_06", 0), 0) END as factor_pz_2023_06,
            CASE WHEN COALESCE(pz."2023_07", 0) + COALESCE(pda."2023_07", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_07", 0) / NULLIF(COALESCE(pz."2023_07", 0) + COALESCE(pda."2023_07", 0), 0) END as factor_pz_2023_07,
            CASE WHEN COALESCE(pz."2023_08", 0) + COALESCE(pda."2023_08", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_08", 0) / NULLIF(COALESCE(pz."2023_08", 0) + COALESCE(pda."2023_08", 0), 0) END as factor_pz_2023_08,
            CASE WHEN COALESCE(pz."2023_09", 0) + COALESCE(pda."2023_09", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_09", 0) / NULLIF(COALESCE(pz."2023_09", 0) + COALESCE(pda."2023_09", 0), 0) END as factor_pz_2023_09,
            CASE WHEN COALESCE(pz."2023_10", 0) + COALESCE(pda."2023_10", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_10", 0) / NULLIF(COALESCE(pz."2023_10", 0) + COALESCE(pda."2023_10", 0), 0) END as factor_pz_2023_10,
            CASE WHEN COALESCE(pz."2023_11", 0) + COALESCE(pda."2023_11", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_11", 0) / NULLIF(COALESCE(pz."2023_11", 0) + COALESCE(pda."2023_11", 0), 0) END as factor_pz_2023_11,
            CASE WHEN COALESCE(pz."2023_12", 0) + COALESCE(pda."2023_12", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_12", 0) / NULLIF(COALESCE(pz."2023_12", 0) + COALESCE(pda."2023_12", 0), 0) END as factor_pz_2023_12,
            CASE WHEN COALESCE(pz."2024_01", 0) + COALESCE(pda."2024_01", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_01", 0) / NULLIF(COALESCE(pz."2024_01", 0) + COALESCE(pda."2024_01", 0), 0) END as factor_pz_2024_01,
            CASE WHEN COALESCE(pz."2024_02", 0) + COALESCE(pda."2024_02", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_02", 0) / NULLIF(COALESCE(pz."2024_02", 0) + COALESCE(pda."2024_02", 0), 0) END as factor_pz_2024_02,
            CASE WHEN COALESCE(pz."2024_03", 0) + COALESCE(pda."2024_03", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_03", 0) / NULLIF(COALESCE(pz."2024_03", 0) + COALESCE(pda."2024_03", 0), 0) END as factor_pz_2024_03,
            CASE WHEN COALESCE(pz."2024_04", 0) + COALESCE(pda."2024_04", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_04", 0) / NULLIF(COALESCE(pz."2024_04", 0) + COALESCE(pda."2024_04", 0), 0) END as factor_pz_2024_04,
            CASE WHEN COALESCE(pz."2024_05", 0) + COALESCE(pda."2024_05", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_05", 0) / NULLIF(COALESCE(pz."2024_05", 0) + COALESCE(pda."2024_05", 0), 0) END as factor_pz_2024_05,
            CASE WHEN COALESCE(pz."2024_06", 0) + COALESCE(pda."2024_06", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_06", 0) / NULLIF(COALESCE(pz."2024_06", 0) + COALESCE(pda."2024_06", 0), 0) END as factor_pz_2024_06,
            CASE WHEN COALESCE(pz."2024_07", 0) + COALESCE(pda."2024_07", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_07", 0) / NULLIF(COALESCE(pz."2024_07", 0) + COALESCE(pda."2024_07", 0), 0) END as factor_pz_2024_07,
            CASE WHEN COALESCE(pz."2024_08", 0) + COALESCE(pda."2024_08", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_08", 0) / NULLIF(COALESCE(pz."2024_08", 0) + COALESCE(pda."2024_08", 0), 0) END as factor_pz_2024_08,
            CASE WHEN COALESCE(pz."2024_09", 0) + COALESCE(pda."2024_09", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_09", 0) / NULLIF(COALESCE(pz."2024_09", 0) + COALESCE(pda."2024_09", 0), 0) END as factor_pz_2024_09,
            CASE WHEN COALESCE(pz."2024_10", 0) + COALESCE(pda."2024_10", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_10", 0) / NULLIF(COALESCE(pz."2024_10", 0) + COALESCE(pda."2024_10", 0), 0) END as factor_pz_2024_10,
            CASE WHEN COALESCE(pz."2024_11", 0) + COALESCE(pda."2024_11", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_11", 0) / NULLIF(COALESCE(pz."2024_11", 0) + COALESCE(pda."2024_11", 0), 0) END as factor_pz_2024_11,
            CASE WHEN COALESCE(pz."2024_12", 0) + COALESCE(pda."2024_12", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_12", 0) / NULLIF(COALESCE(pz."2024_12", 0) + COALESCE(pda."2024_12", 0), 0) END as factor_pz_2024_12
        FROM 
            (SELECT * FROM silver.produccion_tdv WHERE "AP_ID" = 27) pz
        CROSS JOIN
            (SELECT * FROM silver.produccion_tdv WHERE "AP_ID" = 28) pda
    )
    SELECT * FROM produccion_total;
    
    -- 3.2 Actualizar registro original de ESTAMPADO SERIGRAFICO para que sea (pz)
    -- ‚úÖ CORRECTO: WIP 36, area 17
    UPDATE silver.costos_procesos_tdv_temp c
    SET 
        wip_id = '36',
        wip_name = 'Estampado Pieza',
        area_id = 17,
        subproceso = 'ESTAMPADO   SERIGRAFICO (pz)',
        "2023_01" = c."2023_01" * f.factor_pz_2023_01,
        "2023_02" = c."2023_02" * f.factor_pz_2023_02,
        "2023_03" = c."2023_03" * f.factor_pz_2023_03,
        "2023_04" = c."2023_04" * f.factor_pz_2023_04,
        "2023_05" = c."2023_05" * f.factor_pz_2023_05,
        "2023_06" = c."2023_06" * f.factor_pz_2023_06,
        "2023_07" = c."2023_07" * f.factor_pz_2023_07,
        "2023_08" = c."2023_08" * f.factor_pz_2023_08,
        "2023_09" = c."2023_09" * f.factor_pz_2023_09,
        "2023_10" = c."2023_10" * f.factor_pz_2023_10,
        "2023_11" = c."2023_11" * f.factor_pz_2023_11,
        "2023_12" = c."2023_12" * f.factor_pz_2023_12,
        "2024_01" = c."2024_01" * f.factor_pz_2024_01,
        "2024_02" = c."2024_02" * f.factor_pz_2024_02,
        "2024_03" = c."2024_03" * f.factor_pz_2024_03,
        "2024_04" = c."2024_04" * f.factor_pz_2024_04,
        "2024_05" = c."2024_05" * f.factor_pz_2024_05,
        "2024_06" = c."2024_06" * f.factor_pz_2024_06,
        "2024_07" = c."2024_07" * f.factor_pz_2024_07,
        "2024_08" = c."2024_08" * f.factor_pz_2024_08,
        "2024_09" = c."2024_09" * f.factor_pz_2024_09,
        "2024_10" = c."2024_10" * f.factor_pz_2024_10,
        "2024_11" = c."2024_11" * f.factor_pz_2024_11,
        "2024_12" = c."2024_12" * f.factor_pz_2024_12
    FROM temp_factor_estampado_serigrafico f
    WHERE c.wip_id = '44' AND c.area_id = 22 AND c.subproceso = 'ESTAMPADO   SERIGRAFICO';
    
    -- 3.3 Insertar nuevo registro para ESTAMPADO SERIGRAFICO (pda)
    -- ‚úÖ CORREGIDO: Cambiado a WIP 44, area 18
    INSERT INTO silver.costos_procesos_tdv_temp
    SELECT 
        '44' as wip_id,  -- ‚úÖ CORREGIDO: era '36', ahora '44'
        'Estampado Prendas' as wip_name,  -- ‚úÖ CORREGIDO: nombre apropiado
        c.grupo,
        18 as area_id,
        'ESTAMPADO   SERIGRAFICO (pda)' as subproceso,
        c."2023_01" * (1 - f.factor_pz_2023_01),
        c."2023_02" * (1 - f.factor_pz_2023_02),
        c."2023_03" * (1 - f.factor_pz_2023_03),
        c."2023_04" * (1 - f.factor_pz_2023_04),
        c."2023_05" * (1 - f.factor_pz_2023_05),
        c."2023_06" * (1 - f.factor_pz_2023_06),
        c."2023_07" * (1 - f.factor_pz_2023_07),
        c."2023_08" * (1 - f.factor_pz_2023_08),
        c."2023_09" * (1 - f.factor_pz_2023_09),
        c."2023_10" * (1 - f.factor_pz_2023_10),
        c."2023_11" * (1 - f.factor_pz_2023_11),
        c."2023_12" * (1 - f.factor_pz_2023_12),
        c."2024_01" * (1 - f.factor_pz_2024_01),
        c."2024_02" * (1 - f.factor_pz_2024_02),
        c."2024_03" * (1 - f.factor_pz_2024_03),
        c."2024_04" * (1 - f.factor_pz_2024_04),
        c."2024_05" * (1 - f.factor_pz_2024_05),
        c."2024_06" * (1 - f.factor_pz_2024_06),
        c."2024_07" * (1 - f.factor_pz_2024_07),
        c."2024_08" * (1 - f.factor_pz_2024_08),
        c."2024_09" * (1 - f.factor_pz_2024_09),
        c."2024_10" * (1 - f.factor_pz_2024_10),
        c."2024_11" * (1 - f.factor_pz_2024_11),
        c."2024_12" * (1 - f.factor_pz_2024_12)
    FROM silver.costos_procesos_tdv c
    CROSS JOIN temp_factor_estampado_serigrafico f
    WHERE c.wip_id = '44' AND c.area_id = 22 AND c.subproceso = 'ESTAMPADO   SERIGRAFICO';
    
    -- 3.4 Crear factores para SERV ESTAMPADO
    DROP TABLE IF EXISTS temp_factor_serv_estampado;
    CREATE TEMP TABLE temp_factor_serv_estampado AS
    WITH produccion_total AS (
        SELECT 
            CASE WHEN COALESCE(pz."2023_01", 0) + COALESCE(pda."2023_01", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_01", 0) / NULLIF(COALESCE(pz."2023_01", 0) + COALESCE(pda."2023_01", 0), 0) END as factor_pz_2023_01,
            CASE WHEN COALESCE(pz."2023_02", 0) + COALESCE(pda."2023_02", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_02", 0) / NULLIF(COALESCE(pz."2023_02", 0) + COALESCE(pda."2023_02", 0), 0) END as factor_pz_2023_02,
            CASE WHEN COALESCE(pz."2023_03", 0) + COALESCE(pda."2023_03", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_03", 0) / NULLIF(COALESCE(pz."2023_03", 0) + COALESCE(pda."2023_03", 0), 0) END as factor_pz_2023_03,
            CASE WHEN COALESCE(pz."2023_04", 0) + COALESCE(pda."2023_04", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_04", 0) / NULLIF(COALESCE(pz."2023_04", 0) + COALESCE(pda."2023_04", 0), 0) END as factor_pz_2023_04,
            CASE WHEN COALESCE(pz."2023_05", 0) + COALESCE(pda."2023_05", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_05", 0) / NULLIF(COALESCE(pz."2023_05", 0) + COALESCE(pda."2023_05", 0), 0) END as factor_pz_2023_05,
            CASE WHEN COALESCE(pz."2023_06", 0) + COALESCE(pda."2023_06", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_06", 0) / NULLIF(COALESCE(pz."2023_06", 0) + COALESCE(pda."2023_06", 0), 0) END as factor_pz_2023_06,
            CASE WHEN COALESCE(pz."2023_07", 0) + COALESCE(pda."2023_07", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_07", 0) / NULLIF(COALESCE(pz."2023_07", 0) + COALESCE(pda."2023_07", 0), 0) END as factor_pz_2023_07,
            CASE WHEN COALESCE(pz."2023_08", 0) + COALESCE(pda."2023_08", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_08", 0) / NULLIF(COALESCE(pz."2023_08", 0) + COALESCE(pda."2023_08", 0), 0) END as factor_pz_2023_08,
            CASE WHEN COALESCE(pz."2023_09", 0) + COALESCE(pda."2023_09", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_09", 0) / NULLIF(COALESCE(pz."2023_09", 0) + COALESCE(pda."2023_09", 0), 0) END as factor_pz_2023_09,
            CASE WHEN COALESCE(pz."2023_10", 0) + COALESCE(pda."2023_10", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_10", 0) / NULLIF(COALESCE(pz."2023_10", 0) + COALESCE(pda."2023_10", 0), 0) END as factor_pz_2023_10,
            CASE WHEN COALESCE(pz."2023_11", 0) + COALESCE(pda."2023_11", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_11", 0) / NULLIF(COALESCE(pz."2023_11", 0) + COALESCE(pda."2023_11", 0), 0) END as factor_pz_2023_11,
            CASE WHEN COALESCE(pz."2023_12", 0) + COALESCE(pda."2023_12", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2023_12", 0) / NULLIF(COALESCE(pz."2023_12", 0) + COALESCE(pda."2023_12", 0), 0) END as factor_pz_2023_12,
            CASE WHEN COALESCE(pz."2024_01", 0) + COALESCE(pda."2024_01", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_01", 0) / NULLIF(COALESCE(pz."2024_01", 0) + COALESCE(pda."2024_01", 0), 0) END as factor_pz_2024_01,
            CASE WHEN COALESCE(pz."2024_02", 0) + COALESCE(pda."2024_02", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_02", 0) / NULLIF(COALESCE(pz."2024_02", 0) + COALESCE(pda."2024_02", 0), 0) END as factor_pz_2024_02,
            CASE WHEN COALESCE(pz."2024_03", 0) + COALESCE(pda."2024_03", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_03", 0) / NULLIF(COALESCE(pz."2024_03", 0) + COALESCE(pda."2024_03", 0), 0) END as factor_pz_2024_03,
            CASE WHEN COALESCE(pz."2024_04", 0) + COALESCE(pda."2024_04", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_04", 0) / NULLIF(COALESCE(pz."2024_04", 0) + COALESCE(pda."2024_04", 0), 0) END as factor_pz_2024_04,
            CASE WHEN COALESCE(pz."2024_05", 0) + COALESCE(pda."2024_05", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_05", 0) / NULLIF(COALESCE(pz."2024_05", 0) + COALESCE(pda."2024_05", 0), 0) END as factor_pz_2024_05,
            CASE WHEN COALESCE(pz."2024_06", 0) + COALESCE(pda."2024_06", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_06", 0) / NULLIF(COALESCE(pz."2024_06", 0) + COALESCE(pda."2024_06", 0), 0) END as factor_pz_2024_06,
            CASE WHEN COALESCE(pz."2024_07", 0) + COALESCE(pda."2024_07", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_07", 0) / NULLIF(COALESCE(pz."2024_07", 0) + COALESCE(pda."2024_07", 0), 0) END as factor_pz_2024_07,
            CASE WHEN COALESCE(pz."2024_08", 0) + COALESCE(pda."2024_08", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_08", 0) / NULLIF(COALESCE(pz."2024_08", 0) + COALESCE(pda."2024_08", 0), 0) END as factor_pz_2024_08,
            CASE WHEN COALESCE(pz."2024_09", 0) + COALESCE(pda."2024_09", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_09", 0) / NULLIF(COALESCE(pz."2024_09", 0) + COALESCE(pda."2024_09", 0), 0) END as factor_pz_2024_09,
            CASE WHEN COALESCE(pz."2024_10", 0) + COALESCE(pda."2024_10", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_10", 0) / NULLIF(COALESCE(pz."2024_10", 0) + COALESCE(pda."2024_10", 0), 0) END as factor_pz_2024_10,
            CASE WHEN COALESCE(pz."2024_11", 0) + COALESCE(pda."2024_11", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_11", 0) / NULLIF(COALESCE(pz."2024_11", 0) + COALESCE(pda."2024_11", 0), 0) END as factor_pz_2024_11,
            CASE WHEN COALESCE(pz."2024_12", 0) + COALESCE(pda."2024_12", 0) = 0 THEN 0.5 
                 ELSE COALESCE(pz."2024_12", 0) / NULLIF(COALESCE(pz."2024_12", 0) + COALESCE(pda."2024_12", 0), 0) END as factor_pz_2024_12
        FROM 
            (SELECT * FROM silver.produccion_tdv WHERE "AP_ID" = 33) pz
        CROSS JOIN
            (SELECT * FROM silver.produccion_tdv WHERE "AP_ID" = 34) pda
    )
    SELECT * FROM produccion_total;
    
    -- 3.5 Actualizar SERV ESTAMPADO para (pz)
    -- ‚úÖ CORREGIDO: Cambiado a WIP 36, area 18
    UPDATE silver.costos_procesos_tdv_temp c
    SET 
        wip_id = '36',  -- ‚úÖ CORREGIDO: era '44', ahora '36'
        wip_name = 'Estampado Pieza',  -- ‚úÖ CORREGIDO: nombre apropiado
        area_id = 18,
        subproceso = 'SERV ESTAMPADO (pz)',
        "2023_01" = c."2023_01" * f.factor_pz_2023_01,
        "2023_02" = c."2023_02" * f.factor_pz_2023_02,
        "2023_03" = c."2023_03" * f.factor_pz_2023_03,
        "2023_04" = c."2023_04" * f.factor_pz_2023_04,
        "2023_05" = c."2023_05" * f.factor_pz_2023_05,
        "2023_06" = c."2023_06" * f.factor_pz_2023_06,
        "2023_07" = c."2023_07" * f.factor_pz_2023_07,
        "2023_08" = c."2023_08" * f.factor_pz_2023_08,
        "2023_09" = c."2023_09" * f.factor_pz_2023_09,
        "2023_10" = c."2023_10" * f.factor_pz_2023_10,
        "2023_11" = c."2023_11" * f.factor_pz_2023_11,
        "2023_12" = c."2023_12" * f.factor_pz_2023_12,
        "2024_01" = c."2024_01" * f.factor_pz_2024_01,
        "2024_02" = c."2024_02" * f.factor_pz_2024_02,
        "2024_03" = c."2024_03" * f.factor_pz_2024_03,
        "2024_04" = c."2024_04" * f.factor_pz_2024_04,
        "2024_05" = c."2024_05" * f.factor_pz_2024_05,
        "2024_06" = c."2024_06" * f.factor_pz_2024_06,
        "2024_07" = c."2024_07" * f.factor_pz_2024_07,
        "2024_08" = c."2024_08" * f.factor_pz_2024_08,
        "2024_09" = c."2024_09" * f.factor_pz_2024_09,
        "2024_10" = c."2024_10" * f.factor_pz_2024_10,
        "2024_11" = c."2024_11" * f.factor_pz_2024_11,
        "2024_12" = c."2024_12" * f.factor_pz_2024_12
    FROM temp_factor_serv_estampado f
    WHERE c.wip_id = '44' AND c.area_id = 23 AND c.subproceso = 'SERV ESTAMPADO';
    
    -- 3.6 Insertar nuevo registro para SERV ESTAMPADO (pda)
    -- ‚úÖ CORRECTO: WIP 44, area 18
    INSERT INTO silver.costos_procesos_tdv_temp
    SELECT 
        '44' as wip_id,
        'Estampado Prendas' as wip_name,  -- ‚úÖ CORREGIDO: nombre apropiado
        c.grupo,
        18 as area_id,
        'SERV ESTAMPADO (pda)' as subproceso,
        c."2023_01" * (1 - f.factor_pz_2023_01),
        c."2023_02" * (1 - f.factor_pz_2023_02),
        c."2023_03" * (1 - f.factor_pz_2023_03),
        c."2023_04" * (1 - f.factor_pz_2023_04),
        c."2023_05" * (1 - f.factor_pz_2023_05),
        c."2023_06" * (1 - f.factor_pz_2023_06),
        c."2023_07" * (1 - f.factor_pz_2023_07),
        c."2023_08" * (1 - f.factor_pz_2023_08),
        c."2023_09" * (1 - f.factor_pz_2023_09),
        c."2023_10" * (1 - f.factor_pz_2023_10),
        c."2023_11" * (1 - f.factor_pz_2023_11),
        c."2023_12" * (1 - f.factor_pz_2023_12),
        c."2024_01" * (1 - f.factor_pz_2024_01),
        c."2024_02" * (1 - f.factor_pz_2024_02),
        c."2024_03" * (1 - f.factor_pz_2024_03),
        c."2024_04" * (1 - f.factor_pz_2024_04),
        c."2024_05" * (1 - f.factor_pz_2024_05),
        c."2024_06" * (1 - f.factor_pz_2024_06),
        c."2024_07" * (1 - f.factor_pz_2024_07),
        c."2024_08" * (1 - f.factor_pz_2024_08),
        c."2024_09" * (1 - f.factor_pz_2024_09),
        c."2024_10" * (1 - f.factor_pz_2024_10),
        c."2024_11" * (1 - f.factor_pz_2024_11),
        c."2024_12" * (1 - f.factor_pz_2024_12)
    FROM silver.costos_procesos_tdv c
    CROSS JOIN temp_factor_serv_estampado f
    WHERE c.wip_id = '44' AND c.area_id = 23 AND c.subproceso = 'SERV ESTAMPADO';
    
    RAISE NOTICE 'Transformaci√≥n completada. Tabla temporal creada: silver.costos_procesos_tdv_temp';
    RAISE NOTICE 'Resultado esperado:';
    RAISE NOTICE '  - WIP 36 (Estampado Pieza) + area 17 ‚Üí ESTAMPADO SERIGRAFICO (pz)';
    RAISE NOTICE '  - WIP 36 (Estampado Pieza) + area 18 ‚Üí SERV ESTAMPADO (pz)';
    RAISE NOTICE '  - WIP 44 (Estampado Prendas) + area 18 ‚Üí ESTAMPADO SERIGRAFICO (pda)';
    RAISE NOTICE '  - WIP 44 (Estampado Prendas) + area 18 ‚Üí SERV ESTAMPADO (pda)';
    
END;
$procedure$

-------------------------------------------------------------------------------------
